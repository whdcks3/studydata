## 시간 복잡도
시간 복잡도(Time Complexity)는 알고리즘이 실행되는 데 걸리는 시간을 입력 크기(n)에 대한 함수로 표현한 것이다. 즉, 입력 크기가 커질수록 알고리즘의 실행 시간이 얼마나 증가하는지를 수학적으로 나타낸다.

소프트웨어 성능을 분석할 때 중요한 개념이며, 알고리즘을 비교하고 최적의 방법을 선택하는 기준이 된다. 특히 대량의 데이터를 처리해야 하는 경우, 시간 복잡도가 낮은 알고리즘을 선택하는 것이 필수적이다.

### 시간 복잡도가 중요한 이유
실제 프로그램을 실행할 때는 CPU 속도, 운영체제, 캐시 메모리, 컴파일러 최적화 등 다양한 요소가 실행 시간에 영향을 미친다. 따라서 단순히 **실행 시간을 측정하는 것**만으로는 알고리즘의 성능을 정확하게 평가하기 어렵다.

예를 들어, 동일한 알고리즘을 실행하더라도 고성능 컴퓨터에서는 1초, 저사양 컴퓨터에서는 3초가 걸릴 수 있다. 이러한 하드웨어 환경에 따라 변하는 요소를 배제하고, 오직 알고리즘 자체의 효율성만 분석하는 것이 시간 복잡도의 핵심 목적이다.

시간 복잡도를 분석하면 입력 크기가 커질수록 실행 시간이 어떻게 변화하는지 예측할 수 있다. 예를 들어, 입력 크기가 10배 증가할 때 실행 시간이 10배 증가하는 알고리즘과, 100배 증가하는 알고리즘이 있다면, 후자의 알고리즘은 큰 데이터에서 심각한 성능 문제를 일으킬 수 있다.

-----------------
## 시간 복잡도를 어떻게 측정하는가?
시간 복잡도는 **입력 크기(n) 에 따른 연산 횟수의 증가율**을 측정하는 방식으로 정의된다.
```java
// 두 개의 정수를 더하는 함수
int sum(int a, int b) {
    return a + b;
}
```
위 함수는 단 한 번의 덧셈 연산만 수행한다. 입력 크기(n)이 커지더라도 항상 동일한 연산 횟수를 가지므로 O(1), 즉 상수 시간 복잡도(Constant Time Complexity)를 가진다.

반면, 다음과 같은 코드에서는 입력 크기(n)에 따라 실행 시간이 선형적으로 증가한다.
```java
// 배열의 모든 요소를 출력하는 함수
void printElements(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        System.out.println(arr[i]);
    }
}
```
이 함수는 배열의 크기가 n일 때, for 반복문이 n번 실행되므로 O(n) (선형 시간 복잡도, Linear Time Complexity)를 갖는다.<br>
즉, 시간 복잡도를 측정하는 핵심은 코드 내에서 연산이 몇 번 수행되는지 분석하는 것이며, 이를 통해 알고리즘의 성능을 예측할 수 있다.

---------------
## 시간 복잡도 분석이 중요한 이유
알고리즘의 시간 복잡도를 분석하는 것은 작은 데이터에서는 차이가 나지 않지만, 대량의 데이터를 처리할 때 성능 차이가 극명하게 나타나기 때문이다.<br>
예를 들어, n = 1,000,000 (100만)일 때 각 시간 복잡도에 따른 연산 횟수를 비교해보자

|시간 복잡도|연산 횟수 예측|
|:---|:---|
|O(1)|1번|
|O(log n)|약 20번|
|O(n)|1,000,000번|
|O(n log n)|약 20,000,000번|
|O(n²)|1,000,000,000,000번(1조 번)|
위 표처럼, 입력 크기가 커질수록 시간 복잡도가 낮은 알괴즘을 선택하는 것이 중요하다.<br>
특히 O(n²) 이상의 알고리즘은 입력 크기가 커지면 실행이 불가능할 정도로 비효율적일 수 있다.

----------------
## 알고리즘 선택이 중요한 이유
소규모 데이터에서는 어떤 알고리즘을 사용하든 실행 시간이 비슷할 수 있다. 하지만 데이터가 수백만 개 이상으로 증가하면 잘못된 알고리즘을 선택할 경우 실행 시간이 극적으로 증가할 수 있다.<br>
예를 들어, 다음과 같은 문제를 고려해보자.<br>
+ A 알고리즘 : O(n) -> 100만 개 데이터 처리 시 100만 번 연산
+ B 알고리즘 : O(n²) -> 100만 개 데이터 처리 시 1조 번 연산<br>
이 경우, A 알고리즘은 몇초 만에 실행될 수 있지만, B 알고리즘은 몇 시간, 심지어 며칠이 걸릴 수도 있다.<br>
따라서 시간 복잡도가 어떻게 증가하는지 미리 예측하는 것이 필수적이다.

---------------
## 시간 복잡도 분석의 기본 원칙
### 최악, 최선, 평균 경우란 무엇인가?
시간 복잡도를 평가할 때 가장 중요한 개념 중 하나는 최악(Worst Case),최선(Best Case),평균(Average Case) 시간 복잡도이다.<br>
알고리즘은 입력 값에 따라 실행 시간이 달라질 수 있다. 예를 들어, 정렬되지 않은 리스트에서 특정 값을 찾는다고 가정하자.<br>

&nbsp;&nbsp;&nbsp; 만약 우리가 찾으려는 값이 리스트 첫 번째 위치 있다면? -> 이는 **최선의 경우(Best Case)** 이다.<br>
&nbsp;&nbsp;&nbsp; 반대로 찾으려는 값이 리스트의 가장 마지막에 있거나 존재하지 않는다면? -> 이는 **최악의 경우(Worst Case)** 이다.<br>
&nbsp;&nbsp;&nbsp; 보통 입력이 무작위로 주어질 때 걸리는 평균적인 실행 시간을 고려할 수도 있다. -> 이는 **평균의 경우(Average Case)** 이다.

|경우|실행시간|
|:---|:---|
|최선(Best Case)|가장 빠름|
|평균(Average Case)|중간 수준|
|최악(Worst Case)|가장 느림|

시간 복잡도를 분석할 때는 일반적으로 최악의 경우(Worst Case)를 기준으로 분석한다. 그 이유는 **알고리즘이 최악의 입력에서 얼마나 효율적인지**를 평가하는 것이 가장 중요하기 때문이다.

예를 들어, 웹 서비스에서 검색 기능을 제공할 때, 최악의 경우 매우 오래 걸린다면 사용자 경험이 나빠질 수 있다. 따라서 일반적으로 시간 복잡도를 평가할 때는 최악의 경우를 고려하는 것이 일반적이다.

----------------
## 주요 연산 기준 분석
시간 복잡도를 분석할 때는 알고리즘에서 가장 중요한 연산을 기준으로 연산 횟수를 측정한다.<br>
주요 연산이란 알고리즘의 실행 시간을 결정하는 핵심적인 연산을 의미하며, 보통 다음과 같은 연산들이 분석 대상이 된다.
+ **대입(Assignment)** : 변수를 할당하는 연산(x = 10;)
+ **비교(Comparison)** : 두 값을 비교하는 연산(if (a > b) {...})
+ **반복(Looping)** : 반복문이 실행되는 횟수(for, while)
+ **재귀 호출** : 재귀적으로 함수를 호출하는 경우 (f(n) = f(n - 1) + f(n - 2))
+ **기본 연산** : 덧셈, 뺄셈, 곱셈, 나눗셈(a + b, a * b)

예제 : 선형 탐색(Linear Search)
```java
// 배열에서 특정한 값을 찾는 선형 탐색 함수
public static int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {  // n번 반복
        if (arr[i] == target) { // 비교 연산
            return i;  // 값이 발견되면 인덱스 반환
        }
    }
    return -1; // 값을 찾지 못한 경우
}
```
이 코드에서 시간 복잡도를 분석해보자<br>
**최선의 경우(Best Case)** <br>
&nbsp;&nbsp;&nbsp; 찾는 값이 배열의 첫 번째 요소에 있는 경우<br>
&nbsp;&nbsp;&nbsp; 비교 연산이 한 번만 수행되므로 O(1)의 시간 복잡도를 가짐

**최악의 경우(Worst Case)** <br>
&nbsp;&nbsp;&nbsp; 찾는 값이 배열의 마지막 요소에 있거나 배열에 존재하지 않는 경우<br>
&nbsp;&nbsp;&nbsp; 배열의 모든 요소를 탐색해야 하므로 O(n)의 시간 복잡도를 가짐

**평균적인 경우(Average Case)** <br>
&nbsp;&nbsp;&nbsp; 찾는 값이 배열의 중간쯤에 위치하는 경우<br>
&nbsp;&nbsp;&nbsp; 평균적으로 배열 길이의 절반만큼(n/2) 탐색하므로 O(n)의 시간 복잡도를 가짐<br>
&nbsp;&nbsp;&nbsp; 하지만 빅-오 표기법에서는 상수를 무시하므로 O(n)으로 표현됨

이처럼 시간 복잡도를 분석할 때는 반복문이 몇 번 실행되는지, 비교 연산이 몇 번 수행되는지를 기준으로 분석한다.

---------------
## 시간 복잡도를 분석하는 일반적인 과정
**반복문이 몇 번 실행되는지 확인**<br>
&nbsp;&nbsp;&nbsp; 반복문이 1개이면 O(n)
&nbsp;&nbsp;&nbsp; 반복문이 중첩되어 있으면 O(n²)등으로 계산 가능

**주요 연산(비교,대입,산술 연산)의 횟수 확인**<br>
&nbsp;&nbsp;&nbsp; if문, while 문 등의 비교 연산이 몇 번 수행되는지 고려

**재귀 호출이 있는 경우 호출 횟수 계산**<br>
&nbsp;&nbsp;&nbsp; 재귀 호출이 ```f(n) = f(n - 1) + f(n - 2)```와 같은 형태라면 피보나치 수열과 유사한 O(2ⁿ)의 시간 복잡도를 가질 가능성이 높음

-----------------
