## 시간 복잡도
시간 복잡도(Time Complexity)는 알고리즘이 실행되는 데 걸리는 시간을 입력 크기(n)에 대한 함수로 표현한 것이다. 즉, 입력 크기가 커질수록 알고리즘의 실행 시간이 얼마나 증가하는지를 수학적으로 나타낸다.

소프트웨어 성능을 분석할 때 중요한 개념이며, 알고리즘을 비교하고 최적의 방법을 선택하는 기준이 된다. 특히 대량의 데이터를 처리해야 하는 경우, 시간 복잡도가 낮은 알고리즘을 선택하는 것이 필수적이다.

### 시간 복잡도가 중요한 이유
실제 프로그램을 실행할 때는 CPU 속도, 운영체제, 캐시 메모리, 컴파일러 최적화 등 다양한 요소가 실행 시간에 영향을 미친다. 따라서 단순히 **실행 시간을 측정하는 것**만으로는 알고리즘의 성능을 정확하게 평가하기 어렵다.

예를 들어, 동일한 알고리즘을 실행하더라도 고성능 컴퓨터에서는 1초, 저사양 컴퓨터에서는 3초가 걸릴 수 있다. 이러한 하드웨어 환경에 따라 변하는 요소를 배제하고, 오직 알고리즘 자체의 효율성만 분석하는 것이 시간 복잡도의 핵심 목적이다.

시간 복잡도를 분석하면 입력 크기가 커질수록 실행 시간이 어떻게 변화하는지 예측할 수 있다. 예를 들어, 입력 크기가 10배 증가할 때 실행 시간이 10배 증가하는 알고리즘과, 100배 증가하는 알고리즘이 있다면, 후자의 알고리즘은 큰 데이터에서 심각한 성능 문제를 일으킬 수 있다.

-----------------
## 시간 복잡도를 어떻게 측정하는가?
시간 복잡도는 **입력 크기(n) 에 따른 연산 횟수의 증가율**을 측정하는 방식으로 정의된다.
```java
// 두 개의 정수를 더하는 함수
int sum(int a, int b) {
    return a + b;
}
```
위 함수는 단 한 번의 덧셈 연산만 수행한다. 입력 크기(n)이 커지더라도 항상 동일한 연산 횟수를 가지므로 O(1), 즉 상수 시간 복잡도(Constant Time Complexity)를 가진다.

반면, 다음과 같은 코드에서는 입력 크기(n)에 따라 실행 시간이 선형적으로 증가한다.
```java
// 배열의 모든 요소를 출력하는 함수
void printElements(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        System.out.println(arr[i]);
    }
}
```
이 함수는 배열의 크기가 n일 때, for 반복문이 n번 실행되므로 O(n) (선형 시간 복잡도, Linear Time Complexity)를 갖는다.<br>
즉, 시간 복잡도를 측정하는 핵심은 코드 내에서 연산이 몇 번 수행되는지 분석하는 것이며, 이를 통해 알고리즘의 성능을 예측할 수 있다.

---------------
## 시간 복잡도 분석이 중요한 이유
알고리즘의 시간 복잡도를 분석하는 것은 작은 데이터에서는 차이가 나지 않지만, 대량의 데이터를 처리할 때 성능 차이가 극명하게 나타나기 때문이다.<br>
예를 들어, n = 1,000,000 (100만)일 때 각 시간 복잡도에 따른 연산 횟수를 비교해보자
|시간 복잡도|연산 횟수 예측|
|:---|:---|
|O(1)|1번|
|O(log n)|약 20번|
|O(n)|1,000,000번|
|O(n log n)|약 20,000,000번|
|O(n²)|1,000,000,000,000번(1조 번)|
위 표처럼, 입력 크기가 커질수록 시간 복잡도가 낮은 알괴즘을 선택하는 것이 중요하다.<br>
특히 O(n²) 이상의 알고리즘은 입력 크기가 커지면 실행이 불가능할 정도로 비효율적일 수 있다.
