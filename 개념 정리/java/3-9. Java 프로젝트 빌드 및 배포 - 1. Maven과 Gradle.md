1. Maven의 기본 개념과 구조
1.1 Maven의 개념
Maven의 정의
Maven은 Java 프로젝트 관리 및 빌드 도구로, 개발 과정에서 발생하는 반복적인 작업(예: 빌드, 테스트, 패키징, 배포)을 자동화하고, 의존성 관리를 단순화하기 위해 설계되었다. Apache Software Foundation에서 유지보수하며, Java뿐만 아니라 다양한 JVM 기반 언어와도 호환된다.

Maven은 단순한 빌드 도구에 그치지 않고, 프로젝트 관리 도구로서 역할을 한다. 프로젝트의 메타정보를 정의하는 파일(POM)을 통해 프로젝트 구조를 표준화하고, 협업 환경에서 일관성을 유지하며, 팀원들이 동일한 환경에서 작업할 수 있도록 돕는다.

Maven의 목적과 중요성
Maven이 필요한 이유는 소프트웨어 개발에서 발생하는 다음과 같은 문제를 해결하기 위해서다:

의존성 관리의 복잡성
Java 애플리케이션은 다양한 외부 라이브러리(예: Spring, Hibernate)를 필요로 한다.
Maven 이전에는 필요한 라이브러리를 직접 다운로드하고, 이를 프로젝트에 추가하는 과정이 수작업으로 이루어졌다. 특히, 라이브러리 간의 버전 충돌 문제가 발생했을 때 이를 해결하는 과정이 복잡하고 시간이 많이 소요되었다. Maven은 이러한 문제를 해결하기 위해 중앙 저장소와 로컬 저장소를 사용하여 자동으로 의존성을 관리한다.

프로젝트 구조 표준화
개발자가 프로젝트를 새로 생성할 때 디렉토리 구조가 일관되지 않은 경우가 많았다. Maven은 표준 디렉토리 구조를 제공하여 모든 프로젝트가 동일한 방식으로 구성되도록 한다. 이를 통해 협업의 효율성을 높이고, 새로운 개발자가 프로젝트에 빠르게 적응할 수 있도록 한다.

반복적인 작업 자동화
소스 코드의 컴파일, 테스트 실행, JAR/WAR 파일 생성, 배포와 같은 작업은 반복적으로 발생한다. Maven은 이러한 작업을 자동화하여 개발자가 비즈니스 로직에 더 집중할 수 있도록 한다.

Maven의 주요 특징
POM 파일 기반 프로젝트 관리
Maven은 모든 프로젝트를 관리하기 위해 POM (Project Object Model) 이라는 XML 기반 설정 파일을 사용한다.
POM 파일에는 프로젝트의 메타정보, 의존성, 빌드 플러그인 등이 정의되며, 이를 통해 프로젝트의 모든 설정을 한곳에서 관리할 수 있다.

의존성 관리 자동화
Maven은 의존성 정보를 POM 파일에 선언하면, 중앙 저장소에서 필요한 라이브러리를 자동으로 다운로드하고 프로젝트에 추가한다. 또한, 의존성 간의 충돌을 해결하기 위한 메커니즘도 제공한다.

표준 디렉토리 구조 제공
Maven은 프로젝트의 디렉토리 구조를 표준화하여 모든 프로젝트가 동일한 방식으로 구성되도록 한다.
Maven 표준 디렉토리 구조 예:

project/
├── src/
│   ├── main/
│   │   ├── java/           // 애플리케이션 소스 코드
│   │   └── resources/      // 리소스 파일 (예: 설정 파일)
│   └── test/
│       ├── java/           // 테스트 코드
│       └── resources/      // 테스트용 리소스 파일
└── target/                 // 빌드 결과물이 저장되는 디렉토리
빌드 라이프사이클 관리
Maven은 빌드 과정을 단계별로 나누어 관리한다.

클린(clean): 이전 빌드 결과물을 삭제.
컴파일(compile): 소스 코드를 컴파일.
테스트(test): 단위 테스트 실행.
패키지(package): 컴파일된 코드를 JAR 또는 WAR 파일로 패키징.
설치(install): 결과물을 로컬 저장소에 설치.
배포(deploy): 중앙 저장소에 배포.
다양한 플러그인 지원
Maven은 다양한 플러그인을 통해 빌드와 관련된 작업을 확장할 수 있다. 예를 들어, maven-compiler-plugin은 컴파일 작업을, maven-surefire-plugin은 테스트 작업을 수행한다.

Maven의 동작 방식
Maven은 다음과 같은 단계를 통해 프로젝트를 관리한다:

POM 파일 분석
Maven은 프로젝트 디렉토리에서 pom.xml 파일을 읽어 프로젝트의 의존성, 플러그인, 빌드 설정 등을 파악한다.

의존성 다운로드
POM 파일에 선언된 의존성 정보를 바탕으로, 중앙 저장소(예: Maven Central)에서 필요한 라이브러리를 다운로드한다. 다운로드된 라이브러리는 로컬 저장소(~/.m2/repository)에 저장되며, 동일한 의존성을 사용하는 다른 프로젝트에서도 재사용된다.

플러그인 실행
Maven은 빌드 라이프사이클의 각 단계에서 필요한 플러그인을 실행한다. 예를 들어, mvn compile 명령어를 실행하면 maven-compiler-plugin이 호출되어 소스 코드를 컴파일한다.

결과물 생성
Maven은 빌드 과정을 거쳐 JAR 또는 WAR 파일과 같은 결과물을 생성하며, 이는 target 디렉토리에 저장된다.

Maven 주요 명령어와 사용 예제
Maven을 사용하는 동안 자주 사용되는 명령어와 그 동작은 다음과 같다:

mvn clean
기존 빌드 결과물을 삭제하는 명령어로, target 디렉토리를 제거한다.

mvn clean
mvn compile
프로젝트의 소스 코드를 컴파일한다. 결과물은 target/classes 디렉토리에 저장된다.

mvn compile
mvn package
프로젝트를 패키징하여 JAR 또는 WAR 파일을 생성한다.

mvn package
mvn install
생성된 패키지를 로컬 저장소에 설치하여, 다른 프로젝트에서 이를 의존성으로 사용할 수 있도록 한다.

mvn install
mvn deploy
패키지를 중앙 저장소에 업로드하여, 팀원들이 이를 다운로드하여 사용할 수 있도록 한다.

mvn deploy
코드 예제: Maven 프로젝트의 POM 파일과 명령어 실행
다음은 Maven 프로젝트에서 pom.xml 파일과 명령어를 사용하는 예제이다.

1. pom.xml 파일 생성
pom.xml 파일은 프로젝트의 메타정보와 설정을 포함한다. 아래는 간단한 예제이다:

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>simple-app</artifactId>
    <version>1.0.0</version>
</project>
2. Maven 명령어 실행

# 기존 빌드 결과물을 삭제
$ mvn clean

# 소스 코드 컴파일
$ mvn compile

# 패키징(JAR 파일 생성)
$ mvn package

# 로컬 저장소에 설치
$ mvn install
3. 실행 결과 확인

mvn clean: target 디렉토리 삭제.
mvn compile: 컴파일된 클래스 파일이 target/classes에 생성.
mvn package: JAR 파일이 target/simple-app-1.0.0.jar로 생성.
mvn install: 생성된 JAR 파일이 로컬 저장소(~/.m2/repository/com/example/simple-app/1.0.0/)에 저장.
Maven을 선택해야 하는 이유
Maven은 다음과 같은 상황에서 특히 유용하다:

대규모 프로젝트 관리
다수의 모듈로 구성된 프로젝트에서, 각 모듈 간 의존성을 명확히 정의하고 관리할 수 있다.

협업 환경에서의 일관성
표준화된 프로젝트 구조와 설정 파일을 통해, 팀원 간의 협업을 원활히 한다.

반복 작업 최소화
빌드, 테스트, 배포와 같은 반복적인 작업을 자동화하여, 개발자가 비즈니스 로직에 집중할 수 있도록 한다.

학습자의 사고를 돕기 위한 질문
Maven이 제공하는 주요 기능 중 빌드 자동화가 대규모 프로젝트에서 어떤 이점을 제공할 수 있는지 설명하라.

팀 단위 협업과 프로젝트 구조의 일관성을 고려해보라.
Maven이 종속성 관리를 통해 개발자에게 제공하는 편리함은 무엇인가?

수동으로 라이브러리를 관리하는 경우와 비교해보라.
1.2 Maven의 주요 구성 요소
POM 파일(pom.xml)
Maven의 핵심은 POM (Project Object Model) 파일이다. pom.xml은 프로젝트의 메타정보, 빌드 설정, 의존성, 플러그인 등을 XML 형식으로 정의하며, Maven 프로젝트의 중심 역할을 한다. POM 파일은 Maven이 프로젝트를 이해하고 빌드를 수행하는 데 필요한 모든 정보를 담고 있다.

POM 파일의 구조
pom.xml 파일은 다음과 같은 주요 태그들로 구성된다:

<project>:
POM 파일의 루트 태그로, 모든 Maven 프로젝트는 이 태그로 시작한다. XML 네임스페이스 정보와 스키마 정의를 포함한다.

<modelVersion>:
POM 파일의 모델 버전을 지정하며, 현재 Maven 3.x에서는 4.0.0을 사용한다.

<groupId>, <artifactId>, <version>:
Maven 프로젝트를 식별하는 핵심 메타데이터로, 프로젝트를 고유하게 정의하는 데 사용된다.

<groupId>: 프로젝트가 속한 그룹이나 조직의 고유 식별자. 일반적으로 도메인명을 역순으로 사용한다(예: com.example).
<artifactId>: 프로젝트의 이름. JAR 파일 또는 WAR 파일의 이름에 반영된다.
<version>: 프로젝트의 버전. 일반적으로 1.0.0, 1.0.0-SNAPSHOT과 같은 형식을 사용한다.
<dependencies>:
프로젝트에서 사용하는 라이브러리 의존성을 정의하는 블록이다.
각 의존성은 <dependency> 태그 안에 <groupId>, <artifactId>, <version> 정보를 포함한다.

<build>:
빌드 관련 설정을 정의하며, 컴파일러 플러그인, 출력 디렉토리 등을 설정할 수 있다.

<repositories>:
추가적인 원격 저장소를 정의하여 Maven이 의존성을 검색하는 경로를 확장할 수 있다.

POM 파일의 예제
다음은 간단한 POM 파일의 예제이다. 이 파일은 com.example 그룹의 sample-app이라는 아티팩트를 정의하며, 버전은 1.0.0이다.

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>sample-app</artifactId>
    <version>1.0.0</version>

    <dependencies>
        <!-- JUnit 의존성 추가 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
주요 태그의 역할
<groupId>, <artifactId>, <version>

이 세 가지는 Maven 프로젝트를 고유하게 식별한다.
Maven Central Repository나 로컬 저장소에 배포된 모든 프로젝트는 이 정보를 사용하여 구분된다.
예: 위의 POM 파일에서 생성된 JAR 파일은 다음 경로에 저장된다:

~/.m2/repository/com/example/sample-app/1.0.0/sample-app-1.0.0.jar
<dependencies>

프로젝트에서 필요한 외부 라이브러리를 정의한다.
<scope> 태그를 사용하여 의존성의 사용 범위를 설정할 수 있다.
compile: 기본 스코프. 컴파일 및 런타임에 필요.
test: 테스트 시에만 필요.
provided: 컴파일 시 필요하지만, 런타임 시에는 컨테이너(예: Tomcat)에서 제공됨.
runtime: 런타임에만 필요.
<build>

Maven 빌드 과정을 정의하는 영역이다.
위의 예제에서 maven-compiler-plugin은 소스 코드와 타겟 JDK 버전을 설정하는 데 사용되었다.
<source>와 <target>을 각각 11로 설정하면 Java 11 소스와 타겟 클래스 파일을 사용하도록 설정된다.
의존성 관리의 기본 원리
Maven은 의존성을 관리하기 위해 로컬 저장소와 중앙 저장소를 활용한다.

로컬 저장소:
Maven은 의존성을 먼저 로컬 저장소(~/.m2/repository)에서 검색한다.
로컬 저장소에 없는 경우, 중앙 저장소에서 다운로드한 뒤 로컬 저장소에 캐싱한다.

중앙 저장소:
기본적으로 Maven은 Maven Central Repository를 사용한다. 이 저장소는 널리 사용되는 라이브러리를 호스팅하며, pom.xml 파일에 의존성을 선언하면 Maven이 중앙 저장소에서 라이브러리를 다운로드한다.

중복 의존성 처리:
Maven은 의존성 트리를 분석하여 중복된 의존성을 제거한다. 이 과정은 "의존성 해결(Dependency Resolution)"이라고 하며, 프로젝트 빌드 시 중요한 역할을 한다.

코드 예제: Maven 의존성 트리 확인
Maven은 프로젝트의 의존성 트리를 시각화할 수 있는 기능을 제공한다.
예를 들어, 다음 명령어를 실행하면 프로젝트의 모든 의존성을 트리 형태로 확인할 수 있다:

mvn dependency:tree
출력 예제:

[INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ sample-app ---
[INFO] com.example:sample-app:jar:1.0.0
[INFO] \- junit:junit:jar:4.13.2:test
[INFO]    \- org.hamcrest:hamcrest-core:jar:1.3:compile
결론
POM 파일은 Maven 프로젝트의 핵심이며, 프로젝트의 의존성, 빌드 설정, 플러그인 등을 정의하는 역할을 한다. 이를 통해 개발자는 반복적인 작업을 줄이고, 프로젝트 관리를 더욱 효율적으로 수행할 수 있다.

종속성 관리
Maven은 프로젝트 개발에 필요한 외부 라이브러리를 손쉽게 관리할 수 있도록 설계되었다. 종속성 관리 기능은 Maven의 가장 중요한 특징 중 하나이며, 이를 통해 개발자는 수동으로 라이브러리를 추가하거나 의존성 충돌 문제를 해결하는 부담을 덜 수 있다.

종속성 관리란?
종속성 관리란 프로젝트에서 필요한 외부 라이브러리와 이를 포함한 다른 모듈들을 체계적으로 관리하는 것을 의미한다. Maven은 이를 XML 기반의 <dependencies> 블록을 통해 설정한다. <dependencies> 안에 선언된 모든 항목은 빌드 과정에서 Maven이 자동으로 다운로드하고 관리한다.

<dependencies> 태그
Maven 프로젝트에서 외부 라이브러리를 포함하려면 <dependencies> 태그를 사용한다. 이 태그는 여러 개의 <dependency> 태그를 포함할 수 있다. 각 <dependency>는 하나의 외부 라이브러리를 나타내며, 다음 세 가지 필수 정보를 포함해야 한다.

<groupId>: 라이브러리를 식별하는 그룹 ID. 보통 조직이나 회사의 도메인 이름을 반대로 사용한다(예: org.apache.commons).
<artifactId>: 라이브러리 이름. 프로젝트의 실제 이름을 나타낸다(예: commons-lang3).
<version>: 라이브러리의 버전. 특정 버전을 지정해야 한다(예: 3.12.0).
종속성 선언 예제
다음은 Apache Commons Lang 라이브러리를 추가하는 예제이다. 이 라이브러리는 문자열 조작, 숫자 변환 등의 유틸리티를 제공한다.

<dependencies>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.12.0</version>
    </dependency>
</dependencies>
위의 코드를 pom.xml에 추가하면, Maven은 Apache Commons Lang 라이브러리를 자동으로 다운로드하여 프로젝트에 포함한다. 다운로드된 파일은 로컬 저장소에 캐싱되며, 이후 빌드 시 반복적으로 다운로드할 필요가 없다.

의존성의 스코프(Scope)
Maven에서는 종속성을 사용하는 범위를 지정하기 위해 <scope> 태그를 사용한다. 이는 특정 의존성을 컴파일, 테스트, 런타임 등 특정 단계에서만 사용할 수 있도록 설정할 수 있다.

스코프의 종류
compile

기본 스코프.
컴파일, 테스트, 런타임 모든 단계에서 사용 가능.
별도로 설정하지 않으면 기본값으로 사용된다.
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
    <scope>compile</scope>
</dependency>
test

테스트 시에만 필요한 라이브러리를 지정한다.
예: JUnit, Mockito와 같은 테스트 라이브러리.
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.13.2</version>
    <scope>test</scope>
</dependency>
provided

런타임 환경에서 제공되는 라이브러리.
예: Servlet API는 애플리케이션 서버(Tomcat 등)가 제공하기 때문에 별도로 포함하지 않아도 된다.
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
</dependency>
runtime

런타임 시에만 필요한 라이브러리.
예: JDBC 드라이버와 같은 실행 시점에 필요한 라이브러리.
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.31</version>
    <scope>runtime</scope>
</dependency>
의존성 트리와 충돌 해결
Maven은 프로젝트에 포함된 모든 의존성을 계층적으로 분석하며, 이를 "의존성 트리"라고 한다. 트리의 일부 라이브러리가 동일한 의존성을 다른 버전으로 요구하면, Maven은 기본적으로 가장 상위 계층의 의존성을 선택한다.

의존성 트리 확인 명령어
의존성 트리를 확인하려면 다음 명령어를 사용한다.

mvn dependency:tree
출력 예제
[INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ sample-app ---
[INFO] com.example:sample-app:jar:1.0.0
[INFO] +- junit:junit:jar:4.13.2:test
[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:compile
[INFO] \- org.apache.commons:commons-lang3:jar:3.12.0:compile
의존성 관리 전략
버전 고정
POM 파일에서 라이브러리의 특정 버전을 고정하는 것이 권장된다. LATEST 또는 RELEASE와 같은 동적인 버전을 사용할 경우, 의도하지 않은 업데이트로 인해 프로젝트가 불안정해질 수 있다.

의존성 제외
특정 의존성이 프로젝트와 충돌할 경우, <exclusions> 태그를 사용하여 제외할 수 있다.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
    <version>2.6.7</version>
    <exclusions>
        <exclusion>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
관리 의존성
<dependencyManagement> 태그를 사용하여 모든 하위 모듈에서 공통적으로 사용하는 의존성을 한 곳에서 관리할 수 있다.

코드 예제: 의존성 충돌 해결
다음은 Spring Framework와 Hibernate 라이브러리가 충돌할 경우, 특정 버전을 명시적으로 지정하는 방법이다.

<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.9</version>
    </dependency>
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>5.4.32.Final</version>
    </dependency>
</dependencies>
결론
Maven의 종속성 관리 기능은 대규모 프로젝트에서 필수적이며, 외부 라이브러리를 효율적으로 관리하고 충돌을 해결하는 데 도움을 준다. <dependencies> 태그와 스코프, 의존성 트리 확인 등을 잘 활용하면 안정적이고 유지보수 가능한 프로젝트를 만들 수 있다.

플러그인
Maven의 플러그인은 빌드 프로세스의 핵심을 구성하는 도구이다. 플러그인은 Maven이 제공하는 다양한 작업(예: 컴파일, 테스트, 패키징 등)을 수행하는 실행 단위이며, 프로젝트의 라이프사이클 단계에서 자동으로 호출되거나 명시적으로 실행할 수 있다. Maven의 플러그인 시스템은 확장 가능하며, 개발자가 필요에 따라 커스텀 플러그인을 작성하여 사용할 수도 있다.

플러그인이란?
플러그인은 Maven이 제공하는 명령 기반 작업 단위이다. 이를 통해 개발자는 반복 작업을 자동화하고 프로젝트 관리를 효율적으로 수행할 수 있다. Maven은 기본적으로 제공하는 표준 플러그인뿐만 아니라 외부 플러그인도 지원한다.

예를 들어, 프로젝트 빌드를 위해 maven-compiler-plugin이 사용되며, JAR 파일 생성을 위해 maven-jar-plugin이 사용된다. 이러한 플러그인은 pom.xml 파일에 추가되어 설정과 함께 사용된다.

주요 Maven 플러그인
Maven에서 자주 사용되는 플러그인은 다음과 같다:

maven-compiler-plugin

역할: 소스 코드를 컴파일한다.
기본 동작: src/main/java에 있는 코드를 컴파일하여 .class 파일로 변환한다.
설정 예제:
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.8.1</version>
            <configuration>
                <source>11</source> <!-- Java 소스 버전 -->
                <target>11</target> <!-- 출력 대상 버전 -->
            </configuration>
        </plugin>
    </plugins>
</build>
maven-surefire-plugin

역할: 테스트를 실행한다.
기본 동작: JUnit이나 TestNG와 같은 테스트 프레임워크를 사용하여 테스트를 수행한다.
설정 예제:
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.22.2</version>
        </plugin>
    </plugins>
</build>
maven-jar-plugin

역할: 컴파일된 코드를 기반으로 JAR 파일을 생성한다.
설정 예제:
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jar-plugin</artifactId>
            <version>3.2.0</version>
        </plugin>
    </plugins>
</build>
maven-clean-plugin

역할: 이전 빌드에서 생성된 파일(target 디렉토리 등)을 삭제한다.
기본 동작: 빌드 전 깨끗한 환경을 유지한다.
설정 예제:
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-clean-plugin</artifactId>
            <version>3.1.0</version>
        </plugin>
    </plugins>
</build>
maven-dependency-plugin

역할: 프로젝트 종속성을 관리하고 의존성을 다운로드하거나 내보낸다.
설정 예제:
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-dependency-plugin</artifactId>
            <version>3.1.2</version>
        </plugin>
    </plugins>
</build>
플러그인 실행 방식
Maven 플러그인은 명령어로 실행하거나 프로젝트의 라이프사이클 단계에 포함되어 자동으로 실행될 수 있다.

명령어로 실행
플러그인은 Maven 명령어를 통해 직접 실행할 수 있다. 예를 들어, maven-compiler-plugin을 사용하여 코드를 컴파일하려면 다음과 같은 명령을 실행한다.

mvn compile
이 명령은 Maven의 기본 라이프사이클 단계에서 maven-compiler-plugin을 호출한다.

라이프사이클 단계와 플러그인
Maven 프로젝트는 default, clean, site라는 세 가지 라이프사이클로 구성되며, 각 라이프사이클에는 여러 단계가 포함된다. 특정 단계에서 플러그인이 호출되어 작업을 수행한다.

예:

compile 단계: maven-compiler-plugin이 소스 코드를 컴파일한다.
test 단계: maven-surefire-plugin이 테스트를 실행한다.
package 단계: maven-jar-plugin이 JAR 파일을 생성한다.
플러그인 사용자 정의
Maven 플러그인은 기본 동작을 설정할 수 있지만, 프로젝트 요구사항에 따라 추가 설정을 통해 동작을 커스터마이징할 수도 있다.

예제: 사용자 정의 컴파일 플러그인
다음은 Java 17 소스를 컴파일하기 위해 maven-compiler-plugin을 커스터마이징한 예제이다.

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.8.1</version>
            <configuration>
                <source>17</source> <!-- Java 소스 버전 -->
                <target>17</target> <!-- 출력 대상 버전 -->
                <compilerArgs>
                    <arg>-Xlint:unchecked</arg> <!-- 컴파일 시 경고를 출력 -->
                </compilerArgs>
            </configuration>
        </plugin>
    </plugins>
</build>
이 설정은 Java 17을 사용하며, 컴파일 시 unchecked 경고를 표시하도록 설정한 예제이다.

결론
Maven의 플러그인은 프로젝트 관리와 빌드를 자동화하고 효율적으로 수행할 수 있게 해주는 핵심 도구이다. 플러그인을 통해 반복 작업을 최소화하고 프로젝트의 라이프사이클 단계에서 필요한 작업을 자동화할 수 있다. 각 플러그인의 설정과 활용 방식을 잘 이해하면 프로젝트를 더욱 안정적으로 관리할 수 있다.

학습자의 사고를 돕기 위한 질문
pom.xml 파일에서 <groupId>, <artifactId>, <version>이 각각 어떤 역할을 하는지 설명하라.

예를 들어, org.springframework, spring-core, 5.3.8으로 구성된 Maven 좌표를 분석해보라.
Maven 플러그인은 빌드 프로세스를 자동화하는 데 어떻게 기여하는가?

플러그인을 활용한 빌드, 테스트, 패키징의 효율성을 떠올려보라.
실습 문제
문제 1: 간단한 POM 파일 작성
다음 요구사항에 따라 POM 파일을 작성하시오.

프로젝트 이름: my-first-maven-project
그룹 ID: com.example
아티팩트 ID: maven-demo
버전: 1.0-SNAPSHOT
작성된 POM 파일은 아래와 같은 형식으로 출력되어야 한다:

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>maven-demo</artifactId>
  <version>1.0-SNAPSHOT</version>
</project>
문제 2: Maven 플러그인 추가
다음 요구사항을 만족하는 POM 파일을 작성하시오.

플러그인 이름: maven-compiler-plugin
컴파일러 버전: 11
POM 파일에 추가된 플러그인의 기본 설정은 다음과 같아야 한다:
<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.8.1</version>
      <configuration>
        <source>11</source>
        <target>11</target>
      </configuration>
    </plugin>
  </plugins>
</build>
2.1. Gradle의 개념
Gradle의 정의
Gradle은 Groovy 및 Kotlin DSL(Domain-Specific Language)을 기반으로 하는 빌드 도구이다. Maven과 유사하게 빌드 자동화와 종속성 관리를 주요 목적으로 사용되며, 특히 유연성과 확장성이 강조되는 대규모 프로젝트에서 적합하다.

Gradle의 특징
태스크(Task) 기반 빌드 시스템
Gradle은 태스크라는 단위로 작업을 정의하고, 이 태스크를 조합하여 빌드 프로세스를 구성한다. 각각의 태스크는 독립적으로 실행될 수 있으며, 특정 태스크가 완료된 후 다른 태스크가 실행되도록 의존성을 설정할 수 있다.

유연성과 확장성
Gradle은 Groovy와 Kotlin DSL을 사용하여 빌드 스크립트를 작성하며, 이러한 스크립트는 프로그래밍 언어의 특성을 활용해 매우 유연하게 빌드 로직을 정의할 수 있다. 필요한 경우 사용자 정의 태스크를 작성하거나 플러그인을 통해 기능을 확장할 수도 있다.

선언적 및 명령적 스타일 혼합
Gradle은 Maven처럼 선언적 방식으로 의존성을 관리할 뿐만 아니라, 명령적 방식으로 빌드 과정을 정의할 수 있다. 이로 인해 복잡한 빌드 요구사항도 쉽게 구현할 수 있다.

빠른 빌드 성능
Gradle은 증분 빌드(incremental build)와 빌드 캐싱(build caching)을 지원하여 반복적인 빌드 작업의 속도를 대폭 향상시킨다.

다양한 언어와 플랫폼 지원
Gradle은 Java뿐만 아니라 Kotlin, Groovy, Scala 등 다양한 JVM 기반 언어를 지원하며, 안드로이드 및 네이티브 프로젝트에도 사용할 수 있다.

Gradle의 주요 용도
빌드 자동화
Gradle은 소스 코드 컴파일, 테스트 실행, 패키징, 배포 등을 자동화하여 개발 프로세스를 단순화한다.

종속성 관리
Gradle은 종속성을 중앙 저장소(Maven Central, JCenter) 또는 로컬 저장소에서 가져와 프로젝트에 추가한다.

복잡한 빌드 로직 구현
Gradle의 유연한 스크립트 작성 방식을 활용하면 대규모 프로젝트에 적합한 빌드 로직을 구현할 수 있다.

안드로이드 개발
Google이 공식적으로 지원하는 빌드 도구로, 안드로이드 프로젝트에서 Gradle은 표준 빌드 시스템으로 자리 잡았다.

Gradle의 장점
고성능
Gradle은 증분 빌드와 병렬 실행을 통해 빌드 속도를 최적화한다. 이로 인해 대규모 프로젝트에서도 빌드 시간이 크게 단축된다.

유연성
사용자 정의 태스크와 플러그인을 통해 다양한 요구사항에 맞게 빌드 프로세스를 커스터마이징할 수 있다.

확장 가능성
Gradle은 다양한 커뮤니티 플러그인을 지원하며, 필요에 따라 자체 플러그인을 개발하여 사용할 수 있다.

범용성
Gradle은 Java 프로젝트뿐만 아니라 Kotlin, Groovy, Scala, C/C++, Python 등 다양한 언어와 플랫폼을 지원한다.

Gradle 빌드 스크립트의 특징
Gradle의 빌드 스크립트는 Groovy 또는 Kotlin DSL로 작성된다. Groovy는 Gradle의 초기 빌드 스크립트 언어이며, Kotlin DSL은 강력한 타입 안정성과 IntelliJ IDEA에서의 자동 완성을 제공한다.

Groovy 기반 스크립트 예제
plugins {
    id 'java'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework:spring-context:5.3.15'
    testImplementation 'junit:junit:4.13.2'
}
Kotlin 기반 스크립트 예제
plugins {
    kotlin("jvm") version "1.8.10"
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.springframework:spring-context:5.3.15")
    testImplementation("junit:junit:4.13.2")
}
Gradle의 기본 개념 요약
Gradle은 Maven의 단점을 보완하여 유연성과 성능을 제공하는 빌드 도구이다. 태스크 기반 빌드 시스템과 Groovy/Kotlin DSL을 통해 복잡한 빌드 로직을 쉽게 정의할 수 있으며, 다양한 언어와 플랫폼을 지원하여 범용적인 빌드 도구로 자리 잡았다.

학습자의 사고를 돕기 위한 질문
Gradle이 Groovy/Kotlin 기반 스크립트를 사용함으로써 얻는 유연성은 무엇인가?

복잡한 빌드 로직을 정의할 때의 장점을 떠올려보라.
태스크 기반 빌드 시스템이 프로젝트 개발에 어떻게 기여할 수 있는가?

선언적 빌드와 명령적 빌드 스타일의 장단점을 비교해보라.
2.2. Gradle의 주요 구성 요소
Gradle은 태스크 기반 빌드 시스템을 중심으로 동작하며, 이를 구성하는 여러 핵심 요소가 존재한다. 이 요소들을 통해 프로젝트의 빌드 및 종속성 관리가 체계적으로 이루어진다. Gradle의 주요 구성 요소는 아래와 같다.

빌드 스크립트 (build.gradle)
Gradle 프로젝트의 중심은 빌드 스크립트이다. 빌드 스크립트는 Groovy 또는 Kotlin DSL(Domain Specific Language)로 작성되며, 프로젝트와 빌드 프로세스에 대한 설정을 포함한다. 빌드 스크립트의 주요 역할과 구성 요소는 다음과 같다:

플러그인 (plugins)

플러그인은 Gradle에 특정 기능을 추가하기 위해 사용된다.
예를 들어, java 플러그인을 적용하면 Java 프로젝트의 빌드와 관련된 기본 태스크(compileJava, jar, test 등)가 자동으로 추가된다.
plugins {
    id 'java' // Java 플러그인 적용
}
plugins {
    kotlin("jvm") version "1.8.10" // Kotlin JVM 플러그인 적용
}
의존성 (dependencies)

프로젝트가 사용하는 라이브러리와 외부 모듈을 정의한다.
implementation은 런타임에 필요한 의존성을 정의하며, testImplementation은 테스트 환경에서만 필요한 의존성을 설정한다.
dependencies {
    implementation 'org.springframework:spring-core:5.3.15'
    testImplementation 'junit:junit:4.13.2'
}
dependencies {
    implementation("org.springframework:spring-core:5.3.15")
    testImplementation("junit:junit:4.13.2")
}
저장소 (repositories)

의존성을 다운로드할 저장소를 지정한다.
Gradle은 Maven 중앙 저장소(Maven Central)와 JCenter, 로컬 저장소를 지원한다.
repositories {
    mavenCentral() // Maven 중앙 저장소
}
repositories {
    mavenCentral() // Maven 중앙 저장소
}
태스크 정의

Gradle은 태스크 기반으로 빌드 프로세스를 실행한다.
사용자는 기본 태스크 외에도 사용자 정의 태스크를 추가할 수 있다.
task customTask {
    doLast {
        println 'Custom task executed!'
    }
}
tasks.register("customTask") {
    doLast {
        println("Custom task executed!")
    }
}
태스크 (Task)
Gradle의 태스크는 빌드 프로세스에서 특정 작업을 수행하는 단위이다. Gradle은 빌드와 관련된 작업을 태스크로 분리하여 정의하며, 빌드 과정은 이 태스크들을 실행하는 과정으로 이해할 수 있다.

기본 제공 태스크

Gradle은 프로젝트의 유형에 따라 다양한 기본 태스크를 제공한다.
build: 전체 빌드 작업을 수행.
clean: 이전 빌드 결과물을 삭제.
test: 테스트 실행.
사용자 정의 태스크

Gradle 스크립트를 통해 필요에 따라 태스크를 정의할 수 있다.
task hello {
    doLast {
        println 'Hello, Gradle!'
    }
}
tasks.register("hello") {
    doLast {
        println("Hello, Gradle!")
    }
}
태스크 의존성

Gradle은 태스크 간의 의존성을 설정할 수 있다.
특정 태스크가 실행되기 전에 다른 태스크가 먼저 실행되도록 설정할 수 있다.
task firstTask {
    doLast {
        println 'First Task Executed'
    }
}

task secondTask {
    dependsOn firstTask
    doLast {
        println 'Second Task Executed'
    }
}
val firstTask = tasks.register("firstTask") {
    doLast {
        println("First Task Executed")
    }
}

tasks.register("secondTask") {
    dependsOn(firstTask)
    doLast {
        println("Second Task Executed")
    }
}
Gradle Wrapper
Gradle Wrapper는 Gradle을 설치하지 않고도 프로젝트를 빌드할 수 있도록 지원하는 도구이다. Wrapper를 사용하면 특정 Gradle 버전에 종속되지 않으며, 프로젝트별로 Gradle 버전을 관리할 수 있다.

Wrapper 생성

다음 명령어로 Wrapper를 생성할 수 있다:
gradle wrapper
Wrapper 파일 구성

Wrapper를 생성하면 프로젝트 디렉토리에 다음과 같은 파일이 생성된다:
gradlew: Unix 환경에서 사용 가능한 Wrapper 실행 파일.
gradlew.bat: Windows 환경에서 사용 가능한 Wrapper 실행 파일.
gradle/wrapper/gradle-wrapper.jar: Wrapper 실행을 위한 Java 아카이브 파일.
gradle/wrapper/gradle-wrapper.properties: Wrapper 설정 파일.
Wrapper를 통한 빌드 실행

Wrapper를 사용하여 빌드를 실행하려면 다음 명령어를 사용한다:
./gradlew build
Gradle 구성의 요약
Gradle의 주요 구성 요소는 빌드 스크립트(build.gradle), 태스크(Task), 그리고 Gradle Wrapper로 이루어져 있다. 빌드 스크립트는 프로젝트의 빌드 설정을 포함하며, 태스크는 빌드 과정의 작업 단위를 정의한다. Gradle Wrapper는 Gradle 설치 없이 프로젝트를 빌드할 수 있는 환경을 제공하여 유연성을 극대화한다.

학습자의 사고를 돕기 위한 질문
build.gradle에서 plugins 블록과 dependencies 블록은 각각 어떤 역할을 하는가?

프로젝트 설정과 라이브러리 의존성 관리의 차이를 떠올려보라.
Gradle의 태스크 기반 시스템이 Maven과 비교해 제공하는 이점은 무엇인가?

사용자 정의 태스크 작성과 기본 제공 태스크 활용 측면에서 생각해보라.
실습 문제
문제 1: 간단한 Gradle 빌드 스크립트 작성
다음 요구사항에 맞는 build.gradle 파일을 작성하시오.

프로젝트 이름: my-first-gradle-project
사용 플러그인: java
Gradle 버전: 7.4
작성된 build.gradle 파일은 다음과 같은 형식을 가져야 한다:

plugins {
    id 'java'
}

repositories {
    mavenCentral()
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.1'
}
문제 2: 사용자 정의 태스크 추가
다음 요구사항을 만족하는 사용자 정의 태스크를 build.gradle에 추가하시오.

태스크 이름: helloWorld
태스크 설명: "Prints 'Hello, World!' to the console."
실행 시 출력 내용: Hello, World!
작성된 태스크는 아래와 같은 형식으로 실행되어야 한다:

task helloWorld {
    doLast {
        println 'Hello, World!'
    }
}
3. Maven과 Gradle의 비교
3.1. 주요 유사점과 차이점
Maven과 Gradle은 모두 현대적인 빌드 도구로, Java를 포함한 다양한 언어 기반 프로젝트에서 사용된다. 두 도구는 빌드 자동화와 종속성 관리를 위해 개발되었으며, 많은 공통점을 공유하면서도 여러 면에서 차이를 보인다. 여기서는 이들의 주요 유사점과 차이점을 상세히 분석한다.

유사점
빌드 자동화 및 종속성 관리

Maven과 Gradle 모두 프로젝트 빌드를 자동화하며, 필요한 라이브러리를 중앙 저장소에서 다운로드하여 관리한다.
프로젝트에서 사용하는 외부 라이브러리를 명시적으로 정의하고, 해당 의존성을 자동으로 다운로드하고 관리하는 기능을 제공한다.
공통적으로, 중앙 저장소(Maven Central)와 로컬 저장소를 지원한다.
프로젝트 구조

두 도구는 표준 프로젝트 디렉토리 구조를 권장하며, 이를 따름으로써 개발자 간의 일관성을 유지한다.
src/main/java 및 src/test/java와 같은 구조는 Maven과 Gradle 모두에서 동일하다.
표준 구조를 활용하면 IDE에서도 자동으로 프로젝트를 올바르게 인식할 수 있다.
다양한 언어 및 플랫폼 지원

두 도구는 Java뿐만 아니라 Kotlin, Scala 등 다양한 JVM 언어와 함께 사용할 수 있다.
Gradle은 JVM 외에도 C++, Swift 등 더 많은 언어를 지원하는 경향이 있지만, 기본적인 유연성은 Maven과 Gradle 모두 제공한다.
확장 가능성

Maven과 Gradle 모두 플러그인을 통해 확장할 수 있다. 예를 들어:
Maven의 플러그인은 POM 파일에 <plugin> 태그로 정의된다.
Gradle의 플러그인은 plugins 블록에서 정의된다.
플러그인을 사용하면 테스트, 패키징, 배포와 같은 기능을 추가할 수 있다.
차이점
구문 및 설정 언어

Maven은 XML 기반의 구성 파일을 사용한다.
XML은 구조가 명확하지만, 긴 코드와 복잡한 태그 구조로 인해 가독성이 떨어질 수 있다.
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>5.3.15</version>
</dependency>
Gradle은 Groovy 또는 Kotlin DSL을 사용한다.
스크립트 언어를 사용해 구성 파일이 간결하며, 유연성과 가독성이 뛰어나다.
dependencies {
    implementation 'org.springframework:spring-core:5.3.15'
}
빌드 성능

Gradle은 빌드 속도에서 Maven보다 유리하다.
Gradle은 Incremental Build(증분 빌드)와 Build Cache(빌드 캐시)를 사용해 이전 빌드 데이터를 재활용한다.
Maven은 매번 새롭게 빌드 과정을 수행하므로 Gradle에 비해 느릴 수 있다.
의존성 선언 방식

Maven은 POM 파일의 <dependencies> 태그에 모든 의존성을 선언한다.
Gradle은 스크립트 기반으로 선언하며, 정적 버전과 동적 버전을 쉽게 정의할 수 있다.
동적 버전 예: implementation 'org.springframework:spring-core:5.+ (Gradle)
유연성과 확장성

Gradle은 선언적 방식(Declarative)과 명령적 방식(Imperative)을 혼합하여 지원한다.
예를 들어, 태스크 간의 복잡한 논리를 쉽게 정의할 수 있다.
Maven은 XML 기반의 선언적 방식만 지원하므로, 복잡한 빌드 로직을 구현하기가 다소 제한적이다.
학습 곡선

Maven은 상대적으로 배우기가 쉽다. XML 기반의 직관적인 구성 덕분에 초보 개발자도 빠르게 이해할 수 있다.
Gradle은 유연성과 기능이 많아 배우는 데 더 많은 시간이 필요할 수 있다. Groovy 또는 Kotlin DSL을 이해해야 하기 때문이다.
비교 요약
기능	Maven	Gradle
설정 파일	XML	Groovy 또는 Kotlin DSL
유연성	제한적	매우 유연
빌드 속도	느림	빠름
의존성 선언	정적 버전 선언	정적 및 동적 버전 모두 지원
학습 곡선	쉬움	다소 어려움
확장성	플러그인을 통한 기본 확장	플러그인 및 스크립트 기반 확장 가능
학습자의 사고를 돕기 위한 질문
Maven과 Gradle의 주요 차이점 중, XML 기반과 Groovy/Kotlin 기반의 장단점은 무엇인가?

가독성, 확장성, 선언적 스타일의 표현력 등을 고려하여 설명하라.
두 빌드 도구가 모두 종속성 관리를 지원하지만, Gradle의 동적 의존성(+ 버전 표기법)이 프로젝트 유지보수에 어떤 영향을 미칠 수 있는가?

특정 버전 고정의 장단점과 비교해보라.
실습 문제
문제 1: Maven과 Gradle을 활용한 동일한 프로젝트 생성
다음 요구사항에 맞는 프로젝트를 각각 Maven과 Gradle을 사용하여 생성하시오.

프로젝트 이름: compare-project
Maven과 Gradle에서 다음 디렉토리 구조를 확인하시오.
Maven: src/main/java, src/test/java
Gradle: src/main/java, src/main/resources
결과적으로 생성된 디렉토리 구조를 비교하고 각 도구의 기본 설정 차이를 설명하시오.
문제 2: 동일 의존성을 Maven과 Gradle에서 정의
다음 요구사항에 맞는 동일한 의존성을 각각 Maven과 Gradle에서 정의하시오.

사용 라이브러리: JUnit 5
버전: 5.8.1
Maven POM 파일 예제:
<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.8.1</version>
        <scope>test</scope>
    </dependency>
</dependencies>
Gradle build.gradle 예제:
dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.1'
}
3.2. 도구 선택의 기준
Maven과 Gradle은 각기 다른 프로젝트 요구 사항에 적합한 빌드 도구로, 도구를 선택할 때는 프로젝트의 특성과 목표에 따라 신중히 결정해야 한다. 이 절에서는 Maven과 Gradle을 선택할 때 고려해야 할 주요 기준을 설명한다.

1. 표준화된 프로젝트와 일관성이 중요한 경우 - Maven
Maven은 표준화된 프로젝트 구조와 빌드 과정을 제공한다. 이 도구를 사용하는 가장 큰 이유 중 하나는 바로 일관성이다.

장점:

Maven의 XML 기반 설정 파일은 모든 프로젝트에서 동일한 구조와 포맷을 유지한다. 팀원이 새로운 프로젝트에 합류하더라도 기존 프로젝트와 동일한 구조를 기대할 수 있다.
대규모 팀에서는 일관된 설정이 중요한데, Maven은 이러한 요구를 충족한다.
Maven의 중앙 저장소(Maven Central)는 대부분의 Java 개발자가 사용하므로, 타사 라이브러리를 쉽게 검색하고 활용할 수 있다.
적합한 시나리오:

표준적인 Java 웹 애플리케이션 개발.
강력한 표준화가 요구되는 기업 환경.
새로 합류하는 개발자가 빠르게 적응해야 하는 프로젝트.
2. 복잡한 빌드 논리가 필요한 경우 - Gradle
Gradle은 유연성과 확장성이 뛰어난 빌드 도구로, 복잡한 요구 사항이 있는 프로젝트에 적합하다.

장점:

Gradle의 Groovy 또는 Kotlin DSL을 사용하면 빌드 로직을 쉽게 커스터마이징할 수 있다.
증분 빌드와 빌드 캐시를 활용해 큰 프로젝트에서도 빠른 빌드 속도를 제공한다.
동적 의존성 설정(5.+와 같은 버전 표현)을 통해 프로젝트가 자동으로 최신 라이브러리를 사용할 수 있다.
적합한 시나리오:

복잡한 모듈식 프로젝트.
안드로이드 애플리케이션 개발(Gradle은 안드로이드 공식 빌드 도구임).
빠른 빌드 속도와 유연성이 중요한 프로젝트.
3. 프로젝트 규모
작은 프로젝트:

작은 프로젝트에서는 설정이 간단하고 표준화된 Maven이 더 적합할 수 있다.
단일 모듈 기반 프로젝트에서 Gradle의 유연성은 크게 필요하지 않다.
대규모 프로젝트:

Gradle은 복잡한 멀티모듈 프로젝트를 관리하기에 적합하다.
Gradle의 태스크(Task) 기반 빌드 시스템은 빌드 과정을 세밀하게 제어할 수 있다.
4. 빌드 성능
Gradle은 빌드 속도 면에서 Maven보다 우위를 점한다. Gradle의 주요 성능 특징은 다음과 같다:

증분 빌드:
Gradle은 변경된 부분만 빌드하므로, Maven보다 빌드 시간이 짧다.
빌드 캐시:
이전 빌드의 결과를 재활용하여 반복적인 작업을 최소화한다.
Maven은 매번 전체 빌드를 실행하므로 Gradle만큼 효율적이지 않다.
5. 의존성 관리
Maven:

의존성 관리는 비교적 단순하다. <dependency> 태그를 사용하며, 특정 버전을 명시적으로 선언해야 한다.
의존성 충돌 시, Maven은 "가장 오래된 버전"을 기본으로 선택한다.
Gradle:

동적 버전 의존성을 지원하여 항상 최신 패치를 자동으로 다운로드할 수 있다.
의존성 충돌 해결에 대해 더 유연한 제어가 가능하다. strictly 옵션을 사용하면 특정 버전을 강제할 수 있다.
dependencies {
    implementation 'org.springframework:spring-core:5.+'
    implementation('com.google.guava:guava:30.1.1-jre') {
        version {
            strictly '30.1.1-jre'
        }
    }
}
6. 팀의 경험 수준
Maven은 배우기 쉽고 설정이 간단하여 초보 개발자에게 적합하다.
Gradle은 스크립트 언어(Groovy/Kotlin)를 사용하기 때문에, 기존 경험이 없는 개발자에게는 학습 곡선이 존재한다.
7. 커뮤니티 및 생태계
Maven은 더 오랜 역사를 가지고 있어, 기존 문서화와 커뮤니티 지원이 풍부하다.
Gradle은 현대적이고 다양한 기능을 제공하며, 특히 안드로이드 개발 커뮤니티에서 강력한 지지를 받고 있다.
비교 요약
기준	Maven	Gradle
표준화	매우 표준화	유연함
복잡한 빌드 지원	제한적	뛰어남
성능	느림	빠름
의존성 관리	단순	유연하고 강력
초보자 친화도	높음	다소 낮음
학습자의 사고를 돕기 위한 질문
프로젝트의 복잡성과 크기에 따라 Maven과 Gradle 중 어떤 도구가 더 적합할지 판단해보라.

소규모 프로젝트와 대규모 프로젝트를 기준으로 생각하라.
Gradle의 빌드 속도가 Maven보다 빠른 경우, 이를 통해 얻을 수 있는 이점은 무엇인가?

CI/CD 환경에서 빌드 속도가 중요한 이유를 고려하라.
실습 문제
문제 1: 특정 프로젝트에 도구 선택 기준 작성
다음 프로젝트를 예로 들어 도구 선택 기준을 작성하시오.

프로젝트 1: 소규모 API 서버 프로젝트
프로젝트 2: 대규모 모듈화된 웹 애플리케이션
도구 선택의 이유를 상세히 설명하고, 각 도구가 제공하는 이점과 단점을 비교하시오.

문제 2: 도구 성능 비교 실습
Maven과 Gradle의 빌드 성능을 다음 조건에 따라 비교하시오.

동일한 프로젝트를 Maven과 Gradle로 생성한다.
프로젝트에 10개의 외부 라이브러리를 추가한다.
각 도구의 빌드 시간을 측정하고, 결과를 비교하시오.
결과를 분석하여 Gradle이 빌드 속도에서 더 유리한 이유를 설명하시오.
4. Maven과 Gradle을 활용한 프로젝트 생성
4.1. Maven 프로젝트 생성
Maven을 사용하여 새로운 프로젝트를 생성하면 Maven이 제공하는 표준화된 프로젝트 구조와 의존성 관리를 즉시 활용할 수 있다. 이번 절에서는 Maven 프로젝트의 디렉토리 구조와 생성 명령어를 상세히 설명한다.

1. Maven 프로젝트 디렉토리 구조
Maven은 표준 디렉토리 구조를 강제한다. 이 구조는 프로젝트 내의 소스 코드와 리소스 파일, 그리고 테스트 파일이 어디에 위치해야 하는지를 명확히 정의한다.

주요 디렉토리와 파일:

src/main/java: 애플리케이션의 Java 소스 파일이 위치하는 곳이다. 이 디렉토리 아래에 도메인 이름 기반의 패키지 구조를 생성한다.
src/main/resources: 애플리케이션 실행에 필요한 설정 파일이나 기타 리소스 파일(XML, YAML, 이미지 등)을 저장한다.
src/test/java: JUnit 또는 TestNG와 같은 테스트 프레임워크를 사용하는 테스트 코드가 위치한다.
src/test/resources: 테스트 실행 시 필요한 설정 파일이나 기타 리소스를 저장한다.
pom.xml: 프로젝트의 모든 설정이 포함된 Maven의 중심 파일이다.
예시 디렉토리 구조:

my-maven-project/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── App.java
│   │   ├── resources/
│   │       └── application.properties
│   ├── test/
│       ├── java/
│       │   └── com/
│       │       └── example/
│       │           └── AppTest.java
│       └── resources/
└── pom.xml
2. Maven 프로젝트 생성 명령어
Maven은 프로젝트를 생성하기 위한 강력한 CLI 도구를 제공한다. 이를 통해 표준 구조를 갖춘 새로운 프로젝트를 빠르게 설정할 수 있다.

2.1. mvn archetype:generate 명령어
정의:

Maven Archetype은 템플릿 프로젝트를 생성하는 도구로, archetype:generate 명령어를 사용하여 새 프로젝트를 생성한다.
기본적으로 Maven은 중앙 저장소에서 템플릿(Archetype)을 검색하고, 이를 사용해 프로젝트를 설정한다.
명령어 실행 방법:

mvn archetype:generate
실행 시 Maven은 다양한 Archetype 리스트를 표시하며, 프로젝트에 적합한 템플릿을 선택할 수 있다.

중요한 파라미터:

옵션	설명
-DgroupId	프로젝트의 그룹 ID. 일반적으로 회사 도메인 이름을 반대로 작성한다. 예: com.example.
-DartifactId	프로젝트의 이름. 생성된 JAR 파일의 이름으로 사용된다.
-Dversion	프로젝트의 버전. 기본값은 1.0-SNAPSHOT.
-Dpackage	Java 패키지 이름. 생략하면 groupId와 동일하게 설정된다.
-DarchetypeArtifactId	사용할 템플릿 이름. 기본 Java 프로젝트용 Archetype은 maven-archetype-quickstart.
2.2. 간단한 Maven 프로젝트 생성
아래 명령어를 실행하면 간단한 Maven 프로젝트를 생성할 수 있다:

mvn archetype:generate \
    -DgroupId=com.example \
    -DartifactId=my-maven-project \
    -Dversion=1.0.0 \
    -Dpackage=com.example \
    -DarchetypeArtifactId=maven-archetype-quickstart \
    -DinteractiveMode=false
명령어 설명:
-DinteractiveMode=false: 대화형 모드를 비활성화하여 빠르게 프로젝트를 생성한다.
maven-archetype-quickstart: 간단한 Java 애플리케이션 템플릿을 제공한다.
3. 프로젝트 생성 후 구조 확인
명령어를 실행하면 지정된 artifactId 이름의 폴더가 생성된다. 예를 들어, artifactId가 my-maven-project라면 다음과 같은 구조를 확인할 수 있다:

my-maven-project/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── App.java
│   ├── test/
│       ├── java/
│           └── com/
│               └── example/
│                   └── AppTest.java
└── pom.xml
4. Maven 프로젝트의 주요 파일
4.1. pom.xml
pom.xml은 Maven 프로젝트의 설정 파일로, 프로젝트의 의존성, 플러그인, 그리고 기타 빌드 관련 설정이 포함된다.
기본적으로 maven-archetype-quickstart로 생성된 pom.xml은 다음과 같다:
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>my-maven-project</artifactId>
    <version>1.0.0</version>
    <properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
    </properties>
</project>
4.2. 기본 Java 파일
src/main/java/com/example/App.java 파일은 간단한 main 메서드를 포함한다:
package com.example;

public class App {
    public static void main(String[] args) {
        System.out.println("Hello, Maven!");
    }
}
학습자의 사고를 돕기 위한 질문
Maven에서 mvn archetype:generate 명령어가 제공하는 주요 이점은 무엇인가?

표준화된 프로젝트 구조와 템플릿 활용의 장점을 고려해보라.
Maven 프로젝트 생성 후 기본 디렉토리 구조의 역할은 무엇인가?

src/main/java, src/test/java 디렉토리의 용도와 중요성을 설명하라.
실습 문제
문제 1: Maven 명령어를 활용한 프로젝트 생성
다음 요구사항에 맞는 Maven 프로젝트를 생성하시오.

프로젝트 이름: maven-sample
그룹 ID: com.example
아티팩트 ID: sample-app
생성된 디렉토리 구조를 확인하고, 각 디렉토리의 역할을 간단히 정리하시오.
문제 2: Maven 프로젝트에서 POM 파일 수정
다음 요구사항에 따라 POM 파일을 수정하시오.

플러그인: maven-compiler-plugin
컴파일러 설정:
source: 17
target: 17
수정된 POM 파일은 아래와 같은 형식을 가져야 한다:
<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.8.1</version>
      <configuration>
        <source>17</source>
        <target>17</target>
      </configuration>
    </plugin>
  </plugins>
</build>
4.2. Gradle 프로젝트 생성
Gradle은 유연성과 속도 면에서 장점이 있는 빌드 도구로, 특히 대규모 프로젝트에서 활용도가 높다. 이번 절에서는 Gradle 프로젝트의 디렉토리 구조와 프로젝트 생성 명령어를 상세히 설명한다.

1. Gradle 프로젝트 디렉토리 구조
Gradle 프로젝트는 Maven과는 약간 다른 디렉토리 구조를 따른다. 하지만 Gradle도 기본적으로 표준화된 디렉토리 구조를 제공하며, 이는 대부분의 Java 프로젝트에 적합하다.

주요 디렉토리와 파일:

src/main/java: 애플리케이션의 Java 소스 파일이 위치한다.
src/main/resources: 실행에 필요한 리소스 파일(예: application.properties, XML 파일 등)을 저장한다.
src/test/java: 테스트 코드가 위치한다. JUnit 또는 TestNG와 같은 테스트 프레임워크에서 사용된다.
src/test/resources: 테스트 실행 시 필요한 리소스를 저장한다.
build.gradle: 프로젝트의 주요 빌드 설정 파일이다. Gradle 스크립트를 기반으로 빌드 작업과 의존성을 정의한다.
settings.gradle: 프로젝트 설정 파일로, 프로젝트 이름 및 여러 모듈 간 관계를 정의한다.
예시 디렉토리 구조:

my-gradle-project/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── App.java
│   │   ├── resources/
│   │       └── application.properties
│   ├── test/
│       ├── java/
│       │   └── com/
│       │       └── example/
│       │           └── AppTest.java
│       └── resources/
├── build.gradle
└── settings.gradle
2. Gradle 프로젝트 생성 명령어
Gradle은 명령줄 도구인 gradle init 명령어를 사용하여 프로젝트를 생성한다. 이 명령어는 다양한 프로젝트 유형과 빌드 스크립트 언어(Groovy 또는 Kotlin)를 선택할 수 있는 대화형 인터페이스를 제공한다.

2.1. gradle init 명령어
정의:

Gradle의 기본 프로젝트 생성 도구로, 초기화된 프로젝트 디렉토리와 설정 파일을 생성한다.
Gradle은 생성 도중 프로젝트 유형(예: Java 애플리케이션, 라이브러리 등)과 언어(Groovy 또는 Kotlin)를 선택할 수 있는 옵션을 제공한다.
명령어 실행 방법:

gradle init
대화형 실행 흐름: 명령어를 실행하면 다음과 같은 대화형 흐름을 통해 프로젝트를 설정한다:

프로젝트 유형 선택: 애플리케이션, 라이브러리, 빈 프로젝트 등.
빌드 스크립트 언어 선택: Groovy 또는 Kotlin.
테스트 프레임워크 선택: JUnit, TestNG, Spock 등.
기타 프로젝트 세부 정보 입력.
결과물: 대화형 모드를 통해 생성된 프로젝트는 Gradle의 표준 구조를 따른다.

2.2. 비대화형 명령어 사용
대화형 설정을 생략하고, 명령어의 옵션을 사용해 빠르게 프로젝트를 생성할 수도 있다. 아래는 간단한 Java 애플리케이션 프로젝트를 생성하는 명령어다:

gradle init \
  --type java-application \
  --dsl groovy \
  --test-framework junit \
  --project-name my-gradle-project \
  --package com.example
명령어 설명:
--type java-application: Java 애플리케이션 프로젝트를 생성한다.
--dsl groovy: 빌드 스크립트 언어를 Groovy로 설정한다.
--test-framework junit: JUnit 테스트 프레임워크를 사용한다.
--project-name my-gradle-project: 프로젝트 이름을 설정한다.
--package com.example: Java 패키지 구조를 설정한다.
3. 프로젝트 생성 후 구조 확인
위 명령어를 실행하면 프로젝트 이름에 해당하는 폴더가 생성되고, 그 안에 Gradle 표준 디렉토리 구조가 형성된다. 예를 들어, my-gradle-project라는 이름으로 생성했다면 다음과 같은 구조를 확인할 수 있다:

my-gradle-project/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── App.java
│   │   ├── resources/
│   │       └── application.properties
│   ├── test/
│       ├── java/
│       │   └── com/
│       │       └── example/
│       │           └── AppTest.java
│       └── resources/
├── build.gradle
└── settings.gradle
4. Gradle 프로젝트의 주요 파일
4.1. build.gradle
build.gradle은 Gradle의 빌드 스크립트로, 의존성, 플러그인, 빌드 태스크 등을 정의한다.
기본적으로 아래와 같은 내용이 포함된다:
plugins {
    id 'java'
    id 'application'
}

group = 'com.example'
version = '1.0.0'

application {
    mainClass = 'com.example.App'
}

repositories {
    mavenCentral()
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.2'
}

test {
    useJUnitPlatform()
}
주요 섹션:
plugins: 프로젝트에 필요한 플러그인을 선언.
repositories: 의존성을 다운로드할 저장소를 정의.
dependencies: 프로젝트가 사용하는 의존성 라이브러리를 명시.
application: 애플리케이션의 진입점(Main 클래스)을 설정.
4.2. 기본 Java 파일
src/main/java/com/example/App.java:

package com.example;

public class App {
    public static void main(String[] args) {
        System.out.println("Hello, Gradle!");
    }
}
4.3. 기본 테스트 파일
src/test/java/com/example/AppTest.java:

package com.example;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class AppTest {
    @Test
    void testApp() {
        assertTrue(true);
    }
}
학습자의 사고를 돕기 위한 질문
Gradle의 gradle init 명령어가 제공하는 템플릿 옵션은 무엇인가?

애플리케이션, 라이브러리, 빈 프로젝트 등 옵션의 차이를 설명하라.
Gradle 프로젝트 생성 후 build.gradle 파일에서 기본적으로 포함되는 설정은 무엇인가?

초기화된 빌드 스크립트 구조를 분석하라.
실습 문제
문제 1: Gradle 명령어를 활용한 프로젝트 생성
다음 요구사항에 맞는 Gradle 프로젝트를 생성하시오.

프로젝트 이름: gradle-sample
프로젝트 타입: 애플리케이션
생성된 build.gradle 파일의 내용을 확인하고, 각 섹션의 역할을 정리하시오.
문제 2: Gradle 빌드 스크립트 수정
다음 요구사항에 따라 Gradle 빌드 스크립트를 수정하시오.

플러그인: java
리포지토리: mavenCentral
의존성:
org.junit.jupiter:junit-jupiter:5.8.1
수정된 build.gradle 파일은 아래와 같은 형식을 가져야 한다:
plugins {
    id 'java'
}

repositories {
    mavenCentral()
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.1'
}
5. 빌드와 종속성 관리
5.1. 종속성 추가 및 관리
종속성 관리(Dependency Management)는 Maven과 Gradle의 핵심 기능 중 하나로, 외부 라이브러리를 프로젝트에 추가하고 관리하는 작업을 말한다. 이를 통해 프로젝트에 필요한 라이브러리를 효율적으로 추가할 수 있으며, 의존성 간의 충돌 문제를 해결하거나 특정 버전의 라이브러리를 유지하는 등의 작업을 수행할 수 있다.

1. Maven의 종속성 관리
Maven은 pom.xml 파일에서 <dependencies> 태그를 사용해 종속성을 관리한다. Maven 중앙 저장소(Maven Central Repository) 또는 로컬 저장소에서 라이브러리를 자동으로 다운로드하고, 프로젝트에 포함시킨다.

1.1. 기본 종속성 정의
pom.xml 파일 내 <dependencies> 태그는 프로젝트에 필요한 모든 라이브러리를 정의한다. 각 라이브러리는 <dependency> 태그를 통해 추가하며, 주요 구성 요소는 다음과 같다:

<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.15</version>
    </dependency>
</dependencies>
구성 요소:
<groupId>: 라이브러리의 그룹 식별자(예: org.springframework).
<artifactId>: 특정 라이브러리의 식별자(예: spring-context).
<version>: 라이브러리의 버전(예: 5.3.15).
1.2. Maven 저장소
Maven은 기본적으로 다음 두 종류의 저장소에서 라이브러리를 다운로드한다:

Maven 중앙 저장소 (Central Repository): 인터넷에 연결된 상태에서 외부 라이브러리를 자동으로 다운로드한다.
로컬 저장소: 사용자의 로컬 디렉토리에 다운로드된 라이브러리를 저장한다. 기본 경로는 ~/.m2/repository이다.
1.3. 의존성 트리 확인
Maven 프로젝트에서 의존성 트리를 확인하려면 다음 명령어를 사용한다:

mvn dependency:tree
출력 예시:
[INFO] +- org.springframework:spring-context:jar:5.3.15:compile
[INFO] |  +- org.springframework:spring-core:jar:5.3.15:compile
[INFO] |  \- org.springframework:spring-beans:jar:5.3.15:compile
이 명령어는 프로젝트의 모든 의존성과 의존성 계층 구조를 보여준다. 이를 통해 의존성 충돌 여부를 파악할 수 있다.

1.4. 의존성 범위
Maven에서는 의존성의 범위를 지정할 수 있다. 범위는 특정 라이브러리가 어디에서 사용되는지를 나타낸다. 주요 범위는 다음과 같다:

compile: 기본값이며, 컴파일과 실행 시에 모두 사용된다.
provided: 런타임 시에는 사용되지 않고, 애플리케이션 서버와 같은 환경에서 제공된다.
runtime: 런타임 시에만 필요하며, 컴파일 시에는 필요하지 않다.
test: 테스트 코드에서만 사용된다.
예시:

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.13.2</version>
    <scope>test</scope>
</dependency>
2. Gradle의 종속성 관리
Gradle에서는 build.gradle 파일의 dependencies 블록을 사용해 종속성을 추가한다. Gradle은 Maven 중앙 저장소, JCenter, 로컬 저장소 등 다양한 저장소를 지원하며, 동적 의존성 설정과 같은 고급 기능을 제공한다.

2.1. 기본 종속성 정의
Gradle에서 종속성은 다음과 같이 추가된다:

dependencies {
    implementation 'org.springframework:spring-context:5.3.15'
    testImplementation 'junit:junit:4.13.2'
}
키워드 설명:
implementation: 컴파일과 런타임 모두에서 사용되는 의존성을 정의한다.
testImplementation: 테스트 시에만 필요한 의존성을 정의한다.
2.2. 저장소 정의
Gradle 프로젝트에서 의존성을 다운로드할 저장소는 repositories 블록에서 정의한다:

repositories {
    mavenCentral() // Maven 중앙 저장소
    mavenLocal()   // 로컬 저장소
}
2.3. 동적 의존성
Gradle은 동적 의존성을 지원하며, 특정 버전의 범위를 지정할 수 있다. 예를 들어, 아래와 같이 사용하면 1.0.0 이상의 최신 버전을 자동으로 가져온다:

dependencies {
    implementation 'com.google.guava:guava:1.+'
}
장점: 항상 최신 버전의 라이브러리를 유지할 수 있다.
단점: 빌드 결과가 버전에 따라 달라질 수 있으므로, 주의해서 사용해야 한다.
2.4. 의존성 확인
Gradle에서는 dependencies 태스크를 통해 의존성 트리를 확인할 수 있다:

gradle dependencies
출력 예시:
+--- org.springframework:spring-context:5.3.15
|    +--- org.springframework:spring-core:5.3.15
|    \--- org.springframework:spring-beans:5.3.15
3. Maven과 Gradle의 의존성 관리 비교
항목	Maven	Gradle
의존성 정의 방식	XML 파일 (pom.xml)	Groovy/Kotlin 스크립트 (build.gradle)
동적 의존성 지원	지원하지 않음	지원 (1.+와 같은 형식)
의존성 확인 명령어	mvn dependency:tree	gradle dependencies
저장소 설정	<repositories> 태그 사용	repositories 블록 사용
학습자의 사고를 돕기 위한 질문
Maven의 <dependency> 태그에서 scope 속성은 어떤 역할을 하는가?

compile, test, runtime, provided 등의 스코프가 어떤 상황에서 적합한지 생각해보라.
Gradle의 implementation과 api 키워드의 차이점은 무엇인가?

모듈 간 의존성 전파의 관점에서 비교해보라.
실습 문제
문제 1: Maven에서 종속성 추가
다음 요구사항에 맞게 Maven POM 파일에 종속성을 추가하시오.

사용 라이브러리: org.apache.commons:commons-lang3:3.12.0
Scope: compile
수정된 POM 파일 예시는 다음과 같아야 한다:
<dependencies>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.12.0</version>
        <scope>compile</scope>
    </dependency>
</dependencies>
문제 2: Gradle에서 종속성 추가
다음 요구사항에 맞게 Gradle의 build.gradle 파일에 종속성을 추가하시오.

사용 라이브러리: com.google.guava:guava:31.0.1-jre
Repository: mavenCentral
수정된 build.gradle 파일은 다음과 같아야 한다:
repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.google.guava:guava:31.0.1-jre'
}
5.2. 로컬 및 중앙 저장소 활용
Maven과 Gradle은 빌드 도구로서 외부 라이브러리를 다운로드하고 프로젝트에 포함시키기 위해 저장소(Repository) 를 사용한다. 저장소는 라이브러리와 플러그인을 저장하는 장소로, 로컬 환경에서의 속도와 인터넷 연결 여부를 고려한 구조를 갖추고 있다. 본 절에서는 Maven과 Gradle의 로컬 및 중앙 저장소 활용 방식을 각각 살펴본다.

1. Maven에서의 저장소 활용
Maven은 기본적으로 중앙 저장소(Maven Central Repository)를 사용하지만, 사용자의 환경에 맞게 로컬 저장소와 별도의 원격 저장소를 설정할 수 있다. 저장소 활용 방식은 아래와 같다:

1.1. 중앙 저장소
Maven의 기본 저장소는 Maven 중앙 저장소(Maven Central) 이며, URL은 다음과 같다:

https://repo.maven.apache.org/maven2
Maven은 중앙 저장소를 통해 프로젝트에 필요한 의존성을 다운로드하고 이를 로컬 저장소에 캐시로 저장한다. 인터넷 연결이 필요한 경우, Maven은 중앙 저장소에서 필요한 모든 파일을 자동으로 다운로드한다.

1.2. 로컬 저장소
로컬 저장소는 사용자 컴퓨터에 저장되는 캐시 저장소로, 다운로드된 모든 라이브러리와 플러그인을 저장한다. 기본 위치는 다음과 같다:

Windows: C:\Users\<사용자이름>\.m2\repository
macOS/Linux: ~/.m2/repository
로컬 저장소의 주요 역할은 다음과 같다:

속도 향상: 이미 다운로드된 라이브러리를 다시 다운로드하지 않는다.
오프라인 지원: 인터넷 연결이 없는 경우에도 의존성을 활용할 수 있다.
1.3. 사용자 정의 원격 저장소
사용자는 중앙 저장소 외에도 자신만의 원격 저장소를 설정할 수 있다. 이는 기업 내에서 공용 라이브러리를 배포하거나 인터넷 연결이 제한적인 환경에서 유용하다.

pom.xml에 원격 저장소 추가:
<repositories>
    <repository>
        <id>my-repo</id>
        <url>https://my.company.com/maven2</url>
    </repository>
</repositories>
1.4. 의존성 다운로드 우선순위
Maven은 의존성을 다운로드할 때 아래 순서로 저장소를 탐색한다:

로컬 저장소: 로컬 저장소에 라이브러리가 있으면 즉시 사용한다.
원격 저장소: 로컬에 없으면 repositories에 정의된 원격 저장소를 탐색한다.
중앙 저장소: 원격 저장소에서도 찾지 못한 경우, 기본 중앙 저장소를 탐색한다.
2. Gradle에서의 저장소 활용
Gradle은 Maven과 유사하게 중앙 저장소와 로컬 저장소를 사용하지만, 유연한 저장소 설정과 다양한 저장소 타입을 지원한다. 아래는 Gradle에서의 저장소 활용 방식이다:

2.1. 중앙 저장소
Gradle의 기본 중앙 저장소는 다음과 같다:

Maven 중앙 저장소: https://repo.maven.apache.org/maven2
JCenter: 한때 널리 사용되었으나, 현재 Gradle에서는 Maven Central 사용을 권장한다.
build.gradle 파일에서 중앙 저장소를 사용하는 예는 다음과 같다:

repositories {
    mavenCentral()
}
2.2. 로컬 저장소
Gradle은 로컬 저장소를 통해 의존성을 관리하며, 기본 위치는 다음과 같다:

Windows: C:\Users\<사용자이름>\.gradle\caches\modules-2\files-2.1\
macOS/Linux: ~/.gradle/caches/modules-2/files-2.1/
Gradle은 Maven과 마찬가지로, 한 번 다운로드된 의존성을 로컬에 저장해 이후 빌드 속도를 높이고 오프라인 환경에서도 빌드를 지원한다.

2.3. 사용자 정의 저장소
Gradle에서는 사용자 정의 저장소를 매우 간단히 추가할 수 있다. 원격 저장소를 추가하려면 repositories 블록에 설정을 추가한다:

repositories {
    maven {
        url "https://my.company.com/maven-repo"
    }
}
2.4. 저장소 우선순위
Gradle은 저장소 탐색 순서를 아래와 같이 따른다:

로컬 저장소: 캐시된 라이브러리를 먼저 확인한다.
repositories에 정의된 저장소: 순서대로 저장소를 탐색한다.
기본 중앙 저장소: 마지막으로 Maven Central에서 의존성을 찾는다.
2.5. 의존성 확인
Gradle은 dependencies 명령어를 통해 다운로드된 저장소 경로와 의존성 트리를 확인할 수 있다:

gradle dependencies
3. Maven과 Gradle 저장소 활용 비교
특징	Maven	Gradle
기본 중앙 저장소	Maven Central (https://repo.maven.apache.org)	Maven Central (mavenCentral())
로컬 저장소 경로	~/.m2/repository	~/.gradle/caches/modules-2/files-2.1/
사용자 정의 저장소 설정	<repositories> 태그	repositories 블록
저장소 탐색 순서	로컬 → 원격 → 중앙 저장소	로컬 → 정의된 저장소 → 중앙 저장소
학습자의 사고를 돕기 위한 질문
Maven의 로컬 저장소와 중앙 저장소의 차이는 무엇인가?

로컬 저장소의 역할과 중앙 저장소와의 상호작용을 고려해보라.
Gradle에서 커스텀 저장소를 설정하려면 어떤 과정을 따라야 하는가?

repositories 블록의 활용을 중심으로 생각해보라.
실습 문제
문제 1: Maven 로컬 저장소 확인
다음 요구사항에 따라 Maven 로컬 저장소를 탐색하시오.

로컬 저장소 경로: 기본적으로 ~/.m2/repository
Maven 프로젝트에서 특정 라이브러리를 추가한 후, 로컬 저장소에서 해당 라이브러리 파일의 경로를 확인하시오.
문제 2: Gradle 커스텀 저장소 설정
다음 요구사항에 맞게 Gradle의 build.gradle 파일에 커스텀 저장소를 추가하시오.

저장소 URL: https://example.com/repo
사용 라이브러리: org.example:custom-lib:1.0.0
수정된 build.gradle 파일은 다음과 같아야 한다:
repositories {
    maven {
        url 'https://example.com/repo'
    }
}

dependencies {
    implementation 'org.example:custom-lib:1.0.0'
}
6. 빌드 출력물 생성
6.1. 빌드 명령어
빌드는 소스 코드를 컴파일하고, 필요한 의존성을 포함하여 최종적으로 실행 가능한 출력물(artifact) 을 생성하는 과정을 말한다. Maven과 Gradle은 모두 이 과정을 단순화하고 자동화하기 위해 빌드 명령어를 제공하며, 프로젝트의 설정 파일(pom.xml 또는 build.gradle)에 정의된 규칙에 따라 빌드가 수행된다.

1. Maven에서 빌드 명령어 사용하기
Maven은 명령줄에서 명령어를 실행하여 빌드를 수행한다. Maven 빌드 명령어는 아래와 같은 단계별 작업을 수행하며, 각 단계는 개별적으로 실행할 수도 있다.

1.1. Maven 주요 명령어
mvn compile:

Java 소스 파일을 컴파일하여 .class 파일을 생성한다.
출력물은 프로젝트 디렉토리 내의 target/classes에 저장된다.
mvn test:

프로젝트의 단위 테스트를 실행한다.
테스트 코드는 기본적으로 src/test/java에 위치하며, JUnit 또는 TestNG와 같은 테스트 프레임워크를 사용한다.
mvn package:

컴파일된 파일과 모든 의존성을 포함하여 JAR 또는 WAR 파일을 생성한다.
출력 파일은 target 디렉토리에 생성된다.
예: target/my-app-1.0-SNAPSHOT.jar
mvn install:

생성된 JAR 또는 WAR 파일을 로컬 Maven 저장소(~/.m2/repository)에 설치한다.
다른 프로젝트에서 이 파일을 의존성으로 사용할 수 있게 된다.
1.2. 예제: Maven으로 JAR 파일 생성
다음은 간단한 Maven 프로젝트를 빌드하는 과정이다:

프로젝트 디렉토리 구조:

my-app/
├── pom.xml
└── src/
    ├── main/
    │   └── java/
    │       └── com/
    │           └── example/
    │               └── App.java
    └── test/
        └── java/
            └── com/
                └── example/
                    └── AppTest.java
빌드 명령 실행:

mvn package
빌드 결과 확인: Maven은 target 디렉토리에 다음과 같은 파일을 생성한다:

target/
├── classes/
│   └── (컴파일된 .class 파일)
├── my-app-1.0-SNAPSHOT.jar
└── test-classes/
2. Gradle에서 빌드 명령어 사용하기
Gradle은 gradle 명령어를 통해 빌드를 수행한다. Gradle의 빌드 명령은 태스크(task) 기반으로 동작하며, 필요한 빌드 작업을 효율적으로 실행한다.

2.1. Gradle 주요 명령어
gradle compileJava:

Java 소스 파일을 컴파일한다.
출력 파일은 기본적으로 build/classes/java/main에 생성된다.
gradle test:

프로젝트의 단위 테스트를 실행한다.
테스트 결과는 build/reports/tests에 HTML 형식으로 저장된다.
gradle build:

컴파일, 테스트, 패키징 과정을 한 번에 실행한다.
최종 결과물(JAR 파일)은 build/libs 디렉토리에 저장된다.
예: build/libs/my-app-1.0-SNAPSHOT.jar
2.2. 예제: Gradle로 JAR 파일 생성
프로젝트 디렉토리 구조:

my-app/
├── build.gradle
└── src/
    ├── main/
    │   └── java/
    │       └── com/
    │           └── example/
    │               └── App.java
    └── test/
        └── java/
            └── com/
                └── example/
                    └── AppTest.java
빌드 명령 실행:

gradle build
빌드 결과 확인: Gradle은 build 디렉토리에 다음과 같은 파일을 생성한다:

build/
├── classes/
│   ├── java/
│   │   ├── main/    (컴파일된 .class 파일)
│   │   └── test/    (테스트 클래스)
│   └── kotlin/      (Kotlin 소스가 있는 경우)
├── libs/
│   └── my-app-1.0-SNAPSHOT.jar
├── reports/
│   └── tests/       (테스트 결과)
└── tmp/
3. Maven과 Gradle 빌드 명령어 비교
명령어	Maven	Gradle
컴파일	mvn compile	gradle compileJava
테스트 실행	mvn test	gradle test
JAR 파일 생성	mvn package	gradle build
로컬 저장소 설치	mvn install	별도의 명령어 없음 (publish 플러그인 사용)
학습자의 사고를 돕기 위한 질문
Maven에서 mvn compile과 mvn package 명령어의 차이점은 무엇인가?

각각의 명령어가 실행되는 단계와 결과물을 비교해보라.
Gradle의 gradle build 명령어는 어떤 작업 단계를 포함하는가?

Gradle의 태스크 기반 실행 구조를 고려해보라.
실습 문제
문제 1: Maven 빌드 실행
다음 요구사항에 따라 Maven 프로젝트를 빌드하시오.

Maven 프로젝트를 컴파일(mvn compile)한 뒤, 결과를 확인하시오.
이후 mvn package 명령어를 실행하여 결과물을 확인하시오.
target 디렉토리에 생성된 JAR 파일의 이름을 확인하고, 파일 크기를 출력하시오.
문제 2: Gradle 빌드 실행
다음 요구사항에 따라 Gradle 프로젝트를 빌드하시오.

Gradle의 build.gradle 파일이 정상적으로 작성된 프로젝트에서 gradle build 명령어를 실행하시오.
빌드 결과를 확인하고 build/libs 디렉토리에 생성된 JAR 파일의 이름을 출력하시오.
빌드 시간과 결과를 기록하고 분석하시오.
6.2. 출력물
출력물은 빌드 도구가 소스 코드와 의존성을 처리한 결과물로, 일반적으로 JAR(Java Archive) 또는 WAR(Web Application Archive) 형식이다.

1. Maven 출력물
Maven은 기본적으로 target 디렉토리에 출력물을 생성한다:

JAR 파일: 독립 실행형 Java 애플리케이션에 사용된다.
WAR 파일: Java 웹 애플리케이션 배포에 사용된다.
출력 파일 이름은 pom.xml의 설정에 따라 다음과 같이 결정된다:

<groupId>com.example</groupId>
<artifactId>my-app</artifactId>
<version>1.0-SNAPSHOT</version>
결과 파일 이름: my-app-1.0-SNAPSHOT.jar

2. Gradle 출력물
Gradle은 기본적으로 build/libs 디렉토리에 출력물을 생성한다:

JAR 파일: 기본 파일 이름은 project-name-version.jar 형식을 따른다.
WAR 파일: Gradle의 war 플러그인을 사용하여 생성 가능하다.
출력 파일 이름은 build.gradle의 설정에 따라 변경할 수 있다:

jar {
    archiveBaseName.set("custom-name")
    archiveVersion.set("1.0.0")
}
결과 파일 이름: custom-name-1.0.0.jar

6. 빌드 출력물 생성
6.1. 빌드 명령어
Maven과 Gradle은 프로젝트를 빌드하고 실행 가능한 파일(JAR 또는 WAR 등)을 생성하는 데 최적화된 명령어를 제공한다. 이 과정은 컴파일, 테스트, 패키징, 의존성 병합 등 다양한 단계로 이루어져 있다. 이 절에서는 Maven과 Gradle이 제공하는 주요 빌드 명령어와 각 명령어의 역할을 상세히 살펴본다.

1. Maven의 빌드 명령어
Maven은 명령어 기반으로 빌드 작업을 처리하며, 다양한 단계별 명령어를 제공한다. Maven의 명령어는 프로젝트 루트 디렉토리에서 실행된다. Maven의 주요 빌드 명령어는 다음과 같다:

1.1. mvn compile
역할: 소스 코드를 컴파일하여 .class 파일을 생성한다.
실행 과정:
src/main/java 디렉토리에 있는 Java 소스 코드를 컴파일한다.
결과 파일은 target/classes 디렉토리에 생성된다.
예시:
mvn compile
출력 예시:

[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) ---
[INFO] Compiling 10 source files to /path/to/project/target/classes
[INFO] BUILD SUCCESS
1.2. mvn test
역할: 테스트 코드를 실행하고 결과를 출력한다.
실행 과정:
src/test/java 디렉토리에 있는 테스트 코드를 컴파일한다.
테스트 케이스를 실행하고 결과를 리포트한다.
예시:
mvn test
1.3. mvn package
역할: 프로젝트를 패키징하여 JAR 또는 WAR 파일을 생성한다.
실행 과정:
소스 코드와 테스트 코드를 컴파일한다.
테스트를 실행하여 성공적으로 통과하면 결과물을 패키징한다.
패키징된 파일은 target/ 디렉토리에 생성된다.
예시:
mvn package
출력 예시:

[INFO] Building jar: /path/to/project/target/project-name-1.0.jar
[INFO] BUILD SUCCESS
1.4. mvn clean
역할: 이전 빌드에서 생성된 파일(target/ 디렉토리)을 삭제한다.
용도: 새로운 빌드를 시작하기 전에 클린 상태로 초기화.
예시:
mvn clean
2. Gradle의 빌드 명령어
Gradle은 태스크(Task) 기반 빌드 시스템으로, 빌드 단계를 명확히 정의하여 작업을 실행한다. 주요 Gradle 빌드 명령어는 다음과 같다:

2.1. gradle build
역할: 전체 빌드 과정을 실행하여 JAR 또는 WAR 파일을 생성한다.
실행 과정:
소스 코드를 컴파일한다.
테스트를 실행한다.
결과물을 패키징하여 build/libs 디렉토리에 저장한다.
예시:
gradle build
출력 예시:

BUILD SUCCESSFUL in 5s
3 actionable tasks: 3 executed
2.2. gradle clean
역할: 이전 빌드에서 생성된 모든 출력물을 삭제한다.
용도: 새로운 빌드를 실행하기 전에 작업 환경을 초기화.
예시:
gradle clean
출력 예시:

BUILD SUCCESSFUL in 1s
1 actionable task: 1 executed
2.3. gradle test
역할: 테스트 코드를 실행하고 결과를 출력한다.
실행 과정:
테스트 코드를 컴파일한다.
테스트를 실행하고 리포트를 생성한다.
예시:
gradle test
2.4. gradle assemble
역할: 테스트 단계를 실행하지 않고 빌드 결과물만 생성한다.
용도: 빠른 빌드가 필요할 때 사용.
예시:
gradle assemble
3. Maven과 Gradle 빌드 명령어 비교
빌드 단계	Maven 명령어	Gradle 명령어
소스 코드 컴파일	mvn compile	N/A (자동 처리됨)
테스트 실행	mvn test	gradle test
전체 빌드 및 패키징	mvn package	gradle build
출력물 생성(패키징만)	N/A	gradle assemble
이전 출력물 삭제	mvn clean	gradle clean
6.2. 출력물
빌드 프로세스를 성공적으로 완료하면 Maven과 Gradle은 각각 지정된 디렉토리 구조에 결과물을 생성한다. 출력물은 주로 JAR(Java Archive) 또는 WAR(Web Archive) 파일로 나타나며, 애플리케이션 실행이나 배포에 사용된다. 이 절에서는 Maven과 Gradle이 생성하는 출력물의 위치, 구조, 그리고 특징을 설명한다.

1. Maven의 출력물
Maven은 target 디렉토리를 사용하여 모든 빌드 결과물을 저장한다. 이 디렉토리는 프로젝트 루트 디렉토리 아래에 자동으로 생성되며, 빌드 과정에 따라 다양한 산출물을 포함한다.

1.1. 주요 출력물 디렉토리 구조
Maven 빌드가 완료되면, target 디렉토리 안에 다음과 같은 파일과 폴더가 생성된다:

target/classes:
컴파일된 .class 파일이 저장된다.
예: src/main/java 디렉토리에 작성된 소스 코드가 컴파일되어 이 위치에 저장된다.
target/test-classes:
테스트용 .class 파일이 저장된다.
예: src/test/java 디렉토리에 작성된 테스트 코드가 컴파일되어 이 위치에 저장된다.
target/project-name-version.jar:
Maven의 패키징 명령(mvn package)을 실행한 결과로 생성되는 JAR 파일이다.
예: project-1.0.jar
target/project-name-version.war:
프로젝트가 웹 애플리케이션(WAR)으로 설정된 경우, 패키징 결과물이 WAR 파일 형태로 생성된다.
1.2. 예제: JAR 파일 생성
POM 설정:

<groupId>com.example</groupId>
<artifactId>sample-project</artifactId>
<version>1.0</version>
<packaging>jar</packaging>
명령어 실행:

mvn package
결과:

target/sample-project-1.0.jar
1.3. JAR 파일 내부 구조
생성된 JAR 파일은 Java 애플리케이션 실행에 필요한 모든 클래스 파일과 리소스를 포함한다. JAR 파일의 기본 구조는 다음과 같다:

META-INF/
    MANIFEST.MF
com/
    example/
        Main.class
application.properties
META-INF/MANIFEST.MF:

JAR 파일의 메타데이터를 포함하며, 애플리케이션의 진입점을 정의할 수 있다.
2. Gradle의 출력물
Gradle은 build 디렉토리를 사용하여 모든 빌드 결과물을 저장한다. 이 디렉토리는 프로젝트 루트 아래에 자동으로 생성되며, Gradle 빌드 태스크의 실행 결과를 포함한다.

2.1. 주요 출력물 디렉토리 구조
Gradle 빌드가 완료되면, build 디렉토리 안에 다음과 같은 파일과 폴더가 생성된다:

build/classes/java/main:
컴파일된 .class 파일이 저장된다.
예: src/main/java 디렉토리에 작성된 소스 코드가 컴파일되어 이 위치에 저장된다.
build/classes/java/test:
테스트용 .class 파일이 저장된다.
예: src/test/java 디렉토리에 작성된 테스트 코드가 컴파일되어 이 위치에 저장된다.
build/libs/project-name-version.jar:
Gradle의 빌드 명령(gradle build)을 실행한 결과로 생성되는 JAR 파일이다.
예: project-1.0.jar
build/reports/tests:
테스트 결과 리포트가 HTML 파일 형태로 저장된다.
2.2. 예제: JAR 파일 생성
build.gradle 설정:

plugins {
    id 'java'
}

group = 'com.example'
version = '1.0'

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}
명령어 실행:

gradle build
결과:

build/libs/sample-project-1.0.jar
2.3. JAR 파일 내부 구조
Gradle로 생성된 JAR 파일의 기본 구조는 Maven과 유사하며, 다음과 같은 파일과 디렉토리를 포함한다:

META-INF/
    MANIFEST.MF
com/
    example/
        Main.class
config/
    application.properties
3. Maven과 Gradle의 출력물 비교
항목	Maven 출력물 위치	Gradle 출력물 위치
컴파일된 클래스	target/classes	build/classes/java/main
테스트 클래스	target/test-classes	build/classes/java/test
JAR 파일	target/project-name.jar	build/libs/project-name.jar
보고서	없음	build/reports
학습자의 사고를 돕기 위한 질문
Maven의 빌드 출력물인 target 디렉토리는 프로젝트 유지보수 관점에서 어떤 장점이 있는가?

컴파일 결과물과 원본 소스 코드를 분리하는 관점에서 설명하라.
Gradle의 출력물 디렉토리(build/libs)는 어떤 기준으로 구조화되는가?

디렉토리 구조와 결과 파일의 명명 규칙을 고려하라.
실습 문제
문제 1: Maven 출력물 확인
다음 요구사항에 따라 Maven 프로젝트의 출력물을 확인하시오.

Maven 프로젝트를 패키징(mvn package)한 뒤, target 디렉토리에 생성된 JAR 파일의 이름과 크기를 확인하시오.
생성된 JAR 파일의 내부 구조를 확인하시오(예: META-INF 디렉토리 및 클래스 파일).
문제 2: Gradle 출력물 확인
다음 요구사항에 따라 Gradle 프로젝트의 출력물을 확인하시오.

Gradle 프로젝트를 빌드한 뒤, build/libs 디렉토리에 생성된 JAR 파일의 이름과 크기를 확인하시오.
생성된 JAR 파일 내부의 MANIFEST.MF 파일을 열어, 해당 프로젝트의 메타데이터를 확인하시오.
연습 문제
문제 1: 간단한 Maven 프로젝트 생성
다음 요구사항을 만족하는 Maven 프로젝트를 생성하시오.

프로젝트 이름: practice-maven-project
그룹 ID: com.practice
아티팩트 ID: maven-demo
POM 파일을 수정하여 다음 의존성을 추가하시오:
JUnit 5 (org.junit.jupiter:junit-jupiter:5.8.1)
Maven 명령어를 실행하여 프로젝트를 빌드하고, 생성된 JAR 파일을 확인하시오.
문제 2: Gradle 사용자 정의 태스크 추가
다음 요구사항을 만족하는 Gradle 프로젝트를 생성하시오.

프로젝트 이름: practice-gradle-project
플러그인: java
사용자 정의 태스크를 추가하시오:
태스크 이름: helloTask
태스크 설명: "Prints 'Hello, Gradle!' to the console."
실행 시 출력 내용: Hello, Gradle!
문제 3: Maven POM 파일 수정
다음 POM 파일을 작성하고, Maven 빌드를 실행하시오.

프로젝트 이름: maven-sample
그룹 ID: com.example
아티팩트 ID: sample-app
플러그인 추가:
maven-compiler-plugin
컴파일러 설정:
source: 17
target: 17
문제 4: Gradle 빌드 스크립트 수정
다음 요구사항에 따라 build.gradle 파일을 작성하시오.

프로젝트 플러그인: java
리포지토리: mavenCentral
추가할 의존성:
Guava 라이브러리 (com.google.guava:guava:31.0.1-jre)
문제 5: 종속성 충돌 해결
Maven 프로젝트에서 다음 두 의존성을 추가하시오.

의존성 1: org.slf4j:slf4j-api:1.7.30
의존성 2: org.slf4j:slf4j-api:1.8.0-beta2
Maven 명령어를 실행하여 충돌 메시지를 확인하고, 해결 방법을 기록하시오.
문제 6: Gradle 멀티프로젝트 구성
다음 요구사항에 따라 Gradle 멀티프로젝트를 구성하시오.

루트 프로젝트 이름: multi-project
서브프로젝트:
app
library
app 프로젝트에서 library 프로젝트를 의존성으로 추가하시오.
문제 7: Maven 출력물 탐색
다음 요구사항에 따라 Maven 프로젝트를 빌드하고 출력물을 확인하시오.

Maven 명령어: mvn package
target 디렉토리에 생성된 JAR 파일 내부 구조를 탐색하고, META-INF/MANIFEST.MF 파일의 내용을 확인하시오.
문제 8: Gradle 태스크 실행 흐름 분석
Gradle 프로젝트를 생성하고 다음 명령어를 실행하시오.

명령어: gradle build
실행 중인 태스크를 분석하고, 각 태스크가 하는 역할을 기록하시오.
문제 9: Maven과 Gradle의 디렉토리 구조 비교
다음 요구사항에 따라 두 프로젝트를 생성하시오.

Maven 프로젝트: mvn archetype:generate
Gradle 프로젝트: gradle init
생성된 디렉토리 구조를 비교하고, 각 디렉토리의 역할을 설명하시오.
문제 10: Gradle 커스텀 저장소 설정
다음 요구사항에 따라 Gradle 프로젝트를 수정하시오.

저장소 URL: https://custom-repo.com/repo
추가할 의존성:
org.custom:custom-lib:1.0.0
저장소와 의존성을 build.gradle 파일에 추가하고, Gradle 빌드를 실행하시오.
5. 연습 문제에 대한 답안
5.1 배열 요소 합 구하기

정답:
배열 요소를 사용자로부터 입력받아 합계를 계산한다.

import java.util.Scanner;

public class ArraySum {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] numbers = new int[5];
        int sum = 0;

        System.out.println("배열 요소를 입력하세요:");
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = scanner.nextInt();
            sum += numbers[i];
        }

        System.out.println("배열 요소의 합: " + sum);
        scanner.close();
    }
}
5.2 배열 요소 평균 계산

정답:
배열 요소를 사용자로부터 입력받아 평균을 계산한다.

import java.util.Scanner;

public class ArrayAverage {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] numbers = new int[7];
        int sum = 0;

        System.out.println("배열 요소를 입력하세요:");
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = scanner.nextInt();
            sum += numbers[i];
        }

        double average = (double) sum / numbers.length;
        System.out.println("배열 요소의 평균: " + average);
        scanner.close();
    }
}
5.3 최대값과 최소값 찾기

정답:
배열의 최대값과 최소값을 계산한다.

import java.util.Scanner;

public class ArrayMinMax {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] numbers = new int[6];

        System.out.println("배열 요소를 입력하세요:");
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = scanner.nextInt();
        }

        int max = numbers[0];
        int min = numbers[0];
        for (int num : numbers) {
            if (num > max) max = num;
            if (num < min) min = num;
        }

        System.out.println("최대값: " + max);
        System.out.println("최소값: " + min);
        scanner.close();
    }
}
5.4 특정 값의 인덱스 찾기

정답:
배열에서 특정 값의 인덱스를 찾는다.

import java.util.Scanner;

public class FindValueIndex {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        Scanner scanner = new Scanner(System.in);

        System.out.print("찾을 값을 입력하세요: ");
        int target = scanner.nextInt();
        int index = -1;

        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == target) {
                index = i;
                break;
            }
        }

        if (index != -1) {
            System.out.println("인덱스: " + index);
        } else {
            System.out.println("값이 존재하지 않습니다.");
        }
        scanner.close();
    }
}
6. 연습 문제에 대한 답안
6.1 Javadoc 주석 작성 - 클래스와 필드

정답:
Person 클래스와 필드에 Javadoc 주석을 작성한다.

/**
 * 사람의 이름과 나이를 관리하는 클래스.
 *
 * @author 작성자
 * @version 1.0
 */
public class Person {
    /**
     * 사람의 이름.
     */
    private String name;

    /**
     * 사람의 나이.
     */
    private int age;
}
6.2 Javadoc 주석 작성 - 메소드

정답:
Calculator 클래스의 add 메소드에 Javadoc 주석을 작성한다.

/**
 * 계산기 클래스.
 * 두 개의 정수를 더하는 메소드를 포함한다.
 */
public class Calculator {
    /**
     * 두 정수를 더한다.
     *
     * @param a 첫 번째 정수
     * @param b 두 번째 정수
     * @return 두 정수의 합
     */
    public int add(int a, int b) {
        return a + b;
    }
}
6.3 태그 활용

정답:
BankAccount 클래스에 메소드와 태그를 작성한다.

/**
 * 은행 계좌를 관리하는 클래스.
 */
public class BankAccount {
    private double balance;

    /**
     * 잔액에 금액을 추가한다.
     *
     * @param amount 입금할 금액
     */
    public void deposit(double amount) {
        balance += amount;
    }

    /**
     * 잔액에서 금액을 차감한다.
     *
     * @param amount 출금할 금액
     * @throws IllegalArgumentException 잔액이 부족할 경우
     */
    public void withdraw(double amount) {
        if (amount > balance) {
            throw new IllegalArgumentException("잔액이 부족합니다.");
        }
        balance -= amount;
    }
}
6.4 Javadoc 주석 작성 - 생성자

정답:
Book 클래스와 생성자에 Javadoc 주석을 작성한다.

/**
 * 책 정보를 관리하는 클래스.
 */
public class Book {
    private String title;
    private String author;

    /**
     * 기본 생성자.
     */
    public Book() {}

    /**
     * 책 제목과 저자를 초기화하는 생성자.
     *
     * @param title 책 제목
     * @param author 책 저자
     */
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }
}
6.5 다국어 지원 Javadoc

정답:
Product 클래스에 다국어 주석을 작성한다.

/**
 * 제품 정보를 관리하는 클래스.
 * Class for managing product information.
 *
 * @author 작성자
 * @version 1.0
 */
public class Product {
    /**
     * 제품의 가격을 반환한다.
     * Returns the price of the product.
     *
     * @return 제품 가격
     */
    public double getPrice() {
        return 0.0;
    }
}
6.6 일관된 형식 유지

정답:
User 클래스와 구성 요소에 일관된 Javadoc 주석을 작성한다.

/**
 * 사용자 계정을 관리하는 클래스.
 */
public class User {
    /**
     * 사용자 계정 이름.
     */
    private String username;

    /**
     * 사용자 비밀번호.
     */
    private String password;

    /**
     * 사용자 이름을 반환한다.
     *
     * @return 사용자 이름
     */
    public String getUsername() {
        return username;
    }
}
6.7 명확하고 간결한 주석 작성

정답:
잘못된 주석을 수정하여 Employee 클래스의 calculateSalary 메소드에 명확한 Javadoc 주석을 작성한다.

/**
 * 직원 정보를 관리하는 클래스.
 */
public class Employee {
    /**
     * 직원의 월급을 계산한다.
     * 기본급과 보너스를 더한 값을 반환한다.
     *
     * @return 월급 (기본급 + 보너스)
     */
    public double calculateSalary() {
        return 0.0; // 계산 로직 생략
    }
}
6.8 Javadoc 생성 연습 (명령줄 사용)

정답:
LibrarySystem 클래스에 Javadoc 주석을 작성한다.

/**
 * 도서관 시스템을 관리하는 클래스.
 */
public class LibrarySystem {
    /**
     * 책을 추가한다.
     *
     * @param title 책 제목
     * @param author 책 저자
     */
    public void addBook(String title, String author) {
        // 책 추가 로직 생략
    }
}
6.9 Javadoc 생성 연습 (IDE 사용)

정답:
CustomerService 클래스에 Javadoc 주석을 작성한다.

/**
 * 고객 서비스 관리를 위한 클래스.
 */
public class CustomerService {
    /**
     * 고객 불만을 처리한다.
     *
     * @param customerId 고객 ID
     */
    public void handleComplaint(String customerId) {
        // 불만 처리 로직 생략
    }
}
6.10 외부 도구를 활용한 Javadoc 확장

정답:
Project 클래스와 메소드에 Javadoc 주석을 작성한다.

/**
 * 프로젝트 정보를 관리하는 클래스.
 */
public class Project {
    /**
     * 팀원을 추가한다.
     *
     * @param memberName 팀원의 이름
     */
    public void addMember(String memberName) {
        // 팀원 추가 로직 생략
    }
}
7. 연습 문제에 대한 답안
7.1 간단한 Maven 프로젝트 생성

정답:
다음 POM 파일로 Maven 프로젝트를 생성하고 JAR 파일을 확인한다.

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.practice</groupId>
  <artifactId>maven-demo</artifactId>
  <version>1.0-SNAPSHOT</version>
  <dependencies>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter</artifactId>
      <version>5.8.1</version>
    </dependency>
  </dependencies>
</project>
7.2 Gradle 사용자 정의 태스크 추가

정답:
build.gradle 파일에 사용자 정의 태스크를 추가한다.

plugins {
    id 'java'
}

task helloTask {
    description = "Prints 'Hello, Gradle!' to the console."
    doLast {
        println 'Hello, Gradle!'
    }
}
7.3 Maven POM 파일 수정

정답:
다음 POM 파일을 수정하여 플러그인을 추가한다.

<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.8.1</version>
      <configuration>
        <source>17</source>
        <target>17</target>
      </configuration>
    </plugin>
  </plugins>
</build>
7.4 Gradle 빌드 스크립트 수정

정답:
다음과 같이 Gradle 의존성을 추가한다.

plugins {
    id 'java'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.google.guava:guava:31.0.1-jre'
}
7.5 종속성 충돌 해결

정답:
<dependencyManagement> 태그를 사용하여 종속성을 명시적으로 설정한다.

<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.30</version>
    </dependency>
  </dependencies>
</dependencyManagement>
7.6 Gradle 멀티프로젝트 구성

정답:
다음은 루트 settings.gradle과 서브프로젝트의 build.gradle 설정이다.

settings.gradle

rootProject.name = 'multi-project'
include 'app', 'library'
app/build.gradle

dependencies {
    implementation project(':library')
}
library/build.gradle

plugins {
    id 'java-library'
}
7.7 Maven 출력물 탐색

정답:
Maven 출력물인 target 디렉토리에서 JAR 파일의 META-INF/MANIFEST.MF 파일 확인.

Manifest-Version: 1.0
Built-By: Maven
Build-Jdk: 17
Main-Class: com.practice.Main
7.8 Gradle 태스크 실행 흐름 분석

정답:
Gradle 빌드 실행 시 실행되는 주요 태스크는 다음과 같다.

clean: 이전 빌드의 출력물을 삭제.
compileJava: Java 소스 코드를 컴파일.
processResources: 리소스 파일 복사.
jar: JAR 파일 생성.
7.9 Maven과 Gradle의 디렉토리 구조 비교

정답:

Maven 기본 디렉토리 구조:

src/main/java    - 애플리케이션 소스 코드
src/test/java    - 테스트 소스 코드
Gradle 기본 디렉토리 구조:

src/main/java    - 애플리케이션 소스 코드
src/main/resources - 애플리케이션 리소스 파일
7.10 Gradle 커스텀 저장소 설정

정답:
다음은 커스텀 저장소와 의존성을 추가한 build.gradle 파일이다.

repositories {
    maven {
        url 'https://custom-repo.com/repo'
    }
}

dependencies {
    implementation 'org.custom:custom-lib:1.0.0'
}
닫기
