# java.time
## 1. 기존 API의 한계
Java 8 이전에 사용되던 날짜와 시간 관련 API인 ```java.util.Date```와 ```java.util.Calendar```는 많은 한계를 가지고 있었다. 이로 인해 날짜 및 시간 처리가 복잡하고 오류를 유발하기 쉬운 구조로 되어 있었다.

**불변성 부족**<br>
```java.util.Date```는 가변 객체로 설계되었다. 이는 객체의 상태가 생성 이후에도 변경될 수 있다는 의미이다.<br>
예를 들어, 동일한 ```Date```객체를 여러 스레드에서 사용할 경우 데이터가 변경되어 동기화 문제가 발생할 수 있따. 이러한 특성은 멀티스레드 환경에서의 사용을 어렵게 한다.

**복잡한 사용법
```java.util.Calendar```는 날짜를 조작하기 위해 여러 단계를 거쳐야 하며, 코드가 직관적이지 않다.<br>
예를 들어, 현재 날짜에서 5일을 더하는 작업은 아래와 같이 복잡하게 작성해야 한다.
```java
Calendar calendar = Calendar.getInstance();
calendar.setTime(new Date());
calendar.add(Calendar.DATE, 5);
Date resultDate = calendar.getTime();
System.out.println(resultDate);
```
이는 간단한 연산도 장황하게  작성해야 하며, 코드의 가독성을 떨어뜨린다.

**불일관성과 모호성**<br>
```java.util.Date```의 설계에는 많은 모호성이 존재한다.<br>
월(Month)값은 0부터 시작하기 때문에, 0이 1월, 11이 12월을 의미한다.<br>
연도(Year)은 1900을 기준으로 계산된다.
```java
Date date = new Date(2025, 0, 1); // 2025년 1월 1일을 의도
System.out.println(date); // Fri Jan 01 00:00:00 KST 3925
```
위 코드의 출력 결과에서 연도가 3925인 이유는 ```Date```가 내부적으로 1900을 기준으로 연도를 계산하기 때문이다.

**시간대 처리의 어려움**
```java.util.Date```와 ```java.util.Calendar```는 시간대를 명시적으로 처리하지 않는다.<br>
시간대(Time Zone) 변환이나 UTC 오프셋 계산과 같은 작업을 수행하려면 추가적인 라이브러리나 복잡한 로직이 필요하다.

---------------------
## 1-2 java.time API의 등장 배경과 특징
Java 8에서 도입된 ```java.time```API는 기존의 한계를 극복하기 위해 설계되었다. 이 API는 ISO-8601 국제 표준을 기반으로 날짜와 시간을 처리하며, 현대적인 애플리케이션 개발에 적합한 기능을 제공한다.

**등장 배경**<br>
&nbsp;날짜와 시간 처리의 복잡성을 줄이고, 간단하고 명확한 API를 제공하기 위해 설계 되었다.
불변성(Immutable)과 스레드 안전성을 보장하는 구조로 설계되었다.<br>
시간대와 UTC 오프셋 관련 작업을 명확하고 일관되게 수행할 수 있다.<BR>
