![image](https://github.com/user-attachments/assets/8fe1eedc-c919-4322-bb40-8f548f63fcf6)# 인증(Authentication)과 인가(Authorization)의 차이
## 인증(Authentication)이란?
**인증(Authentication)** 은 사용자의 신원을 확인하는 과정이다.<br>
쉽게 말해, "이 사람이 정말 본인이 맞는가?"를 검증하는 절차를 의미한다.

우리는 일상생활에서도 인증을 경험한다. 예를 들어, 은행에서 계좌를 개설하려면 신분증을 제시하고 본인 확인을 받아야 한다.<br>
컴퓨터 시스템에서도 마찬가지로 사용자가 본인이 맞는지를 확인해야 한다.

-----------------
#### 인증이 필요한 이유
컴퓨터 시스템에서는 누구나 접근할 수 있도록 열어놓지 않는다. 특정한 사용자만 허용된 정보를 조회하거나 변경할 수 있어야 하며, 이를 위해 인증 과정이 필수적이다. 인증이 없다면 어떤 문제가 발생할까?

**개인 정보 유출 위험**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증 절차가 없다면, 누구나 타인의 계정에 접근하여 이메일, 메시지, 금융 정보를 확인할 수 있다.

**불법적인 시스템 접근**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증 없이 시스템에 접근할 수 있다면, 악의적인 사용자가 서버를 해킹하거나 데이터를 조작할 수 있다.

**기업 내부 정보 보호 실패**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;회사의 중요 정보가 보호되지 않아 경쟁업체에 유출될 위험이 있다.

결국, 인증은 사용자의 신원을 확인하여 시스템을 보호하고, 민감한 정보를 안전하게 관리하기 위한 핵심적인 절차이다.

---------------
#### 인증의 과정
인증이 이루어지는 기본적인 과정을 살펴보자.

**사용자가 로그인 요청**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 아이디와 비밀번호를 입력하거나, 생체 인증(지문, 얼굴 인식 등)을 통해 로그인 시도.

**서버에서 사용자 정보 검증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력된 아이디와 비밀번호가 저장된 데이터베이스(DB)와 일치하는지 확인.

**인증 성공 여부 결정**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력값이 정확하면, 사용자는 인증된 것으로 간주되고 시스템에 접근할 수 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력값이 틀리면, 인증이 거부되고 접근이 차단됨.

**세션 또는 토큰 발급(선택적 과정)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증이 성공하면, 이후 요청에서 사용자의 신원을 확인할 수 있도록 **세션(Session) 또는 토큰(Token)** 을 발급함.

다음은 간단한 인증 과정을 Java로 구현한 예제이다.
```java
import java.util.HashMap;
import java.util.Scanner;

public class AuthenticationExample {
    private static final HashMap<String, String> users = new HashMap<>();

    static {
        users.put("admin", "password123");
        users.put("user1", "mypassword");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("아이디를 입력하세요: ");
        String username = scanner.nextLine();

        System.out.print("비밀번호를 입력하세요: ");
        String password = scanner.nextLine();

        if (authenticate(username, password)) {
            System.out.println("인증 성공! 시스템에 접근할 수 있습니다.");
        } else {
            System.out.println("인증 실패! 아이디 또는 비밀번호가 올바르지 않습니다.");
        }

        scanner.close();
    }

    public static boolean authenticate(String username, String password) {
        return users.containsKey(username) && users.get(username).equals(password);
    }
}
```
이 프로그램은 단순한 사용자 인증 기능을 수행한다.<br>
사용자가 아이디와 비밀번호를 입력하면 미리 저장된 사용자 목록과 비교하여 인증 여부를 결정한다.

------------
#### 다양한 인증 방식
인증 방식에는 여러 가지가 있으며, 상황과 시스템의 보안 수준에 따라 다르게 적용된다.

**지식 기반 인증(Knowledge-Based Authentication, KBA)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 "기억하고 있는 정보"를 기반으로 인증.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예: 아이디/비밀번호, 보안 질문(어머니의 결혼 전 성, 첫 애완동물의 이름 등).

**소유 기반 인증(Possession-Based Authentication)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 "가지고 있는 것"을 기반으로 인증.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예: OTP(One-Time Password) 생성기, 보안 토큰, 스마트 카드.

**생체 인증(Biometric Authentication)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 신체적 특징을 활용한 인증 방식.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예: 지문, 얼굴 인식, 홍채 인식.

**이중 인증(Two-Factor Authentication, 2FA)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;두 가지 이상의 인증 요소를 조합하여 보안을 강화.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예: 아이디/비밀번호 + OTP 또는 생체 인증.

--------------------
## 인가(Authorization)이란?
**인가(Authorization)** 는 인증이 완료된 사용자가 "어떤 자원에 접근할 수 있는가?"를 결정하는 과정이다.

즉, **인증(Authentication)** 이 "사용자가 누구인지 확인하는 것"이라면,<br>
**인가(Authorization)** 는 "사용자가 무엇을 할 수 있는지 결정하는 것"이다.

--------------
### 인증과 인가의 차이
인증과 인가는 비슷해 보이지만 명확한 차이가 있다.<br>
다음 표를 통해 차이점을 정리해 보자.

|비교 항목|인증(Authentication)|인가(Authorization)|
|:---|:---|:---|
|목적|사용자의 신원을 확인|사용자가 수행할 수 있는 작업 결정|
|진행 시점|로그인 시|로그인 후 특정 기능 수행 시|
|결과|"이 사용자가 맞는가?"|"이 사용자가 이 작업을 할 권한이 있는가?"|
|예제|아이디와 비밀번호 입력|관리자만 특정 페이지 접근 허용|

예를 들어, 어떤 사용자가 은행 앱에 로그인하는 과정에서는 인증이 필요하다.<br.
그러나 로그인 후, 이 사용자가 단순한 계좌 조회만 할 수 있는지, 송금까지 할 수 있는지는 인가가 결정하는 것이다.

-------------
### 인증과 인가가 함께 작동하는 방식
일반적인 웹 애플리케이션에서 인증과 인가는 다음과 같은 흐름으로 작동한다.

**사용자가 로그인 요청(인증)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자는 아이디와 비밀번호를 입력하여 로그인 시도.

**서버에서 인증 수행**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력된 정보가 올바르면 인증이 완료됨.

**권한 확인(인가)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 특정 리소스에 접근하려고 하면, 서버는 해당 사용자가 접근할 수 있는 권한이 있는지 확인.

**인가 결과에 따라 처리**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;권한이 있다면 요청이 승인됨.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;권한이 없다면 접근이 거부됨.

-----------------
#### 인증과 인가의 예제 코드
아래는 사용자의 인증과 인가를 함께 구현한 간단한 Java 코드이다.
```java
import java.util.HashMap;

public class AuthenticationAuthorizationExample {
    private static final HashMap<String, String> users = new HashMap<>();
    private static final HashMap<String, String> roles = new HashMap<>();

    static {
        users.put("admin", "password123");
        users.put("user1", "mypassword");

        roles.put("admin", "ADMIN");
        roles.put("user1", "USER");
    }

    public static void main(String[] args) {
        String username = "admin";
        String password = "password123";

        if (authenticate(username, password)) {
            System.out.println(username + " 인증 성공!");

            if (authorize(username, "ADMIN")) {
                System.out.println(username + "은(는) 관리자 기능을 사용할 수 있습니다.");
            } else {
                System.out.println(username + "은(는) 관리자 기능을 사용할 수 없습니다.");
            }
        } else {
            System.out.println("인증 실패!");
        }
    }

    public static boolean authenticate(String username, String password) {
        return users.containsKey(username) && users.get(username).equals(password);
    }

    public static boolean authorize(String username, String requiredRole) {
        return roles.get(username).equals(requiredRole);
    }
}
```
이 코드는 사용자가 먼저 **인증(Authentication)** 을 수행한 후,<br>
해당 사용자가 **인가(Authorization)** 된 기능을 수행할 수 있는지를 확인하는 간단한 구조를 보여준다.

--------------
## 인증 방식의 비교
### 세션 기반 인증(Session-Based Authentication)
**세션 기반 인증(Session-Based Authentication)** 은 서버에서 사용자의 인증 상태를 유지하는 방식이다.<br>
이 방식은 오래전부터 웹 애플리케이션에서 널리 사용되었으며, 현재도 여전히 일부 시스템에서 활용된다.

------------
### 세션 기반 인증의 동작 과정
**사용자가 로그인 요청**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 아이디와 비밀번호를 입력하여 로그인 요청을 보냄.

**서버에서 사용자 인증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 사용자의 정보를 데이터베이스에서 조회하여 검증함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증이 성공하면, 서버는 해당 사용자에 대한 세션(Session) 을 생성함.

**세션 저장 및 식별자(Session ID) 발급**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 생성된 세션을 세션 저장소(Session Store) 에 저장함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 브라우저에는 해당 세션을 식별할 수 있는 세션 ID를 쿠키에 담아 응답으로 보냄.

**사용자의 요청 처리**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이후 사용자가 다른 요청을 보낼 때, 브라우저는 저장된 세션 ID를 함께 전송함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 세션 저장소에서 세션 ID를 조회하여 해당 사용자의 정보를 가져옴.

**세션 만료 또는 로그아웃**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 로그아웃하면, 서버는 세션을 삭제함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;일정 시간이 지나면 세션이 만료됨(예: 30분 동안 활동이 없을 경우).

----------------
### 세션 기반 인증의 장점
+ **보안성**: 세션 데이터는 서버에서 관리되므로, 클라이언트가 직접 조작할 수 없음.<br>
+ **사용자 상태 유지**: 서버가 사용자의 상태를 지속적으로 유지하므로, 인증 상태를 쉽게 확인 가능.<br>
+ **자동 로그아웃**: 일정 시간이 지나면 세션이 만료되도록 설정할 수 있어 보안성을 강화할 수 있음.<br>

### 세션 기반 인증의 단점
+ **확장성 문제**: 세션은 서버에서 관리되므로, 사용자가 많아지면 서버의 메모리를 차지하게 되어 부하가 증가함.<br>
+ **로드 밸런싱 문제**: 다수의 서버가 운영되는 환경에서는 세션을 공유해야 하므로 추가적인 설정이 필요함.<br>
+ **쿠키 의존성**: 세션 ID를 저장하는 쿠키가 필요하며, 쿠키가 차단되거나 삭제되면 인증이 끊어질 수 있음.

-----------
#### 세션 기반 인증의 예제 코드
다음은 Java의 Spring Boot를 활용하여 간단한 세션 기반 인증을 구현하는 코드이다.

Controller - 로그인 및 로그아웃 처리
```java
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.util.HashMap;

@RestController
@RequestMapping("/auth")
public class AuthController {
    private static final HashMap<String, String> users = new HashMap<>();

    static {
        users.put("admin", "password123");
        users.put("user1", "mypassword");
    }

    @PostMapping("/login")
    public String login(@RequestParam String username, @RequestParam String password, HttpServletRequest request) {
        if (users.containsKey(username) && users.get(username).equals(password)) {
            HttpSession session = request.getSession();
            session.setAttribute("user", username);
            return "로그인 성공! 세션 ID: " + session.getId();
        }
        return "로그인 실패! 아이디 또는 비밀번호가 틀립니다.";
    }

    @GetMapping("/logout")
    public String logout(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            session.invalidate();
        }
        return "로그아웃 성공!";
    }
}
```
설명:
```/auth/login``` 엔드포인트를 호출하면 사용자의 인증을 처리하고 세션을 생성한다.<br>
인증이 완료되면, 서버는 세션 ID를 발급하고 이를 브라우저 쿠키에 저장한다.<br>
```/auth/logout``` 엔드포인트를 호출하면 세션이 만료되고 로그아웃이 처리된다.

----------
### 토큰 기반 인증(Token-Based Authentication)
**토큰 기반 인증(Token-Based Authentication)** 은 서버에서 사용자의 인증 상태를 유지하는 대신,<br>
클라이언트에게 **토큰(Token)** 을 발급하여 인증하는 방식이다.<br>
대표적인 예로 **JWT(Json Web Token)** 이 있다.

#### 토큰 기반 인증의 동작 과정
**사용자가 로그인 요청**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 아이디와 비밀번호를 입력하여 로그인 요청을 보냄.

**서버에서 사용자 인증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 사용자의 정보를 데이터베이스에서 조회하여 검증함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증이 성공하면, 서버는 해당 사용자에게 토큰(Token) 을 발급함.

**클라이언트가 토큰 저장**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트는 발급받은 토큰을 로컬 저장소(Local Storage) 또는 쿠키에 저장함.

**사용자의 요청 처리**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이후 사용자가 다른 요청을 보낼 때, HTTP 헤더에 토큰을 포함하여 전송함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 전달된 토큰을 검증하여 사용자의 신원을 확인함.

**토큰 만료 또는 갱신**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;토큰은 만료 시간이 정해져 있으며, 만료되면 새로운 토큰을 발급해야 함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;보안 강화를 위해 Refresh Token을 사용하여 새 토큰을 갱신할 수 있음.

### 토큰 기반 인증의 장점
**확장성 우수**: 서버에서 세션을 유지하지 않으므로, 분산 서버 환경에서도 쉽게 확장 가능.<br>
**클라이언트 독립적**: RESTful API 설계에 적합하며, 모바일 앱이나 웹 애플리케이션에서 동일한 방식으로 사용 가능.<br>
**로드 밸런싱 유리**: 서버가 세션을 관리하지 않으므로, 여러 서버 간 부하를 쉽게 분산 가능.

### 토큰 기반 인증의 단점
**보안 위험**: 토큰이 탈취되면 누구든지 인증된 사용자처럼 행동할 수 있음.<br>
**토큰 크기 문제**: JWT의 경우, Payload에 많은 정보를 담으면 토큰 크기가 커지고 네트워크 비용이 증가할 수 있음.<br>
**토큰 갱신 필요**: 세션은 자동으로 만료되지만, 토큰은 만료 후 갱신이 필요하여 추가적인 로직이 필요함.

### 토큰 기반 인증의 예제 코드
다음은 Spring Boot에서 JWT 기반 인증을 구현하는 간단한 코드이다.

JWT 발급 및 검증 서비스
```java
import io.jsonwebtoken.*;
import java.util.Date;

public class JwtUtil {
    private static final String SECRET_KEY = "mySecretKey";

    public static String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 30)) // 30분 후 만료
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }

    public static String validateToken(String token) {
        try {
            return Jwts.parser()
                    .setSigningKey(SECRET_KEY)
                    .parseClaimsJws(token)
                    .getBody()
                    .getSubject();
        } catch (Exception e) {
            return null;
        }
    }
}
```
설명:<br>
```generateToken()``` 메서드는 사용자 이름을 기반으로 JWT를 생성한다.<br>
```validateToken()``` 메서드는 토큰을 검증하고, 정상적인 토큰이면 사용자 이름을 반환한다.

------------
## 세션 기반 인증 vs 토큰 기반 인증 비교
|비교 항목|세션 기반 인증|토큰 기반 인증 (JWT)|
|:---|:---|:---|
|저장 위치|서버 세션 저장소|클라이언트 (쿠키 또는 로컬 저장소)|
|확장성|낮음|높음|
|로드 밸런싱|추가 설정 필요|유리함|
|보안성|높은 편|토큰 탈취 시 위험|

----------------
## 다양한 인증 방법 개요
### Basic Authentication (기본 인증)
**Basic Authentication(기본 인증)**은 가장 단순한 인증 방식 중 하나로,<br>
HTTP 요청의 ```Authorization``` 헤더에 사용자 이름과 비밀번호를 Base64로 인코딩하여 서버에 전달하는 방식이다.

### 동작 과정
**사용자가 요청을 보냄**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트가 특정 리소스에 접근할 때 사용자 이름과 비밀번호를 포함하여 요청을 보냄.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예를 들어, curl을 이용하여 요청할 경우 다음과 같이 전송할 수 있음.<br>
```curl -u username:password http://example.com/protected-resource```

**서버에서 인증 확인**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 요청의 ```Authorization``` 헤더를 확인하고,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자 이름과 비밀번호가 올바른지 검증함.

**인증 성공 시 응답 반환**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 올바른 자격 증명을 제공하면 서버는 요청한 리소스를 반환함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증이 실패하면 ```401 Unauthorized``` 상태 코드와 함께<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```WWW-Authenticate: Basic``` 헤더를 포함한 응답을 보냄.

### Base64 인코딩 방식의 이해
Basic Authentication 방식은 사용자 이름과 비밀번호를 단순히 Base64로 인코딩하여 전송한다.<br>
즉, 암호화된 것이 아니라 단순히 문자열을 변환한 것에 불과하다.

예를 들어, 다음과 같이 ```"admin:password123"```을 Base64로 변환하면 다음과 같다.

```echo -n "admin:password123" | base64```<br>
출력:<br>
```
YWRtaW46cGFzc3dvcmQxMjM=
```
HTTP 요청에 포함되는 방식:<br>
```
Authorization: Basic YWRtaW46cGFzc3dvcmQxMjM=
```

### Basic Authentication의 장점
**간단한 구현**: 별도의 세션 관리가 필요 없으며, 간단하게 사용할 수 있음.<br>
**HTTP 표준 지원**: 대부분의 브라우저 및 클라이언트에서 기본적으로 지원됨.<br>
**쿠키 사용 불필요**: 세션을 유지하기 위한 쿠키를 관리할 필요 없음.

### Basic Authentication의 단점
**보안 취약점:**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Base64 인코딩은 암호화가 아니므로, 네트워크에서 가로채기(패킷 스니핑) 시 쉽게 복호화 가능.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTPS 없이 사용하면 중간자 공격(MITM, Man-In-The-Middle Attack) 에 취약함.

**비밀번호가 매 요청마다 포함됨:**<br>\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 요청에서 사용자 이름과 비밀번호가 포함되므로, 탈취될 위험이 높음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;세션 기반 인증보다 보안성이 낮음.

**로그아웃이 어려움:**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic Auth는 클라이언트가 브라우저에 자격 증명을 저장하면,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강제로 로그아웃하는 기능이 어려움.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그아웃을 위해서는 브라우저 캐시를 삭제해야 함.

### Basic Authentication의 사용 예제
Spring Security에서 Basic Authentication을 활성화하려면 ```HttpSecurity``` 설정을 추가해야 한다.

Spring Security 설정 (Basic Auth 활성화)
```java
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .httpBasic(); // Basic Authentication 활성화
        return http.build();
    }
}
```
위 설정을 적용하면 모든 요청에 대해 인증이 필요하며,<br>
인증되지 않은 사용자는 기본적인 로그인 창을 통해 사용자 이름과 비밀번호를 입력해야 한다.

### OAuth (Open Authorization)
OAuth는 외부 인증 제공자를 활용하는 인증 방식으로,<br>
소셜 로그인(구글, 페이스북, 카카오 등)과 같은 서비스에서 주로 사용된다.

### OAuth의 동작 방식
**사용자가 로그인 요청**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자는 웹사이트에서 "Google 로그인" 또는 "Facebook 로그인" 버튼을 클릭함.

**OAuth 제공자로 리디렉션**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자는 인증을 위해 OAuth 제공자(예: Google)로 리디렉션됨.

**사용자 인증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자는 OAuth 제공자의 로그인 화면에서 계정 정보를 입력하여 인증함.

**Access Token 발급**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증이 완료되면, OAuth 제공자는 Access Token을 발급하여 클라이언트에게 전달함.

**Access Token을 사용하여 요청**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트는 Access Token을 HTTP 요청 헤더에 포함하여 API를 호출함.

**서버에서 검증 후 응답 반환**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 Access Token이 유효한지 확인하고, 요청된 리소스를 반환함.

### OAuth의 장점
**타사 인증 활용 가능**: 구글, 네이버, 카카오 등의 인증 시스템을 활용할 수 있음.<br>
**비밀번호 노출 위험 감소**: 사용자 비밀번호를 직접 저장하지 않음.<br>
**SSO(Single Sign-On) 지원**: 여러 애플리케이션 간 단일 로그인 가능.

### OAuth의 단점
**구현이 복잡함**: OAuth 2.0의 구조가 복잡하여 설정이 까다로움.<br>
**외부 서비스 의존성**: OAuth 제공자의 장애 발생 시 로그인이 불가능할 수 있음.

### OAuth의 사용 예제
Spring Security에서 OAuth 로그인을 설정하는 방법은 다음과 같다.

OAuth2 로그인 활성화 설정 (Google 로그인 예제)
```java
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.client.oidc.userinfo.OidcUserService;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2
                .userInfoEndpoint(userInfo -> userInfo
                    .oidcUserService(new OidcUserService())
                )
            );
        return http.build();
    }
}
```
----------
### JWT (JSON Web Token)
JWT(Json Web Token) 은 클라이언트가 인증 정보를 유지할 수 있도록 해주는 토큰 기반 인증 방식이다.

### JWT의 특징
토큰 자체에 사용자 정보를 포함함<br>
Stateless (서버에 세션 저장이 필요 없음)<br>
클라이언트가 직접 인증 정보를 유지하며 전송함

### JWT의 동작 과정
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 아이디와 비밀번호로 로그인 요청을 보냄.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 사용자의 자격 증명을 확인한 후, JWT를 발급하여 반환함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트는 받은 JWT를 로컬 스토리지 또는 쿠키에 저장함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이후 요청 시, 클라이언트는 JWT를 Authorization 헤더에 포함하여 전송함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 요청을 받을 때 JWT의 유효성을 검증하고, 사용자 정보를 확인한 후 요청을 처리함.

### JWT의 장점과 단점
|구분|장점|단점|
|:---|:---|:---|
|장점|세션이 필요 없으며 서버 부하 감소|탈취 시 보안 위험 존재|
|단점|탈취 시 도난 방지 방법 필요|토큰 크기가 커질 수 있음|

--------------------

## Spring Security 개요
### Spring Security의 개념
Spring Security는 Spring 기반 애플리케이션에서 인증(Authentication)과 인가(Authorization) 를 관리하는 강력한 보안 프레임워크이다.<br>
웹 애플리케이션이 증가함에 따라 보안 문제도 중요해졌으며, Spring Security는 이러한 보안 요구 사항을 충족하기 위해 제공된다.

Spring Security의 핵심 역할은 다음과 같다.
+ **사용자 인증(Authentication)**: 사용자의 신원을 확인하는 과정
+ **권한 부여(Authorization)**: 사용자가 특정 리소스에 접근할 수 있는지 결정하는 과정
+ **보안 기능 제공(Security Features)**: CSRF 방어, 세션 관리, CORS 설정 등 추가적인 보안 기능 지원
Spring Security는 애플리케이션에서 기본적으로 제공하는 보안 기능이 많아 개발자가 직접 보안 로직을 구현하는 부담을 줄여준다.

### Spring Security가 필요한 이유
웹 애플리케이션에서 보안 문제를 고려하지 않으면, 다음과 같은 보안 위협에 쉽게 노출될 수 있다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**인증되지 않은 사용자 접근**: 로그인 없이 중요한 정보에 접근할 가능성이 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**세션 탈취(Session Hijacking)**: 공격자가 세션 정보를 가로채어 불법적으로 로그인할 수 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**권한 상승(Privilege Escalation)**: 적절한 권한 검사가 없을 경우, 일반 사용자가 관리자로 동작할 가능성이 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**CSRF(Cross-Site Request Forgery)**: 사용자가 원하지 않는 요청이 악의적으로 전송될 가능성이 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**XSS(Cross-Site Scripting)**: 클라이언트 측에서 악성 스크립트가 실행될 위험이 있음.

Spring Security는 이러한 보안 위협을 해결하기 위해 인증과 인가 기능을 기본적으로 제공하며, 개발자가 보안 정책을 쉽게 적용할 수 있도록 한다.

------------------
### Spring Security의 주요 특징
Spring Security는 다른 보안 프레임워크와 비교했을 때 다음과 같은 강력한 기능을 제공한다.

**강력한 인증(Authentication) 기능 제공**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;폼 로그인(Form Login)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OAuth2 로그인 지원<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LDAP 인증 지원<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본 인증(Basic Authentication) 등 다양한 방식 지원

**세밀한 인가(Authorization) 기능**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 패턴을 기반으로 접근 제어 가능<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;메서드 단위에서 @PreAuthorize, @PostAuthorize를 활용한 권한 제어 가능

**보안 기능 제공**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;자동 CSRF 보호 기능<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;세션 고정(Session Fixation) 보호<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;브루트 포스 공격 방지<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비밀번호 암호화(BCryptPasswordEncoder) 지원

**통합 가능성**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot와의 자연스러운 통합 지원<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OAuth 2.0, JWT, SAML 같은 인증 방식과 쉽게 연동 가능

-------------
### Spring Security 기본 동작 흐름
Spring Security는 필터 체인을 통해 보안이 적용된다.<br>
기본적인 인증 흐름은 다음과 같다.

**사용자가 웹 애플리케이션에 접근**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트(사용자)는 특정 리소스에 접근을 시도함.

**Spring Security 필터가 요청을 가로챔**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityFilterChain이 요청을 분석하여 보안 정책을 적용함.

**사용자가 인증되지 않았다면 로그인 페이지로 이동**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그인 페이지로 리디렉션되거나, Basic Authentication의 경우 401 Unauthorized 응답이 반환됨.

**사용자가 인증을 진행**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 ID와 비밀번호를 입력하여 로그인 요청을 보냄.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AuthenticationManager가 UserDetailsService를 사용하여 사용자의 인증 정보를 검증함.

**인증이 성공하면 보안 컨텍스트에 저장**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;성공적인 로그인 후, SecurityContextHolder에 사용자 정보를 저장하여 인증 상태를 유지함.

**인가(Authorization) 과정 진행**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요청된 URL 또는 API가 해당 사용자에게 허용된 리소스인지 확인.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인가되지 않은 요청이면 403 Forbidden 응답을 반환함.

**인가된 사용자만 리소스에 접근 가능**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 권한이 허용된 경우, 요청된 리소스를 반환함.

-------------
### Spring Security의 주요 구성 요소
Spring Security는 몇 가지 핵심 구성 요소를 사용하여 인증과 인가를 수행한다.

```SecurityFilterChain```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security의 보안 설정을 적용하는 필터 체인.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요청을 가로채어 인증 및 인가 여부를 확인함.

```AuthenticationManager```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 로그인 요청을 처리하는 주요 컴포넌트.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserDetailsService와 PasswordEncoder를 사용하여 인증을 수행함.

```UserDetailsService```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자 정보를 제공하는 인터페이스.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스나 메모리에 저장된 사용자 정보를 불러오는 역할을 함.

```SecurityContextHolder```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 로그인한 사용자 정보를 저장하는 컨텍스트.

```BCryptPasswordEncoder```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비밀번호를 안전하게 저장하기 위해 사용되는 해시 알고리즘.

----------
### Spring Security 기본 설정 예제
Spring Security를 적용하는 가장 기본적인 방법은 ```SecurityFilterChain```을 설정하는 것이다.
아래는 모든 요청을 인증해야 하는 기본적인 Spring Security 설정이다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated() // 모든 요청을 인증 필요
            )
            .formLogin(withDefaults()); // 기본 로그인 페이지 사용
        return http.build();
    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(); // 비밀번호 암호화 적용
    }
}
```
설정 설명<br>
```authorizeHttpRequests```를 사용하여 모든 요청을 인증해야 함을 명시.<br>
```formLogin(withDefaults())```를 사용하여 기본 로그인 페이지를 제공.<br>
```BCryptPasswordEncoder```를 사용하여 비밀번호를 안전하게 저장하도록 설정.

이 설정을 적용하면,<br>
Spring Boot 애플리케이션을 실행했을 때 기본 제공 로그인 페이지가 나타나며,<br>
사용자가 로그인해야만 리소스에 접근할 수 있다.

-----------
### Spring Security의 주요 기능
Spring Security는 다양한 보안 기능을 제공하며, 그중 가장 핵심적인 기능은 인증(Authentication) 과 인가(Authorization) 이다.<br>
하지만 이 외에도 다양한 보안 기능을 기본적으로 제공하여 애플리케이션의 보안성을 강화할 수 있다.

Spring Security의 주요 기능은 다음과 같다.

**인증(Authentication)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 신원을 확인하는 과정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다양한 방식(Form Login, OAuth2, Basic Authentication 등) 지원.

**인가(Authorization)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 권한(Role)에 따라 리소스 접근을 제어.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 기반 및 메서드 기반 접근 제어 가능.

**비밀번호 암호화(Password Encoding)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```BCryptPasswordEncoder```를 활용하여 비밀번호를 안전하게 저장.

**CSRF 보호(Cross-Site Request Forgery Protection)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSRF 공격을 방어하기 위한 기본적인 보안 기능 제공.

**CORS 설정(Cross-Origin Resource Sharing)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다른 도메인에서의 요청을 제어할 수 있도록 CORS 정책을 설정 가능.

**세션 관리(Session Management)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;세션 고정 보호(Session Fixation Protection) 기능을 제공.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;세션 타임아웃, 동시 로그인 제한 등의 기능 지원.

**보안 필터 체인(Security Filter Chain)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요청을 가로채어 보안 정책을 적용하는 필터 체인 구조 제공.

**로그인 및 로그아웃 기능(Login & Logout)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그인 및 로그아웃 처리를 자동으로 지원.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;커스텀 로그인 페이지 적용 가능.<br>

**보안 컨텍스트 관리(Security Context)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityContextHolder를 활용하여 인증된 사용자 정보를 유지.<br>

**OAuth2 및 JWT(Json Web Token) 지원**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;외부 인증(OAuth2, Google, Kakao 등) 연동 가능.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stateless한 JWT 기반 인증을 구현할 수 있도록 지원.

------------------
### Spring Security의 핵심 컴포넌트
Spring Security는 여러 가지 핵심 컴포넌트를 통해 인증 및 인가를 수행한다.<br>
이제 주요 컴포넌트들의 역할을 살펴보자.

```SecurityFilterChain```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security의 보안 필터 체인.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 HTTP 요청을 가로채어 보안 설정을 적용함.

```AuthenticationManager```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 인증을 담당하는 주요 컴포넌트.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;여러 인증 방식을 지원하며, UserDetailsService를 사용하여 사용자 정보를 검증함.

```UserDetailsService```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자 정보를 로드하는 인터페이스.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스 또는 다른 저장소에서 사용자 정보를 불러오는 역할을 함.

```PasswordEncoder```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비밀번호를 안전하게 저장하기 위해 암호화하는 컴포넌트.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본적으로 BCryptPasswordEncoder를 사용함.

```SecurityContextHolder```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 로그인한 사용자 정보를 유지하는 컨텍스트.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증된 사용자 정보를 애플리케이션 전반에서 활용 가능함.

```GrantedAuthority```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자 권한을 나타내는 인터페이스.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROLE_USER, ROLE_ADMIN과 같은 권한 정보를 포함함.

```AccessDecisionManager```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인가(Authorization) 과정에서 사용자의 접근 여부를 결정하는 역할.<br>

---------------
### Spring Security의 필터 체인(Security Filter Chain)
Spring Security는 요청을 처리하기 위해 보안 필터 체인(Security Filter Chain) 을 사용한다.<br>
각 요청은 여러 개의 보안 필터를 거치면서 인증 및 인가가 수행된다.

필터 체인의 동작 순서는 다음과 같다.

-> 사용자가 애플리케이션에 요청을 보냄<br>
-> Spring Security의 필터 체인이 요청을 가로챔<br>
-> 인증이 필요한 요청인지 판단<br>
-> 필요한 경우 로그인 페이지로 리디렉션<br>
-> 사용자가 로그인하면 AuthenticationManager가 인증을 처리<br>
-> 성공적으로 인증되면 SecurityContext에 사용자 정보를 저장<br>
-> 인가(Authorization) 단계를 거쳐 사용자의 접근 권한을 확인<br>
-> 사용자가 권한을 가지고 있다면 요청을 정상적으로 처리<br>
-> 권한이 없다면 403 Forbidden 응답 반환<br>

------------
### Spring Security의 기본 설정 예제
Spring Security의 주요 기능을 활용하기 위해서는 필터 체인과 인증 설정을 구성해야 한다.<br>
아래는 Spring Boot에서 기본적인 보안 설정을 적용하는 코드 예제이다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin/**").hasRole("ADMIN") // ADMIN 권한이 필요한 요청
                .requestMatchers("/user/**").hasRole("USER") // USER 권한이 필요한 요청
                .anyRequest().authenticated() // 그 외 모든 요청은 인증 필요
            )
            .formLogin(login -> login // 기본 로그인 설정
                .loginPage("/login") // 커스텀 로그인 페이지 설정
                .defaultSuccessUrl("/") // 로그인 성공 시 이동할 페이지
                .permitAll() // 로그인 페이지는 인증 없이 접근 가능
            )
            .logout(logout -> logout // 로그아웃 설정
                .logoutUrl("/logout")
                .logoutSuccessUrl("/login?logout") // 로그아웃 성공 후 이동할 페이지
                .permitAll()
            )
            .csrf(csrf -> csrf.disable()); // CSRF 보호 비활성화 (API 서버인 경우)

        return http.build();
    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(); // 비밀번호 암호화 적용
    }
}
```
설정 설명
```authorizeHttpRequests```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;특정 URL 패턴에 대해 권한(Role) 기반의 접근 제어를 설정함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/admin/** 경로는 ADMIN 권한이 있어야 접근 가능.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/user/** 경로는 USER 권한이 있어야 접근 가능.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그 외 요청은 인증된 사용자만 접근 가능하도록 설정.

```formLogin```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본 로그인 기능을 활성화하고, /login 페이지를 로그인 페이지로 설정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그인 성공 시 / 페이지로 이동하도록 설정.

```logout```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/logout 요청 시 로그아웃 처리.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그아웃 후 /login?logout 페이지로 리디렉션.

```csrf.disable()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 서버의 경우 CSRF 보호를 비활성화할 수 있음.

```BCryptPasswordEncoder```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비밀번호를 안전하게 저장하기 위해 암호화를 적용함.<br>

--------------
### Spring Boot에서 Spring Security 기본 설정
Spring Boot에서 기본적으로 제공하는 보안 설정<br>
Spring Boot는 Spring Security를 함께 사용할 경우, 기본적으로 몇 가지 보안 설정을 자동으로 적용한다.<br>
이러한 기본 설정을 이해하는 것은 보안 구성을 커스터마이징하기 전에 중요한 개념이 된다.

**기본 로그인 페이지 제공**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security가 활성화되면 /login 경로에서 기본 로그인 페이지가 자동으로 제공된다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;별도로 설정하지 않아도 로그인 폼이 제공되며, 이 폼을 통해 사용자 인증이 이루어진다.

**기본 사용자 계정 생성**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 애플리케이션을 실행하면 자동으로 user라는 사용자 계정이 생성된다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;초기 비밀번호는 애플리케이션 실행 로그에서 확인할 수 있다.<br>

**기본적인 인증 및 접근 제어 적용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 요청은 기본적으로 인증이 필요하도록 설정된다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그인하지 않으면 자동으로 로그인 페이지로 리디렉션된다.

**CSRF(Cross-Site Request Forgery) 보호 활성화**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본적으로 CSRF 보호 기능이 활성화되어 있으며, 상태를 유지하는 웹 애플리케이션에서는 이를 유지하는 것이 보안상 중요하다.<br>

**세션 관리 및 자동 로그아웃**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본적으로 사용자의 세션을 관리하며, 일정 시간이 지나면 자동으로 로그아웃된다.<br>

-------------------
### Spring Boot의 기본 보안 설정 확인하기
Spring Boot에서 기본적으로 제공하는 보안 설정을 확인하려면 ```spring-boot-starter-security```를 추가하고 실행하면 된다.

먼저, spring-boot-starter-security를 의존성에 추가해야 한다.

Maven을 사용할 경우:
```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```
Gradle을 사용할 경우:
```java
implementation 'org.springframework.boot:spring-boot-starter-security'
```
이제 애플리케이션을 실행하면, 콘솔에 다음과 같은 메시지가 나타난다.
```
Using generated security password: a1b2c3d4e5f6
```
이 메시지는 Spring Boot가 기본적으로 생성한 user 계정의 초기 비밀번호를 의미한다.<br>
이제 브라우저에서 애플리케이션을 실행하고 ```/login``` 경로에 접속하면 기본 로그인 페이지가 나타난다.

------------------
### 기본 보안 설정을 비활성화하는 방법
기본적으로 제공되는 보안 설정을 비활성화하고, 직접 보안 구성을 커스터마이징하려면 ```SecurityFilterChain```을 설정해야 한다.

다음은 기본 로그인 페이지를 비활성화하고, 모든 요청을 인증 없이 접근 가능하도록 설정하는 예제이다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().permitAll() // 모든 요청을 인증 없이 허용
            )
            .csrf(csrf -> csrf.disable()) // CSRF 보호 기능 비활성화
            .formLogin(login -> login.disable()) // 기본 로그인 페이지 비활성화
            .logout(logout -> logout.disable()); // 로그아웃 기능 비활성화

        return http.build();
    }
}
```
---------------
#### 설정 설명
```authorizeHttpRequests().anyRequest().permitAll()```<br>
모든 요청을 인증 없이 허용한다.<br>
기본적으로 Spring Security는 모든 요청을 보호하지만, 이 설정을 적용하면 인증 없이 접근할 수 있다.

```csrf().disable()```<br>
CSRF 보호 기능을 비활성화한다.<br>
API 서버의 경우 보통 CSRF 보호가 필요하지 않지만, 웹 애플리케이션에서는 유지하는 것이 바람직하다.

```formLogin().disable()```<br>
기본 로그인 페이지를 비활성화한다.<br>
로그인을 직접 구현하거나 API 기반 인증을 사용할 경우 필요하다.

```logout().disable()```<br>
로그아웃 기능을 비활성화한다.<br>
별도의 로그아웃 로직을 직접 구현할 때 사용된다.

------------
### 커스텀 로그인 페이지 적용하기
기본 로그인 페이지 대신, 직접 만든 로그인 페이지를 적용할 수도 있다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin/**").hasRole("ADMIN") // ADMIN만 접근 가능
                .requestMatchers("/user/**").hasRole("USER") // USER만 접근 가능
                .anyRequest().authenticated() // 모든 요청은 인증 필요
            )
            .formLogin(login -> login
                .loginPage("/custom-login") // 커스텀 로그인 페이지 지정
                .defaultSuccessUrl("/") // 로그인 성공 시 이동할 경로
                .permitAll() // 로그인 페이지는 인증 없이 접근 가능
            );

        return http.build();
    }
}
```
**설정 설명**<br>
**```requestMatchers("/admin/**").hasRole("ADMIN")```**<br>
-> ```/admin/**``` 경로는 ADMIN 역할을 가진 사용자만 접근 가능하도록 설정.

**```requestMatchers("/user/**").hasRole("USER")```**<br>
-> ```/user/**``` 경로는 USER 역할을 가진 사용자만 접근 가능하도록 설정.

```formLogin().loginPage("/custom-login")```<br>
기본 로그인 페이지가 아닌, /custom-login 경로에 존재하는 로그인 페이지를 사용하도록 설정.

```defaultSuccessUrl("/")```<br>
로그인 성공 시 기본적으로 / 경로로 이동.

```permitAll()```<br>
로그인 페이지는 인증 없이 접근 가능해야 하므로 이를 명시.

------------
### Spring Boot에서 기본 보안 설정을 활용하는 방법 정리
Spring Boot와 Spring Security를 사용할 때, 기본적으로 제공되는 보안 기능을 활용하는 방법은 다음과 같다.

**기본 로그인 페이지 사용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/login 경로에서 제공되는 기본 로그인 폼을 활용할 수 있다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본적으로 user 계정이 생성되며, 비밀번호는 애플리케이션 실행 로그에서 확인 가능하다.

**자동으로 적용되는 보안 정책 이해**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security는 기본적으로 모든 요청을 보호한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증되지 않은 사용자는 자동으로 로그인 페이지로 리디렉션된다.

**보안 설정을 커스터마이징하여 필요에 맞게 변경 가능**<br>
필요하면 기본 설정을 비활성화하고, 직접 로그인 페이지를 만들거나 API 기반 인증을 구현할 수 있다.

---------------------
## Spring Security 설정 및 인증 구현
### Spring Security 설정 기본
Spring Security를 사용하여 애플리케이션을 보호하려면 먼저 보안 설정을 정의해야 한다.<br>
기본적으로 Spring Boot는 ```spring-boot-starter-security```를 추가하면 기본적인 보안 설정을 제공하지만,<br>
실제 애플리케이션에서는 사용자 요구사항에 맞게 직접 설정을 구성하는 것이 일반적이다.

Spring Security의 보안 설정을 구성하는 핵심 요소는 다음과 같다.

**인증(Authentication)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 신원을 확인하는 과정이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예를 들어, 사용자가 아이디와 비밀번호를 입력하고, 이것이 올바른지 검증하는 과정이 포함된다.

**인가(Authorization)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 권한을 확인하여 특정 기능에 접근할 수 있는지를 결정하는 과정이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예를 들어, 일반 사용자는 관리자 페이지에 접근하지 못하도록 제한할 수 있다.

**보안 필터(Security Filters)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security는 여러 개의 보안 필터를 통해 요청을 검사하고 보호한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그인, 로그아웃, 인증, 인가 등 다양한 보안 기능이 필터 체인을 통해 처리된다.

**CSRF 보호(Cross-Site Request Forgery Protection)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본적으로 활성화되어 있으며, 상태를 유지하는 웹 애플리케이션에서는 이를 유지하는 것이 바람직하다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;하지만 API 서버에서는 비활성화하는 경우가 많다.

**보안 컨텍스트(Security Context)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 인증된 사용자 정보를 관리하며, 이를 기반으로 인가가 이루어진다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityContext는 요청이 들어올 때마다 생성되며, 인증 정보를 저장한다.

--------------------
## Spring Security 설정 클래스 작성하기
Spring Security의 설정을 위해``` @Configuration``` 및 ```@EnableWebSecurity```를 사용하여 설정 클래스를 생성한다.

아래 예제는 기본적인 보안 설정을 적용하는 방법을 보여준다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin/**").hasRole("ADMIN") // 관리자 페이지 접근 제한
                .requestMatchers("/user/**").hasRole("USER") // 일반 사용자 페이지 접근 제한
                .anyRequest().authenticated() // 모든 요청은 인증 필요
            )
            .formLogin(login -> login
                .loginPage("/login") // 커스텀 로그인 페이지 지정
                .defaultSuccessUrl("/") // 로그인 성공 시 이동할 페이지
                .permitAll() // 로그인 페이지는 인증 없이 접근 가능
            )
            .logout(logout -> logout
                .logoutUrl("/logout") // 로그아웃 URL 지정
                .logoutSuccessUrl("/") // 로그아웃 후 이동할 페이지
                .invalidateHttpSession(true) // 세션 무효화
                .deleteCookies("JSESSIONID") // 로그아웃 시 쿠키 삭제
            )
            .csrf(csrf -> csrf.disable()); // API 사용을 위한 CSRF 비활성화

        return http.build();
    }
}
```
설정 설명
```authorizeHttpRequests()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요청에 대한 접근 제어를 설정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/admin/**``` 경로는 ADMIN 역할을 가진 사용자만 접근 가능하도록 설정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/user/**``` 경로는 USER 역할을 가진 사용자만 접근 가능하도록 설정.<br>
그 외의 모든 요청은 인증이 필요하도록 설정.

```formLogin()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;커스텀 로그인 페이지를 지정하고, 로그인 성공 시 이동할 URL을 설정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/login``` 경로에서 로그인 페이지를 제공하며, 인증되지 않은 사용자는 이 페이지로 리디렉션된다.

```logout()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그아웃 처리를 설정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/logout 경로에서 로그아웃을 수행하며, 성공 시 / 페이지로 이동하도록 설정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;세션을 무효화하고, JSESSIONID 쿠키를 삭제하여 보안성을 강화한다.<br>

```csrf().disable()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSRF 보호 기능을 비활성화한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 기반 애플리케이션에서는 필요하지 않지만, 웹 애플리케이션에서는 유지하는 것이 바람직하다.

-----------
### 보안 설정이 적용되는 흐름
위와 같이 Spring Security 설정을 적용하면, 애플리케이션에서 다음과 같은 흐름으로 보안이 작동한다.

-> 사용자가 ```/admin``` 페이지에 접근하면, 인증되지 않은 경우 로그인 페이지(```/login```)로 리디렉션된다.<br>
-> 사용자가 아이디와 비밀번호를 입력하고 로그인하면, Spring Security가 이를 검증한다.<br>
-> 검증이 완료되면 사용자는 권한에 따라 접근이 허용되거나 차단된다.<br>
-> 사용자가 로그아웃하면 세션이 무효화되고, 쿠키가 삭제된다.

--------------
### 추가 설정: 특정 API에 대한 인증 제외
Spring Security를 사용할 때, 인증이 필요 없는 API를 설정해야 하는 경우가 있다.<br>
예를 들어, 로그인 API(```/api/login```)와 회원가입 API(```/api/register```)는 인증 없이 접근할 수 있어야 한다.

아래와 같이 특정 API에 대해 인증을 제외할 수 있다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/login", "/api/register").permitAll() // 인증 없이 접근 허용
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasRole("USER")
                .anyRequest().authenticated()
            )
            .formLogin(login -> login
                .loginPage("/login")
                .defaultSuccessUrl("/")
                .permitAll()
            )
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/")
                .invalidateHttpSession(true)
                .deleteCookies("JSESSIONID")
            )
            .csrf(csrf -> csrf.disable());

        return http.build();
    }
}
```
**설정 설명**<br>
```requestMatchers("/api/login", "/api/register").permitAll()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/api/login과 /api/register는 인증 없이 접근할 수 있도록 설정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그인과 회원가입 기능은 보안 설정의 영향을 받지 않도록 예외 처리.

**그 외 요청은 인증 필요**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/admin/**``` → ADMIN 권한 필요.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/user/**``` → USER 권한 필요.
그 외 요청은 인증 필요.

------------
### Spring Security 설정의 중요성
Spring Security 설정을 직접 정의하는 것은 보안성을 강화하는 중요한 과정이다.<br>
특히, **어떤 요청에 대해 인증이 필요한지, 어떤 권한이 있어야 접근 가능한지**를 명확하게 설정하는 것이 중요하다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;웹 애플리케이션에서는 기본 보안 설정을 유지하면서 필요한 부분을 커스터마이징하는 것이 바람직하다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 서버에서는 CSRF 보호를 비활성화하고, 필요 없는 보안 설정을 제외하는 것이 일반적이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityFilterChain을 활용하면, 애플리케이션의 요구사항에 맞게 보안 구성을 유연하게 변경할 수 있다.

-----------------------
## 사용자 인증 구현
### Spring Security에서 사용자 인증의 개념
Spring Security에서 사용자 인증(Authentication)은 시스템에 접근하는 사용자가 신뢰할 수 있는지를 확인하는 과정이다.<br>
즉, 사용자가 올바른 자격 증명(예: 아이디와 비밀번호)을 제공해야 시스템에서 해당 사용자의 신원을 확인하고, 인증된 사용자로 간주할 수 있다.

Spring Security는 여러 방식으로 사용자 인증을 처리할 수 있다.
대표적인 방식은 다음과 같다.

**In-Memory 사용자 저장 방식**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;개발 및 테스트 단계에서 주로 사용되며, 애플리케이션 내에서 사용자를 직접 정의한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스를 사용하지 않고, 간단한 인증 로직을 빠르게 구현할 수 있다.

**Database 연동 방식**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실제 애플리케이션에서 주로 사용되는 방식으로, 사용자의 정보를 데이터베이스에 저장하고 관리한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;보통 UserDetailsService 인터페이스를 구현하여 데이터베이스에서 사용자 정보를 조회하는 방식으로 동작한다.

**OAuth2 및 JWT 기반 인증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소셜 로그인(OAuth2) 또는 토큰 기반 인증(JWT)을 사용하는 방식이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REST API 기반의 애플리케이션에서 많이 사용된다.

이제 Spring Security에서 사용자를 인증하는 방법을 자세히 살펴보자.

-------------
### In-Memory 사용자 저장 방식
테스트 및 초기 개발 단계에서는 데이터베이스 없이도 간단하게 사용자 인증을 처리할 수 있다.<br>
Spring Security에서는 InMemoryUserDetailsManager를 사용하여 메모리 내에서 사용자 정보를 저장하고 인증할 수 있도록 지원한다.

아래는 In-Memory 방식으로 사용자를 저장하고 인증하는 예제이다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.builder()
                .username("user")
                .password("{noop}password") // {noop}은 비밀번호 암호화를 하지 않는 설정
                .roles("USER")
                .build();

        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}admin")
                .roles("ADMIN")
                .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasRole("USER")
                .anyRequest().authenticated()
            )
            .formLogin(login -> login
                .loginPage("/login")
                .defaultSuccessUrl("/")
                .permitAll()
            )
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/")
            );

        return http.build();
    }
}
```
설정 설명
```userDetailsService()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```InMemoryUserDetailsManager```를 사용하여 사용자 정보를 메모리에 저장한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```User.builder()```를 사용하여 user와 admin 계정을 생성하며, 각 계정에 역할(ROLE_USER, ROLE_ADMIN)을 부여한다.<br>
```{noop}```을 사용하여 비밀번호 암호화 없이 저장하지만, 실제 환경에서는 반드시 암호화해야 한다.

```securityFilterChain()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/admin/**``` 경로는 ADMIN 역할을 가진 사용자만 접근 가능하도록 설정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/user/**``` 경로는 USER 역할을 가진 사용자만 접근 가능하도록 설정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;로그인 페이지를 ```/login```으로 설정하고, 성공 시 / 페이지로 이동하도록 지정.

--------------
### Database 연동을 통한 사용자 인증
실제 애플리케이션에서는 사용자를 메모리가 아닌 데이터베이스에 저장해야 한다.<br>
이 경우, UserDetailsService 인터페이스를 구현하여 데이터베이스에서 사용자 정보를 조회하는 방식을 사용한다.

먼저, 사용자 정보를 저장하는 엔티티 클래스를 작성한다.
```java
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    private String password;
    private String role;

    public UserEntity() {}

    public UserEntity(String username, String password, String role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }

    public String getUsername() { return username; }
    public String getPassword() { return password; }
    public String getRole() { return role; }
}
```
다음으로, Spring Data JPA를 활용하여 사용자 정보를 조회하는 UserRepository를 생성한다.
```java
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface UserRepository extends JpaRepository<UserEntity, Long> {
    Optional<UserEntity> findByUsername(String username);
}
```
이제 UserDetailsService를 구현하여 데이터베이스에서 사용자 정보를 조회하고 인증할 수 있도록 한다.
```java
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username));

        return User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .roles(user.getRole())
                .build();
    }

```
**설정 설명**<br>
```UserRepository```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```JpaRepository```를 확장하여 사용자 정보를 데이터베이스에서 조회할 수 있도록 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```findByUsername()``` 메서드를 정의하여 특정 사용자 정보를 검색한다.

```CustomUserDetailsService```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```UserDetailsService``` 인터페이스를 구현하여 데이터베이스에서 사용자 정보를 가져오는 역할을 수행한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```loadUserByUsername()``` 메서드를 오버라이드하여 사용자 정보를 조회하고, 존재하지 않으면 예외를 발생시킨다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;조회된 사용자 정보를 UserDetails 객체로 변환하여 반환한다.

--------------
### Spring Security 설정 적용
이제 SecurityConfig 클래스에서 데이터베이스 연동 방식의 사용자 인증을 적용할 수 있도록 설정한다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasRole("USER")
                .anyRequest().authenticated()
            )
            .formLogin(login -> login
                .loginPage("/login")
                .defaultSuccessUrl("/")
                .permitAll()
            )
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/")
            );

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}
```
-----------
## 비밀번호 암호화 적용
### 비밀번호 암호화의 필요성
비밀번호를 암호화하지 않고 저장하는 것은 보안적으로 매우 취약한 접근 방식이다.<br>
만약 데이터베이스에 저장된 비밀번호가 평문(Plain Text) 형태라면, 데이터 유출 시 누구나 해당 정보를 쉽게 확인할 수 있다.<br>
따라서, 사용자의 비밀번호는 반드시 암호화된 형태로 저장되어야 한다.

Spring Security에서는 비밀번호 암호화를 위해 ```BCryptPasswordEncoder```를 기본적으로 제공한다.<br>
```BCrypt```는 보안성이 뛰어난 해시 함수로, 내부적으로 솔트(Salt)를 적용하여 같은 비밀번호라도 서로 다른 해시 값이 생성되도록 한다.

다음은 비밀번호 암호화가 필요한 이유를 정리한 것이다.

**데이터 유출 방지**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스가 해킹당하더라도, 암호화된 비밀번호를 해독하기 어려우므로 보안성을 높일 수 있다.

**솔트(Salt) 적용으로 안전성 강화**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BCrypt는 해시값을 생성할 때 자동으로 솔트를 추가하여 동일한 비밀번호라도 다른 결과를 생성한다.<br>

**무차별 대입 공격(Brute-force Attack) 방어**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BCrypt는 연산 비용을 증가시키는 기능이 있어 해시 계산 속도를 조절할 수 있다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이를 통해 공격자가 무작위로 비밀번호를 대입하는 속도를 늦출 수 있다.

**재사용 공격 방지**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;암호화되지 않은 비밀번호가 유출될 경우, 다른 웹사이트에서도 동일한 비밀번호를 사용했을 가능성이 있다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;따라서 해시화된 비밀번호를 저장하면 유출 시에도 다른 사이트에서 쉽게 사용할 수 없다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이제 BCryptPasswordEncoder를 활용하여 비밀번호를 안전하게 암호화하는 방법을 살펴보자.

----------
### BCryptPasswordEncoder 사용 방법
Spring Security에서 제공하는 BCryptPasswordEncoder를 사용하면 간단하게 비밀번호를 암호화할 수 있다.<br>
아래 예제에서는 비밀번호를 해싱하고 비교하는 기본적인 사용 방법을 보여준다.
```java
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

public class PasswordEncryptionExample {
    public static void main(String[] args) {
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

        // 비밀번호 암호화
        String rawPassword = "mysecurepassword";
        String encodedPassword = passwordEncoder.encode(rawPassword);

        System.out.println("원본 비밀번호: " + rawPassword);
        System.out.println("암호화된 비밀번호: " + encodedPassword);

        // 비밀번호 비교
        boolean isMatch = passwordEncoder.matches(rawPassword, encodedPassword);
        System.out.println("비밀번호 일치 여부: " + isMatch);
    }
}
```
**설명**<br>
**비밀번호 해싱(암호화)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```BCryptPasswordEncoder().encode(rawPassword)```를 사용하여 원본 비밀번호를 암호화한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;같은 비밀번호라도 매번 다른 해시값이 생성된다.

**비밀번호 검증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```matches(rawPassword, encodedPassword)```를 사용하면 사용자가 입력한 비밀번호와 저장된 암호화된 비밀번호가 일치하는지 확인할 수 있다.
위 코드 실행 결과:
```
원본 비밀번호: mysecurepassword
암호화된 비밀번호: $2a$10$sfgj42M... (매번 다른 값이 생성됨)
비밀번호 일치 여부: true
```
--------------
### Spring Security 설정에 BCryptPasswordEncoder 적용
애플리케이션에서 사용자 인증을 구현할 때, ```BCryptPasswordEncoder```를 활용하여 비밀번호를 암호화한 후 데이터베이스에 저장해야 한다.<br>
이를 위해 ```UserDetailsService```에서 사용자 정보를 등록할 때 비밀번호를 암호화하는 방식으로 설정할 수 있다.

다음은 ```BCryptPasswordEncoder```를 Spring Security 설정에 적용하는 코드이다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```
위와 같이 ```@Bean```으로 ```PasswordEncoder```를 등록하면 애플리케이션 전반에서 ```BCryptPasswordEncoder```를 사용할 수 있다.

------------
### 비밀번호 암호화 후 사용자 등록 과정
이제 사용자 정보를 데이터베이스에 저장할 때 비밀번호를 암호화하는 과정을 구현해보자.

사용자 등록 요청을 처리하는 서비스 클래스
```java
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public void registerUser(String username, String rawPassword) {
        String encodedPassword = passwordEncoder.encode(rawPassword); // 비밀번호 암호화
        UserEntity user = new UserEntity(username, encodedPassword, "ROLE_USER");
        userRepository.save(user);
    }
}
```

비밀번호가 암호화된 상태로 저장됨을 확인하기 위한 JPA 엔티티
```java
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    private String password;
    private String role;

    public UserEntity() {}

    public UserEntity(String username, String password, String role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }

    public String getUsername() { return username; }
    public String getPassword() { return password; }
    public String getRole() { return role; }
}
```

사용자가 로그인할 때 입력한 비밀번호와 데이터베이스의 암호화된 비밀번호 비교
```java
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public CustomUserDetailsService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username));

        return User.builder()
                .username(user.getUsername())
                .password(user.getPassword()) // 데이터베이스의 암호화된 비밀번호 사용
                .roles(user.getRole())
                .build();
    }
}
```
**설명**<br>
**사용자 등록 시 비밀번호 암호화**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserService에서 사용자가 입력한 비밀번호를 passwordEncoder.encode()를 사용하여 암호화한 후 데이터베이스에 저장한다.

**로그인 시 비밀번호 검증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserDetailsService를 구현하는 CustomUserDetailsService에서 데이터베이스에서 사용자 정보를 가져온 후 password 필드의 값을 그대로 사용한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security가 내부적으로 PasswordEncoder를 사용하여 입력된 비밀번호와 저장된 해시값을 비교한다.

--------------
### 비밀번호 암호화 적용 시 주의할 점
**비밀번호를 평문으로 저장하지 말 것**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스에 비밀번호를 암호화하지 않고 저장하는 것은 보안상 매우 위험하다.

**적절한 해싱 알고리즘 사용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MD5, SHA-1 등의 알고리즘은 보안성이 낮아 사용하면 안 된다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BCrypt, Argon2, PBKDF2와 같은 강력한 해싱 알고리즘을 사용해야 한다.

**비밀번호 재설정 기능 제공**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 비밀번호를 변경할 수 있도록 적절한 로직을 구현해야 한다.

------------
## JWT(Json Web Token) 개념과 활용
### JWT의 개념과 필요성
#### JWT란 무엇인가?
JWT(Json Web Token)는 인증 및 정보 교환을 위한 토큰 기반 인증 방식이다.<br>
JWT는 사용자 인증 및 권한 부여 시스템에서 널리 사용되며, 클라이언트와 서버 간의 Stateless(상태를 유지하지 않는) 방식으로 작동한다.

기본적으로 JWT는 디지털 서명된 JSON 형태의 토큰이며, Base64Url 방식으로 인코딩된다.<br>
JWT는 크게 세 부분으로 구성되며, Header, Payload, Signature로 이루어져 있다.

--------------
### JWT가 필요한 이유
기존의 세션 기반 인증 방식에서는 서버가 사용자의 인증 정보를 관리하기 위해 세션을 유지해야 한다.<br>
하지만 이는 대규모 시스템에서 서버 부담 증가와 확장성 문제를 초래할 수 있다.

JWT를 활용하면 서버가 사용자의 인증 정보를 별도로 저장하지 않아도 된다.<br>
즉, Stateless 방식으로 동작하므로 확장성(Scalability) 이 뛰어나며, 부하 분산(Load Balancing) 이 용이하다.

----------
### JWT의 주요 특징
**Stateless(상태를 유지하지 않음)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버가 사용자의 세션을 관리할 필요가 없음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트가 요청 시 JWT를 포함하여 보내면 서버는 이를 검증하여 사용자를 인증함.

**자체 포함(Self-contained)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT에는 사용자의 인증 및 권한 정보가 포함되므로, 별도의 데이터베이스 조회 없이 유효성을 검증할 수 있음.

**보안성(Security)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디지털 서명(HS256, RS256 등)을 통해 위변조를 방지할 수 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTPS를 통해 안전하게 통신해야 함.

**유연성(Flexibility)**<br>
다양한 서비스(웹, 모바일, API)에서 쉽게 사용할 수 있음.

-------------
### JWT가 기존 인증 방식과 비교했을 때 가지는 장점과 단점
|인증 방식|장점|단점|
|:---|:---|:---|
|세션 기반 인증|- 서버가 직접 세션을 관리하여 높은 신뢰성 제공. <br> - 세션을 유지하는 동안만 인증이 유지됨.|- 서버 부담 증가(확장성 낮음). <br> - 서버 간 공유가 어려워 로드 밸런싱 적용이 어려움.|
|JWT 기반 인증|- Stateless한 방식으로 확장성이 뛰어남. <br> - 클라이언트가 토큰을 관리하므로 서버 부담 감소.|- 토큰이 유출될 경우 보안 문제가 발생할 수 있음. <br> - 토큰이 길어지면 네트워크 부하 증가 가능.|

-----------
### JWT의 활용 사례
JWT는 다음과 같은 다양한 분야에서 활용된다.

**웹 및 모바일 애플리케이션 인증(Authentication)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 로그인하면 서버에서 JWT를 발급하여 클라이언트에 전달.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이후 사용자는 요청 시 JWT를 포함하여 서버에 보내어 인증을 수행.

**API 인증 및 권한 부여(Authorization)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 요청 시 JWT를 사용하여 접근을 제어할 수 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROLE_USER, ROLE_ADMIN 등의 권한 정보를 포함하여 특정 기능에 대한 접근을 제한 가능.

**싱글 사인온(SSO, Single Sign-On)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 한 번 로그인하면 여러 서비스에서 동일한 인증 정보를 활용할 수 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT를 사용하면 별도의 세션을 유지하지 않고도 여러 시스템에서 인증이 가능.

**OAuth 2.0과의 연계**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OAuth 2.0에서 액세스 토큰(Access Token)으로 JWT를 활용할 수 있음.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT를 활용하면 인증 서버와 리소스 서버 간에 인증 정보를 쉽게 전달 가능.<br>

---------
### JWT를 사용할 때 고려해야 할 보안 이슈
JWT는 강력한 인증 방식이지만, 보안적으로 몇 가지 주의할 점이 있다.

**토큰 탈취 방지**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT는 탈취되면 누구나 사용할 수 있으므로, HTTPS를 반드시 사용해야 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 측에서 JWT를 안전하게 저장할 필요가 있다.

**토큰 만료 시간 설정**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT는 일정 시간이 지나면 만료되도록 설정해야 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만료된 토큰을 재사용할 수 없도록 해야 한다.

**Refresh Token 활용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Access Token의 수명을 짧게 설정하고, Refresh Token을 사용하여 새로운 JWT를 발급하는 구조를 도입해야 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refresh Token은 별도로 저장하고 보안이 강화된 방식으로 관리해야 한다.

**디지털 서명 검증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT는 디지털 서명을 통해 위변조를 방지할 수 있다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버에서 JWT의 서명을 항상 검증한 후 인증을 수행해야 한다.<br>

--------------
### Spring Boot에서 JWT를 활용하는 개요
Spring Boot에서 JWT를 사용하려면 다음과 같은 절차를 따른다.

**JWT 라이브러리 추가**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;io.jsonwebtoken 라이브러리를 활용하여 JWT를 생성하고 검증할 수 있음.

**JWT 발급(토큰 생성)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 로그인하면 서버에서 JWT를 생성하여 클라이언트에 반환.

**JWT 검증(토큰 확인)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트가 요청을 보낼 때 JWT를 포함하면 서버에서 이를 검증.

**JWT 기반 인증 필터 적용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security와 연동하여 JWT 필터를 적용하면 API 요청 시 자동으로 토큰을 검증할 수 있음.

-------------
 JWT 라이브러리 추가 예제
Spring Boot 프로젝트에서 JWT를 사용하려면 ```io.jsonwebtoken(JJWT)``` 라이브러리를 추가해야 한다.
```java
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.11.5</version>
</dependency>
```
이제 JWT를 발급하고 검증하는 예제 코드를 살펴보자.

JWT 생성 및 검증 기본 예제
```java
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;

public class JwtUtil {

    private static final String SECRET_KEY = "mySecretKey";
    private static final long EXPIRATION_TIME = 1000 * 60 * 10; // 10분

    // JWT 생성
    public static String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }

    // JWT 검증 및 파싱
    public static Claims parseToken(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody();
    }

    public static void main(String[] args) {
        String token = generateToken("user123");
        System.out.println("JWT: " + token);

        Claims claims = parseToken(token);
        System.out.println("사용자 이름: " + claims.getSubject());
    }
}
```
**설명**<br>
**JWT 생성**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Jwts.builder()```를 사용하여 JWT를 생성한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```setSubject(username)```: 사용자 이름을 토큰의 Subject에 저장.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))```: 만료 시간 설정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```signWith(SignatureAlgorithm.HS256, SECRET_KEY)```: 서명 알고리즘을 사용하여 토큰을 서명.

**JWT 검증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token).getBody();```를 사용하여 토큰을 검증하고 파싱한다.

-----------------
## JWT의 구조
### JWT의 3가지 구성 요소
JWT는 기본적으로 **Header, Payload, Signature**로 구성되며, 각 부분은 .(점)으로 구분된다.
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.
eyJzdWIiOiJ1c2VyMTIzIiwiaWF0IjoxNjgxMDAwMDAwLCJleHAiOjE2ODEwMDYwMDB9
.
M4eShgg0P9C7c9d5gJs79Bt-3mnpXL7TqX1Mfh39RQw
```
위와 같은 형태의 JWT는 Header.Payload.Signature로 구성되며, 각각의 역할을 살펴보자.

-------------------
### 1. Header (헤더)
JWT의 첫 번째 부분으로, 토큰의 타입과 서명 알고리즘 정보를 포함한다.<br>
다음과 같은 JSON 객체를 Base64Url로 인코딩한 값이다.
```
{
  "alg": "HS256",
  "typ": "JWT"
}
```
```"alg"```: 사용할 서명 알고리즘을 지정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예시: HS256(HMAC SHA-256), RS256(RSA SHA-256) 등
```"typ"```: 토큰의 타입을 나타낸다. 일반적으로 ```"JWT"```를 사용한다.

Base64Url 인코딩을 적용하면 다음과 같은 문자열이 된다.<br>
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

-------------
### 2. Payload (페이로드)
Payload는 토큰에 담을 정보(Claim)를 포함하는 부분으로, 사용자의 권한 및 추가 정보를 저장할 수 있다.<br>
이 JSON 객체도 Base64Url 인코딩하여 JWT의 두 번째 부분을 구성한다.

예제 JSON (Payload):
```
{
  "sub": "user123",
  "iat": 1681000000,
  "exp": 1681006000,
  "role": "USER"
}
```
Claim 설명:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```"sub"``` (Subject) : 토큰을 발급받은 사용자 ID<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```"iat"``` (Issued At) : 토큰이 발급된 시간 (Unix Timestamp)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```"exp"``` (Expiration) : 토큰의 만료 시간 (Unix Timestamp)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```"role"``` : 사용자 권한 (예: USER, ADMIN)

Base64Url 인코딩을 하면 다음과 같이 변환된다.<br>
```
eyJzdWIiOiJ1c2VyMTIzIiwiaWF0IjoxNjgxMDAwMDAwLCJleHAiOjE2ODEwMDYwMDB9
```

------------
### 3. Signature (서명)
Signature(서명)는 JWT의 무결성을 보장하기 위해 사용된다.<br>
서명 부분은 Header와 Payload를 조합한 값에 비밀 키(Secret Key)와 함께 특정 알고리즘을 적용하여 생성된다.

서명을 생성하는 과정은 다음과 같다.
```
HMACSHA256(
  base64UrlEncode(Header) + "." + base64UrlEncode(Payload),
  secret
)
```
예제:
```java
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

public class JwtSignatureExample {
    private static final String SECRET_KEY = "mySecretKey";

    public static void main(String[] args) {
        String signature = Jwts.builder()
                .setHeaderParam("alg", "HS256")
                .setHeaderParam("typ", "JWT")
                .setSubject("user123")
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();

        System.out.println("JWT 서명: " + signature);
    }
}
```
서명이 생성되면 JWT의 마지막 부분을 구성하며, 최종 JWT는 다음과 같은 형태가 된다.<br>
```
Header.Payload.Signature
```
예제 최종 JWT:<br>
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.
eyJzdWIiOiJ1c2VyMTIzIiwiaWF0IjoxNjgxMDAwMDAwLCJleHAiOjE2ODEwMDYwMDB9
.
M4eShgg0P9C7c9d5gJs79Bt-3mnpXL7TqX1Mfh39RQw
```

-----------------
### JWT의 전체 흐름 정리
-> 클라이언트가 서버에 로그인 요청을 보낸다.<br>
-> 서버는 사용자 정보를 확인하고, JWT를 생성하여 클라이언트에 반환한다.<br>
-> 클라이언트는 이후 요청 시 Authorization 헤더에 JWT를 포함하여 서버에 요청한다.<br>
-> 서버는 요청을 받을 때 JWT의 Signature를 검증하여 유효성을 확인한다.<br>
-> 검증이 성공하면 Payload의 정보로 사용자 권한을 확인하고 요청을 처리한다.

---------------
### JWT의 장점과 고려할 점

|항목|설명|
|:---|:---|
|장점|- Stateless 방식으로 서버 부하 감소.<br>- API 인증 및 권한 부여에 적합.<br>- JSON 기반으로 확장성이 뛰어남.|
|고려할 점|- 토큰이 유출되면 누구나 사용할 수 있으므로 HTTPS를 사용해야 함.<br>- 토큰 크기가 크므로 네트워크 부하 증가 가능.<br>- 서버가 토큰을 검증할 때 Signature 검증 로직이 필수적.|

--------------
## JWT 기반 인증 흐름
JWT 기반 인증은 서버가 세션을 관리하지 않고 클라이언트가 자체적으로 인증 정보를 포함하는 방식이다. 이 방식은 Stateless 인증을 지원하며, 클라이언트와 서버 간의 네트워크 트래픽을 최소화하고 확장성을 높이는 데 기여한다. JWT를 이용한 인증 과정은 다음과 같이 진행된다.

----------------
### JWT 인증 흐름 개요
JWT 인증 흐름은 토큰 발급, 토큰 저장 및 사용, 토큰 검증의 과정으로 이루어진다.

**사용자 로그인 요청**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 아이디와 비밀번호를 서버에 전송한다.

**서버에서 사용자 인증 및 JWT 발급**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버가 사용자의 자격 증명을 확인한 후, 해당 정보를 기반으로 JWT를 생성하여 클라이언트에게 반환한다.

**클라이언트가 JWT를 저장하고 사용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트는 서버로부터 받은 JWT를 로컬 저장소(Local Storage), 세션 스토리지(Session Storage) 또는 쿠키에 저장할 수 있다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이후 API 요청 시 HTTP Authorization 헤더에 JWT를 포함하여 요청을 보낸다.

**서버에서 JWT 검증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 클라이언트로부터 전달된 JWT의 서명을 확인하고, 토큰이 유효한 경우 요청을 정상적으로 처리한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만료된 토큰이거나 변조된 경우 요청을 거부한다.

------------
## JWT 인증 흐름 상세 단계
이제 각 단계를 자세히 살펴보자.
### 1. 사용자 로그인 요청 및 인증
사용자가 로그인을 시도하면 클라이언트는 아이디와 비밀번호를 서버로 전송한다.

클라이언트 요청 (HTTP 요청 예시):
```java

POST /api/auth/login HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "username": "user123",
  "password": "password123"
}
```

서버의 사용자 인증 코드 (Spring Boot 예제):
```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;

    public AuthController(AuthenticationManager authenticationManager, JwtTokenProvider jwtTokenProvider) {
        this.authenticationManager = authenticationManager;
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@RequestBody LoginRequest loginRequest) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        loginRequest.getUsername(),
                        loginRequest.getPassword()
                )
        );

        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtTokenProvider.generateToken(authentication);

        return ResponseEntity.ok(new JwtResponse(jwt));
    }
}
```
-----------------
### 2. JWT 생성 및 반환
서버가 사용자의 인증 정보를 확인한 후 JWT를 생성하고 클라이언트에게 반환한다.

JWT 생성 코드 (Spring Boot 예제):
```java
import io.jsonwebtoken.*;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import java.util.Date;

@Component
public class JwtTokenProvider {

    private final String JWT_SECRET = "mySecretKey";
    private final long JWT_EXPIRATION = 604800000L; // 7일

    public String generateToken(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();

        return Jwts.builder()
                .setSubject(userPrincipal.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + JWT_EXPIRATION))
                .signWith(SignatureAlgorithm.HS256, JWT_SECRET)
                .compact();
    }
}
```
서버는 생성된 JWT를 클라이언트에 반환한다.

서버 응답 (JWT 포함 예시):
```java
HTTP/1.1 200 OK
Content-Type: application/json

{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

---------------
### 3. 클라이언트의 JWT 저장 및 사용
클라이언트는 받은 JWT를 API 요청 시 Authorization 헤더에 포함하여 사용한다.

클라이언트 요청 (JWT 포함 예시):
```java
GET /api/user/me HTTP/1.1
Host: example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```
-------------
### 4. 서버에서 JWT 검증 및 요청 처리
서버는 클라이언트가 전송한 JWT를 검증하고, 유효한 경우 해당 사용자의 정보를 가져와 요청을 처리한다.

JWT 검증 코드 (Spring Boot 예제):
```java
import io.jsonwebtoken.*;
import org.springframework.stereotype.Component;
import java.util.Date;

@Component
public class JwtTokenProvider {

    private final String JWT_SECRET = "mySecretKey";

    public String getUsernameFromJWT(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(JWT_SECRET)
                .parseClaimsJws(token)
                .getBody();

        return claims.getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(JWT_SECRET).parseClaimsJws(token);
            return true;
        } catch (JwtException e) {
            return false;
        }
    }
}
```
JWT 검증이 성공하면 서버는 사용자 정보를 바탕으로 요청을 처리하고 응답을 반환한다.

--------------
### JWT 인증 흐름 요약
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 로그인 정보를 서버에 제출 → 서버에서 인증 후 JWT 발급<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트는 JWT를 저장하고 API 요청 시 포함<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버는 JWT의 유효성을 검증 → 검증이 성공하면 요청 처리

이 과정에서 서버는 세션을 유지할 필요가 없으며, Stateless한 인증 방식을 유지할 수 있다.

------------
### JWT 인증의 장점과 한계
|항목|설명|
|:---|:---|
|장점|- 서버에 세션을 저장할 필요가 없음 (Stateless).<br>- 확장성이 뛰어나며, API 서비스에 적합.<br>- 다른 도메인 및 마이크로서비스 환경에서도 사용 가능.|
|한계|- 토큰이 유출되면 누구나 사용할 수 있음 → HTTPS 필수.<br>- 토큰을 폐기할 방법이 제한적 (블랙리스트 방식 사용 필요).<br>- JWT 크기가 커서 네트워크 부하 발생 가능.|

----------
## Spring Security + JWT 적용
### JWT 기반 인증을 위한 Spring Security 설정
Spring Security를 활용하여 JWT 기반 인증을 적용하려면, 기본적으로 SecurityConfig 클래스를 생성하고, 사용자 인증 필터를 설정해야 한다. 이 과정에서는 JwtAuthenticationFilter를 구현하여 Spring Security의 필터 체인에 추가하는 것이 핵심이다.

------------------
### Spring Security 설정을 위한 기본 구조
JWT를 활용한 인증 설정을 하기 위해 Spring Security의 설정 파일을 생성해야 한다. 아래는 SecurityConfig 클래스를 생성하고 HttpSecurity를 구성하는 코드이다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final UserDetailsService userDetailsService;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter, UserDetailsService userDetailsService) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```
**설정 코드 설명**<br>
위 코드에서 JWT 기반 인증을 적용하기 위해 설정한 주요 내용은 다음과 같다.

**JWT 인증 필터 적용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```JwtAuthenticationFilter```를 ```UsernamePasswordAuthenticationFilter``` 앞에 추가한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이를 통해 클라이언트 요청이 Spring Security 필터 체인을 거칠 때 JWT 검증이 먼저 실행된다.

**CSRF 보호 비활성화 (```csrf().disable()```)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT 기반 인증에서는 세션을 사용하지 않기 때문에 CSRF 보호가 불필요하다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만약 CSRF 보호가 필요하다면 별도로 설정해야 한다.

**세션 정책을 Stateless 모드로 설정 (```sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS```))**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT 기반 인증에서는 서버가 세션을 저장하지 않는다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;따라서 STATELESS 모드로 설정하여 클라이언트가 매 요청마다 JWT를 포함하도록 한다.

**보호된 엔드포인트 설정 (authorizeHttpRequests())**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/auth/**``` 엔드포인트는 인증 없이 접근할 수 있도록 permitAll()을 설정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;나머지 모든 요청은 인증을 요구하도록 설정 (```anyRequest().authenticated()```).

--------------
### JWT 인증 필터 구현
JWT 인증을 처리하기 위해 JwtAuthenticationFilter를 구현해야 한다. 이 필터는 JWT를 검증하고 사용자 정보를 SecurityContext에 저장하는 역할을 한다.
```java
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final UserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider, UserDetailsService userDetailsService) {
        this.jwtTokenProvider = jwtTokenProvider;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String token = jwtTokenProvider.extractToken(request);
        if (token != null && jwtTokenProvider.validateToken(token)) {
            String username = jwtTokenProvider.getUsernameFromToken(token);
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        filterChain.doFilter(request, response);
    }
}
```
----------
### JWT 인증 필터 동작 원리
**요청에서 JWT를 추출**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```jwtTokenProvider.extractToken(request)```를 통해 Authorization 헤더에서 JWT를 가져온다.

**JWT 검증**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```jwtTokenProvider.validateToken(token)```을 통해 토큰이 유효한지 확인한다.

**JWT에서 사용자 정보 추출 및 인증 객체 생성**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```jwtTokenProvider.getUsernameFromToken(token)```을 통해 사용자의 아이디를 가져온다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```userDetailsService.loadUserByUsername(username)```을 통해 사용자 정보를 로드한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증 객체 (UsernamePasswordAuthenticationToken)를 생성하여 SecurityContext에 저장한다.

**요청을 다음 필터로 전달**<br>
```filterChain.doFilter(request, response);```를 호출하여 요청을 다음 필터로 넘긴다.

------------
### JWT 토큰 프로바이더 구현
JWT를 생성하고 검증하는 JwtTokenProvider 클래스를 구현해야 한다.
```java
import io.jsonwebtoken.*;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import java.util.Date;

@Component
public class JwtTokenProvider {

    private final String JWT_SECRET = "mySecretKey";
    private final long JWT_EXPIRATION = 604800000L; // 7일

    public String generateToken(UserDetails userDetails) {
        return Jwts.builder()
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + JWT_EXPIRATION))
                .signWith(SignatureAlgorithm.HS256, JWT_SECRET)
                .compact();
    }

    public String extractToken(HttpServletRequest request) {
        String header = request.getHeader("Authorization");
        if (header != null && header.startsWith("Bearer ")) {
            return header.substring(7);
        }
        return null;
    }

    public String getUsernameFromToken(String token) {
        return Jwts.parser()
                .setSigningKey(JWT_SECRET)
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(JWT_SECRET).parseClaimsJws(token);
            return true;
        } catch (JwtException e) {
            return false;
        }
    }
}
```
### Spring Security와 JWT 연동을 위한 전체 흐름
**사용자가 로그인 요청을 보냄 (```/api/auth/login```)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서버에서 사용자 정보를 검증 후 JWT를 생성하여 응답.

**클라이언트는 JWT를 저장하고 API 요청 시 ```Authorization``` 헤더에 포함**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이후 API 요청마다 JWT를 Bearer Token으로 전송.<br>

**Spring Security 필터 체인에서 JwtAuthenticationFilter가 실행**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Authorization``` 헤더에서 JWT를 추출하고 검증.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;토큰이 유효한 경우 사용자 정보를 ```SecurityContext```에 저장.

**보호된 엔드포인트에 대한 요청을 처리**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인증된 사용자의 요청만 접근할 수 있도록 보안 설정이 적용됨.

----------------
## JWT 발급 및 검증 로직 구현
Spring Security에서 JWT 기반 인증을 적용하려면, JWT 생성, 검증, 사용자 정보 추출 기능이 필요하다. 이를 위해 JWT를 발급하는 서비스와 JWT를 검증하는 기능을 구현해야 한다.

### JWT 생성 과정
JWT는 사용자가 인증에 성공했을 때 생성된다. 이를 위해 로그인 요청을 처리하는 API에서 사용자의 정보를 검증한 후, JWT를 생성하여 클라이언트에게 반환해야 한다.

JWT 생성 로직을 포함하는 AuthService 클래스의 구현 예제:
```java
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Service;

@Service
public class AuthService {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final UserDetailsService userDetailsService;

    public AuthService(AuthenticationManager authenticationManager,
                       JwtTokenProvider jwtTokenProvider,
                       UserDetailsService userDetailsService) {
        this.authenticationManager = authenticationManager;
        this.jwtTokenProvider = jwtTokenProvider;
        this.userDetailsService = userDetailsService;
    }

    public String authenticate(String username, String password) {
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(username, password)
        );
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        return jwtTokenProvider.generateToken(userDetails);
    }
}
```
**JWT 생성 로직 설명**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 로그인 요청을 하면 ```authenticate(username, password)```를 호출한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```authenticationManager.authenticate(...)```를 사용하여 사용자의 자격 증명을 확인한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자의 정보를 로드한 후, ```jwtTokenProvider.generateToken(userDetails)```를 호출하여 JWT를 생성한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;생성된 JWT는 클라이언트에게 반환된다.

--------------
### JWT 생성 및 서명 (JwtTokenProvider 클래스의 generateToken 메서드)
JWT를 생성하는 로직을 구현하기 위해 ```JwtTokenProvider``` 클래스에서 사용자 정보를 바탕으로 토큰을 생성한다.
```java
import io.jsonwebtoken.*;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import java.util.Date;

@Component
public class JwtTokenProvider {

    private final String JWT_SECRET = "mySecretKey";  // 서명 키 (보안적으로 안전한 값으로 설정해야 함)
    private final long JWT_EXPIRATION = 604800000L;  // 7일 (밀리초 단위)

    public String generateToken(UserDetails userDetails) {
        return Jwts.builder()
                .setSubject(userDetails.getUsername())  // 사용자 ID 저장
                .setIssuedAt(new Date())  // 발급 시간
                .setExpiration(new Date(System.currentTimeMillis() + JWT_EXPIRATION))  // 만료 시간
                .signWith(SignatureAlgorithm.HS256, JWT_SECRET)  // HMAC SHA-256 서명
                .compact();
    }
}
```
**JWT 생성 과정**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```setSubject(userDetails.getUsername())``` → JWT의 subject 필드에 사용자명을 저장한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```setIssuedAt(new Date())``` → JWT가 발급된 시간을 저장한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```setExpiration(...)``` → JWT의 만료 시간을 설정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```signWith(SignatureAlgorithm.HS256, JWT_SECRET)``` → HMAC SHA-256 알고리즘으로 JWT에 서명한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```.compact()``` → 최종적으로 JWT 문자열을 생성하여 반환한다.

-----------
### JWT 검증 과정
JWT를 검증하는 과정은 다음과 같다.
+ JWT의 서명이 올바른지 확인
+ JWT가 만료되지 않았는지 확인
+ JWT에서 사용자 정보를 추출하여 사용자의 권한을 확인

JwtTokenProvider 클래스의 검증 로직 (validateToken 메서드):
```java
public boolean validateToken(String token) {
    try {
        Jwts.parser().setSigningKey(JWT_SECRET).parseClaimsJws(token);
        return true;
    } catch (ExpiredJwtException e) {
        System.out.println("JWT가 만료되었습니다.");
    } catch (MalformedJwtException e) {
        System.out.println("JWT 형식이 올바르지 않습니다.");
    } catch (SignatureException e) {
        System.out.println("JWT 서명이 올바르지 않습니다.");
    } catch (IllegalArgumentException e) {
        System.out.println("JWT 값이 잘못되었습니다.");
    }
    return false;
}
```

**JWT 검증 과정 설명**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Jwts.parser().setSigningKey(JWT_SECRET).parseClaimsJws(token);```전달된 JWT가 올바르게 서명되었는지 검증한다.<br>
**예외 처리:**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```ExpiredJwtException``` → 토큰이 만료된 경우 예외 발생<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```MalformedJwtException``` → 토큰 형식이 올바르지 않은 경우 예외 발생<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```SignatureException``` → JWT의 서명이 올바르지 않은 경우 예외 발생<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```IllegalArgumentException``` → 잘못된 값이 전달된 경우 예외 발생<br>
모든 검증을 통과하면 true를 반환하고, 그렇지 않으면 false를 반환한다.

-----------------
### JWT에서 사용자 정보 추출
JWT가 유효한 경우, 토큰에서 사용자 정보를 추출할 수 있다.
```java
public String getUsernameFromToken(String token) {
    return Jwts.parser()
            .setSigningKey(JWT_SECRET)
            .parseClaimsJws(token)
            .getBody()
            .getSubject();  // 사용자 ID (username) 반환
}
```
**JWT에서 사용자 정보 추출 과정**<br>
JWT를 파싱하여 ```setSigningKey(JWT_SECRET)```로 서명을 검증한다.<br>
```parseClaimsJws(token).getBody().getSubject()```를 호출하여 subject 필드에 저장된 사용자 ID를 추출한다.

--------------
### JWT를 이용한 로그인 API 구현
위에서 작성한 AuthService를 사용하여 로그인 엔드포인트를 구현할 수 있다.
```java
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        String token = authService.authenticate(request.getUsername(), request.getPassword());
        return ResponseEntity.ok(new AuthResponse(token));
    }
}
```

**요청 및 응답 DTO 정의**<br>
로그인 요청 및 응답을 처리하기 위해 DTO 클래스를 추가해야 한다.
```java
public class LoginRequest {
    private String username;
    private String password;

    // 기본 생성자, getter, setter 추가
}
public class AuthResponse {
    private String token;

    public AuthResponse(String token) {
        this.token = token;
    }

    // getter 추가
}
```
**로그인 API 동작 과정**<br>
-> 클라이언트가 ```/api/auth/login``` 엔드포인트로 username과 password를 전송한다.<br>
-> ```AuthService.authenticate()```를 호출하여 인증을 진행한다.<br>
-> 인증이 성공하면 ```jwtTokenProvider.generateToken(userDetails)```를 호출하여 JWT를 생성한다.<br>
-> 생성된 JWT를 AuthResponse 객체에 담아 클라이언트에 응답한다.

-------------------
### 인증 필터 적용 및 Spring Security 연동
Spring Security에서 JWT 기반 인증을 사용하려면 JWT 인증 필터를 구현하여 HTTP 요청마다 JWT를 검증해야 한다. 이를 위해 ```OncePerRequestFilter```를 활용하여 JWT를 확인하고, 검증된 사용자 정보를 ```SecurityContext```에 저장하는 작업이 필요하다.

-----------
### JWT 인증 필터 (JwtAuthenticationFilter)
Spring Security에서 JWT 인증을 처리하는 필터를 생성해야 한다. 이 필터는 모든 요청이 들어올 때 실행되며, 클라이언트가 전송한 JWT를 추출하고, 검증하여 인증 정보를 설정하는 역할을 한다.
```java
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final UserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider, UserDetailsService userDetailsService) {
        this.jwtTokenProvider = jwtTokenProvider;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        String token = getJwtFromRequest(request);

        if (token != null && jwtTokenProvider.validateToken(token)) {
            String username = jwtTokenProvider.getUsernameFromToken(token);
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            if (userDetails != null) {
                JwtAuthenticationToken authentication = new JwtAuthenticationToken(userDetails);
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```
**JWT 인증 필터 로직 설명**<br>
**getJwtFromRequest(request):**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요청 헤더에서 ```Authorization``` 값을 가져오고, "Bearer "로 시작하는 경우 JWT를 추출한다.

**jwtTokenProvider.validateToken(token):**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT가 유효한지 검증한다.

**jwtTokenProvider.getUsernameFromToken(token):**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT에서 사용자명을 추출한다.

**userDetailsService.loadUserByUsername(username):**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스 또는 In-Memory에서 사용자 정보를 가져온다.

**SecurityContextHolder.getContext().setAuthentication(authentication):**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security의 인증 컨텍스트에 인증 정보를 저장한다.

---------------
### JwtAuthenticationToken 클래스
Spring Security에서는 ```UsernamePasswordAuthenticationToken```을 주로 사용하지만, JWT 인증에서는 비밀번호 검증이 필요하지 않으므로 새로운 ```JwtAuthenticationToken``` 클래스를 만들어 사용한다.
```java
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import java.util.Collection;

public class JwtAuthenticationToken extends AbstractAuthenticationToken {

    private final Object principal;

    public JwtAuthenticationToken(Object principal) {
        super(null);
        this.principal = principal;
        setAuthenticated(true);
    }

    @Override
    public Object getCredentials() {
        return null;
    }

    @Override
    public Object getPrincipal() {
        return this.principal;
    }
}
```
**JwtAuthenticationToken 역할**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security에서 인증 객체를 다루기 위한 클래스<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```getCredentials()``` 메서드는 JWT 기반 인증에서는 필요하지 않으므로 null 반환<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```getPrincipal()```은 사용자 정보를 포함하는 객체 반환

------------
### Spring Security 설정에 필터 등록
SecurityConfig에서 위에서 만든 JwtAuthenticationFilter를 필터 체인에 등록해야 한다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  // JWT 사용 시 Stateless 설정
            .and()
            .authorizeHttpRequests()
            .antMatchers("/api/auth/login").permitAll()  // 로그인 API는 인증 없이 접근 가능
            .anyRequest().authenticated()  // 나머지 요청은 인증 필요
            .and()
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);  // JWT 필터 등록

        return http.build();
    }
}
```
**설정 적용 과정**<br>
**CSRF 비활성화 (```http.csrf().disable()```)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT 기반 인증에서는 CSRF 토큰이 필요 없으므로 비활성화.

**세션을 사용하지 않도록 설정 (```sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)```)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT는 Stateless 방식이므로, 세션을 사용하지 않도록 설정.

**API 엔드포인트별 인증 설정**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/auth/login```은 인증 없이 접근 가능하도록 ```permitAll()```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;나머지 API 요청은 ```authenticated()```로 보호.

**JWT 인증 필터 추가**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기존 Spring Security의 ```UsernamePasswordAuthenticationFilter```보다 먼저 실행되도록 필터 등록.

----------------
### JWT 인증 적용 후 API 요청 흐름
사용자가 ```/api/auth/login``` 엔드포인트로 username과 password를 전송.<br>
```AuthService```에서 사용자 정보를 검증하고 JWT를 생성하여 클라이언트에 반환.<br>
이후 API 요청 시, 클라이언트는 JWT를 "Authorization" 헤더에 포함하여 요청을 보냄.
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsIn...
```
```JwtAuthenticationFilter```가 요청을 가로채서:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT가 유효한지 검증<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT에서 사용자 정보 추출<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Security의 ```SecurityContext```에 인증 정보 저장

인증이 성공하면 요청이 컨트롤러로 전달됨.

-----------------
## API 요청 보호 및 권한 관리
### 특정 API 보호 설정
Spring Security에서는 특정 엔드포인트에 대한 접근을 제한하여 보안성을 강화할 수 있다. **API 보호는 인증(Authenticated) 여부와 권한(Role)** 을 기반으로 동작한다. 이를 설정하는 방식에는 다음과 같은 방법이 있다.

---------------
### 엔드포인트별 접근 제한 설정
Spring Security에서는 특정 엔드포인트에 대한 접근을 제한하는 방법으로 authorizeHttpRequests() 메서드를 활용한다. 이를 통해 인증이 필요하거나 특정 역할을 가진 사용자만 접근할 수 있도록 설정할 수 있다.

다음은 Spring Security에서 특정 API 보호를 설정하는 방법이다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()  // CSRF 보호 비활성화 (JWT 사용 시 필요 없음)
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 세션 사용 안 함
            .and()
            .authorizeHttpRequests()
            .antMatchers("/api/public/**").permitAll()  // 누구나 접근 가능
            .antMatchers("/api/user/**").hasRole("USER")  // USER 권한 필요
            .antMatchers("/api/admin/**").hasRole("ADMIN") // ADMIN 권한 필요
            .anyRequest().authenticated();  // 그 외 모든 요청은 인증 필요

        return http.build();
    }
}
```
**설정 설명**<br>
```.antMatchers("/api/public/**").permitAll():```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/public/``` 하위 모든 API는 누구나 접근 가능하도록 설정.

```.antMatchers("/api/user/**").hasRole("USER"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/user/``` 하위 API는 USER 권한이 있는 사용자만 접근 가능하도록 설정.

```.antMatchers("/api/admin/**").hasRole("ADMIN"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/admin/``` 하위 API는 ADMIN 권한이 있는 사용자만 접근 가능하도록 설정.

```.anyRequest().authenticated():```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;위에 명시된 엔드포인트를 제외한 모든 API 요청은 인증된 사용자만 접근 가능.

---------------
## @PreAuthorize와 @PostAuthorize를 활용한 권한 제어
Spring Security에서는 메서드 수준에서도 접근 제한을 설정할 수 있다. 이를 위해 @PreAuthorize와 @PostAuthorize를 사용한다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@PreAuthorize```: 메서드 실행 전에 권한을 검사.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@PostAuthorize```: 메서드 실행 후 반환 값을 기반으로 권한을 검사.

사용 예제
```java
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.access.prepost.PostAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping("/api/user/profile")
    @PreAuthorize("hasRole('USER')")
    public String getUserProfile() {
        return "사용자 프로필 정보";
    }

    @GetMapping("/api/admin/data")
    @PreAuthorize("hasRole('ADMIN')")
    public String getAdminData() {
        return "관리자 전용 데이터";
    }

    @GetMapping("/api/resource")
    @PostAuthorize("returnObject.owner == authentication.name")
    public UserResource getResource(@RequestParam Long id) {
        return new UserResource(id, "ownerUsername");
    }
}
```
**설정 설명**<br>
```@PreAuthorize("hasRole('USER')"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/user/profile``` API는 USER 역할이 있는 사용자만 접근 가능.<br>

```@PreAuthorize("hasRole('ADMIN')"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/admin/data``` API는 ADMIN 역할이 있는 사용자만 접근 가능.<br>

```@PostAuthorize("returnObject.owner == authentication.name"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;반환된 객체의 owner 속성이 현재 로그인한 사용자와 일치하는 경우에만 접근 허용.

----------------
## 스프링 시큐리티에서 @PreAuthorize를 활성화하는 방법
Spring Security에서 ```@PreAuthorize```와 ```@PostAuthorize```를 사용하려면 @EnableMethodSecurity를 활성화해야 한다.
```java
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;

@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {
}
```
```@EnableMethodSecurity```를 추가하면 ```@PreAuthorize```와 ```@PostAuthorize```를 사용할 수 있다.

-----------------
## 보호된 API 요청 흐름
-> 클라이언트가 ```/api/user/profile```을 요청.<br>
-> 요청 헤더에 JWT 포함.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Authorization: Bearer eyJhbGciOiJIUzI1NiIsIn...```<br>
-> ```JwtAuthenticationFilter```에서 JWT 검증 후 ```SecurityContext```에 사용자 정보 저장.<br>
-> Spring Security에서 요청된 API의 접근 권한 확인:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@PreAuthorize("hasRole('USER')")``` 설정이 적용된 경우, USER 역할이 있는지 확인.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@PreAuthorize("hasRole('ADMIN')")``` 설정이 적용된 경우, ADMIN 역할이 있는지 확인.<br>
권한이 없으면 ```403 Forbidden``` 응답 반환.

-------------------
## 보호된 API에 대한 인증되지 않은 요청 예제
만약 사용자가 인증 없이 ```@PreAuthorize("hasRole('USER')")```가 적용된 API를 요청하면 다음과 같은 응답을 받게 된다.
```java
{
  "timestamp": "2025-02-18T10:30:45.123+00:00",
  "status": 403,
  "error": "Forbidden",
  "message": "Access is denied",
  "path": "/api/user/profile"
}
```
```403 Forbidden```:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 요청을 보냈지만 권한이 없어서 접근이 거부됨.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT가 없거나, ROLE_USER 권한이 없는 경우 발생.

---------------
### API 보호 설정의 핵심 포인트
**HTTP 요청 수준 보호 (```authorizeHttpRequests()```)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;특정 엔드포인트는 ```permitAll()```, 특정 역할 필요 시 ```hasRole('USER')``` 사용.

**메서드 수준 보호 (@PreAuthorize 및 @PostAuthorize)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;세밀한 권한 관리를 위해 컨트롤러의 메서드에 직접 적용.

**Spring Security 필터 체인과 함께 JWT 인증 적용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```JwtAuthenticationFilter```에서 JWT 검증 후 ```SecurityContext```에 인증 정보 저장.

---------------
## Role 기반 접근 제어
Spring Security에서는 사용자의 역할(Role)에 따라 API 접근을 제한하는 기능을 제공한다. 이 기능을 통해 **각 사용자의 권한 수준을 설정하고, 특정 역할(Role)이 있는 사용자만 특정 API에 접근하도록 설정**할 수 있다. 이를 설정하는 방식에는 다음과 같은 방법이 있다.

### Spring Security에서 Role 기반 접근 제어
Role 기반 접근 제어는 보안이 중요한 애플리케이션에서 필수적인 요소이다. 예를 들어, 일반 사용자는 ```USER``` 역할을 부여받아 특정 리소스에 접근할 수 있으며, 관리자 ```ADMIN```는 더 높은 권한을 갖고 추가적인 기능을 수행할 수 있다.

Spring Security에서는 세 가지 방법으로 Role 기반 접근 제어를 할 수 있다.
+ HTTP 요청 수준에서 Role 설정 (authorizeHttpRequests())
+ 메서드 수준에서 Role 설정 (@PreAuthorize, @PostAuthorize)
+ SecurityContext를 활용한 Role 확인

----------------------
### 1. HTTP 요청 수준에서 Role 설정 (```authorizeHttpRequests()```)
Spring Security에서는 특정 URL 패턴에 따라 접근을 제한할 수 있다. 이를 위해 ```SecurityConfig```에서 ```authorizeHttpRequests()``` 메서드를 활용한다.

다음은 Spring Security에서 Role 기반 접근 제어를 설정하는 예제이다.
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests()
            .antMatchers("/api/public/**").permitAll()  // 누구나 접근 가능
            .antMatchers("/api/user/**").hasRole("USER")  // USER 권한 필요
            .antMatchers("/api/admin/**").hasRole("ADMIN") // ADMIN 권한 필요
            .anyRequest().authenticated();  // 그 외 요청은 인증 필요

        return http.build();
    }
}
```
**설정 설명**<br>
```.antMatchers("/api/public/**").permitAll():```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/public/**```로 시작하는 모든 API는 누구나 접근 가능.

```.antMatchers("/api/user/**").hasRole("USER"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/user/**```로 시작하는 API는 ROLE_USER 권한이 있는 사용자만 접근 가능.

```.antMatchers("/api/admin/**").hasRole("ADMIN"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/admin/**```로 시작하는 API는 ROLE_ADMIN 권한이 있는 사용자만 접근 가능.

```.anyRequest().authenticated():```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;위에서 지정한 경로 외의 모든 요청은 인증된 사용자만 접근 가능.

**주의: hasRole("USER")을 사용할 때 ROLE_ 접두어를 자동으로 붙인다. 따라서 데이터베이스에는 ROLE_USER와 같이 저장해야 한다.**

------------------
### 2. 메서드 수준에서 Role 설정 (@PreAuthorize, @PostAuthorize)
Spring Security에서는 특정 API의 메서드 실행 전에 사용자의 Role을 검사하여 접근을 제한할 수도 있다. 이를 위해 ```@PreAuthorize```와 ```@PostAuthorize```를 사용한다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@PreAuthorize```: 메서드 실행 전에 Role을 검사.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@PostAuthorize```: 메서드 실행 후 반환 값을 기반으로 Role을 검사.

사용 예제
```java
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.access.prepost.PostAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping("/api/user/profile")
    @PreAuthorize("hasRole('USER')")
    public String getUserProfile() {
        return "사용자 프로필 정보";
    }

    @GetMapping("/api/admin/data")
    @PreAuthorize("hasRole('ADMIN')")
    public String getAdminData() {
        return "관리자 전용 데이터";
    }

    @GetMapping("/api/resource")
    @PostAuthorize("returnObject.owner == authentication.name")
    public UserResource getResource(@RequestParam Long id) {
        return new UserResource(id, "ownerUsername");
    }
}
```
**설정 설명**<br>
```@PreAuthorize("hasRole('USER')"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/user/profile``` API는 ROLE_USER 권한이 있는 사용자만 접근 가능.

```@PreAuthorize("hasRole('ADMIN')"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```/api/admin/data``` API는 ROLE_ADMIN 권한이 있는 사용자만 접근 가능.

```@PostAuthorize("returnObject.owner == authentication.name"):```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 실행 후 반환된 객체의 owner 속성이 현재 로그인한 사용자와 일치하는 경우에만 접근 허용.

-------------
### 3. SecurityContext를 활용한 Role 확인
Spring Security에서 인증된 사용자의 정보를 확인하는 방법 중 하나는 SecurityContext를 이용하는 것이다. 현재 로그인한 사용자의 Role을 확인할 수 있으며, 비즈니스 로직에서 Role에 따라 특정 동작을 수행할 수 있다.

SecurityContext를 활용한 Role 확인 예제
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.Collection;

@RestController
public class RoleCheckController {

    @GetMapping("/api/check-role")
    public String checkUserRole() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();

        if (authorities.stream().anyMatch(auth -> auth.getAuthority().equals("ROLE_ADMIN"))) {
            return "관리자 권한이 있습니다.";
        } else if (authorities.stream().anyMatch(auth -> auth.getAuthority().equals("ROLE_USER"))) {
            return "사용자 권한이 있습니다.";
        } else {
            return "권한이 없습니다.";
        }
    }
}
설정 설명
현재 로그인한 사용자의 Authentication 객체를 가져옴.
getAuthorities()를 통해 사용자의 Role 목록을 가져옴.
anyMatch()를 사용하여 ROLE_ADMIN 또는 ROLE_USER 여부를 확인.
Role 기반 접근 제어 적용 흐름
사용자가 로그인을 수행하면, Spring Security는 사용자 정보를 인증.
로그인한 사용자에게 ROLE_USER 또는 ROLE_ADMIN 등의 Role을 부여.
사용자가 API 요청 시:
HTTP 요청 수준의 authorizeHttpRequests()에서 Role 검사.
@PreAuthorize, @PostAuthorize를 통한 메서드 수준 Role 검사.
SecurityContextHolder를 통해 Role을 직접 확인하여 로직 적용.
Role 기반 접근 제어 설정 시 고려할 점
hasRole('USER') vs hasAuthority('ROLE_USER')
hasRole('USER'): 자동으로 ROLE_이 붙음 → 데이터베이스 저장 시 ROLE_USER 필요.
hasAuthority('ROLE_USER'): ROLE_을 직접 지정해야 함.
권한(Role) 계층 구조 설정 가능
예를 들어, ROLE_ADMIN이 ROLE_USER의 모든 권한을 포함하도록 설정할 수도 있음.
Role 변경 및 추가 로직 고려
사용자의 Role 변경이 빈번하다면 동적으로 Role을 변경할 수 있도록 API를 설계하는 것이 중요.
6.3. Security Context를 활용한 사용자 권한 관리
Spring Security는 Security Context를 활용하여 현재 인증된 사용자의 정보를 저장 및 조회할 수 있는 기능을 제공한다. 이를 통해 애플리케이션 내부에서 현재 로그인한 사용자의 권한을 확인하고, 비즈니스 로직에서 이를 기반으로 접근 제어를 수행할 수 있다.

Security Context를 활용하면 로그인한 사용자의 정보를 언제든지 조회할 수 있기 때문에, API 요청이 들어왔을 때 특정 권한을 확인하거나 추가적인 인증 검사를 수행할 수 있다.

Security Context란?
Security Context는 현재 인증된 사용자의 인증 정보를 보관하는 컨테이너 역할을 한다. Spring Security는 사용자가 로그인할 때 SecurityContextHolder를 통해 인증 정보를 저장하고, 이를 활용하여 API 요청이 들어올 때마다 인증 여부를 확인한다.

Security Context는 내부적으로 Authentication 객체를 유지하며, 이 객체를 통해 사용자 정보 및 권한(Role)을 확인할 수 있다.

Security Context에서 인증 정보 확인하기
Spring Security에서 현재 인증된 사용자의 정보를 확인하는 방법은 다음과 같다.

SecurityContextHolder에서 직접 가져오기
컨트롤러에서 인증된 사용자 정보 조회하기
Service 계층에서 사용자 정보 활용하기
1. SecurityContextHolder에서 직접 가져오기
SecurityContextHolder를 이용하면 현재 로그인한 사용자의 정보를 직접 가져올 수 있다.

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

public class SecurityUtil {

    public static String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication != null && authentication.getPrincipal() instanceof org.springframework.security.core.userdetails.User) {
            return authentication.getName(); // 현재 로그인한 사용자의 아이디 반환
        }
        return null;
    }
}
설정 설명
SecurityContextHolder.getContext().getAuthentication()을 호출하여 현재 로그인한 사용자의 인증 정보를 가져온다.
authentication.getName()을 호출하면 사용자의 아이디(username) 를 반환한다.
만약 사용자가 인증되지 않은 상태라면 null을 반환한다.
이제 이 메서드를 활용하여 현재 로그인한 사용자의 아이디를 확인할 수 있다.

String username = SecurityUtil.getCurrentUsername();
System.out.println("현재 로그인한 사용자: " + username);
2. 컨트롤러에서 인증된 사용자 정보 조회하기
Spring Security에서는 @AuthenticationPrincipal을 사용하여 컨트롤러에서 로그인한 사용자 정보를 바로 가져올 수도 있다.

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/user")
public class UserController {

    @GetMapping("/me")
    public String getCurrentUser(@AuthenticationPrincipal User user) {
        return "현재 로그인한 사용자: " + user.getUsername();
    }
}
설정 설명
@AuthenticationPrincipal 어노테이션을 사용하여 현재 로그인한 사용자의 정보를 User 객체로 직접 주입받는다.
user.getUsername()을 호출하여 현재 로그인한 사용자의 아이디를 조회할 수 있다.
이제 /api/user/me 엔드포인트로 요청을 보내면 로그인한 사용자의 정보를 확인할 수 있다.

3. Service 계층에서 사용자 정보 활용하기
Security Context에서 가져온 사용자 정보를 활용하여 비즈니스 로직을 처리할 수도 있다.

예를 들어, 현재 로그인한 사용자가 특정 리소스를 수정할 권한이 있는지 확인하는 로직을 작성할 수 있다.

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    public boolean hasAccessToResource(Long resourceId, String resourceOwner) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication != null && authentication.getPrincipal() instanceof User) {
            String currentUsername = authentication.getName();
            return currentUsername.equals(resourceOwner);
        }
        return false;
    }
}
설정 설명
현재 로그인한 사용자의 username을 가져온 후, 특정 리소스의 소유자(resourceOwner)와 비교하여 권한이 있는지 확인한다.
리소스의 소유자가 현재 로그인한 사용자와 일치하는 경우에만 true를 반환한다.
이제 컨트롤러에서 이 메서드를 활용하여 특정 리소스에 대한 권한 검사를 수행할 수 있다.

@GetMapping("/api/resource/{id}")
public String checkResourceAccess(@PathVariable Long id) {
    String resourceOwner = "exampleUser"; // 예제 데이터
    boolean hasAccess = userService.hasAccessToResource(id, resourceOwner);

    return hasAccess ? "리소스 접근 가능" : "리소스 접근 불가능";
}
Security Context 활용 시 주의할 점
SecurityContextHolder는 스레드마다 별도로 유지됨

Security Context는 스레드 로컬(ThreadLocal) 방식으로 관리되므로, 멀티스레드 환경에서 별도로 관리될 수 있음.
비동기 처리(Async)에서는 SecurityContext를 명시적으로 전달해야 한다.
JWT 기반 인증 시 SecurityContextHolder의 인증 정보 설정 필요

JWT 인증을 사용할 경우, 매 요청마다 SecurityContextHolder에 인증 정보를 직접 설정해야 한다.
예제:
SecurityContextHolder.getContext().setAuthentication(authentication);
OAuth2와 같은 외부 인증 방식에서도 SecurityContext를 활용할 수 있음

OAuth2 기반 인증을 사용할 경우, Security Context에서 OAuth2User를 가져와 사용 가능.
학습자의 사고를 돕기 위한 질문
Spring Security에서 특정 역할(Role)에 따라 접근을 제한하는 가장 일반적인 방법은 무엇인가?

@PreAuthorize, @Secured 애노테이션의 차이를 고려해보라.
JWT 기반 인증 시스템에서 사용자 역할(Role)을 어디에 저장해야 하며, 이를 어떻게 활용할 수 있는가?

JWT의 Payload에 역할 정보를 포함하는 방식을 고려해보라.
실습 문제
문제 1: Role 기반 접근 제어 설정
다음 요구사항을 만족하는 사용자 역할(Role) 기반 보안 설정을 구현하시오.

@PreAuthorize를 사용하여 getAdminData() 메서드는 ROLE_ADMIN만 접근 가능하도록 설정한다.
@Secured("ROLE_USER")을 사용하여 getUserData() 메서드는 ROLE_USER 또는 ROLE_ADMIN만 접근 가능하도록 설정한다.
7. 보안 고려사항 및 추가 설정
7.1. CORS(Cross-Origin Resource Sharing) 설정
CORS(Cross-Origin Resource Sharing)는 웹 브라우저가 보안상의 이유로 다른 도메인(origin)에서 실행 중인 리소스에 대한 요청을 제한하는 정책이다. 이는 동일 출처 정책(Same-Origin Policy) 의 일부로, 보안 위험을 방지하기 위해 도입되었다.

그러나 웹 애플리케이션이 API 서버와 다른 도메인에서 실행되는 경우, 즉 프론트엔드와 백엔드가 서로 다른 도메인에서 통신할 때, 이를 허용해줘야 한다. Spring Boot에서는 CorsFilter 또는 @CrossOrigin 어노테이션을 사용하여 CORS 정책을 설정할 수 있다.

CORS가 필요한 이유
CORS 정책을 적용하지 않으면, 클라이언트에서 다른 도메인으로 요청을 보낼 때 "CORS Policy Error" 가 발생할 수 있다.

예를 들어, 프론트엔드(React.js)가 http://localhost:3000에서 실행 중이고, 백엔드(Spring Boot API 서버)가 http://localhost:8080에서 실행 중이라면, 브라우저는 기본적으로 API 요청을 차단한다.

이를 해결하기 위해 CORS를 허용해야 한다.

Spring Boot에서 CORS 설정하는 방법
Spring Boot에서 CORS를 설정하는 방법은 크게 2가지가 있다.

Global 설정 (Spring Security와 함께 적용)
개별 컨트롤러에서 적용
1. Global CORS 설정 (Spring Security 사용)
Spring Security를 사용하는 경우, CORS 정책을 SecurityFilterChain에 등록해야 한다.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.util.List;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors()  // CORS 활성화
            .and()
            .csrf().disable() // CSRF 비활성화 (JWT 사용 시 필요)
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll() // 공개 API
                .anyRequest().authenticated()
            );

        return http.build();
    }

    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.setAllowedOrigins(List.of("http://localhost:3000")); // 허용할 도메인 지정
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
        config.setAllowedHeaders(List.of("*")); // 모든 헤더 허용
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
설정 설명
http.cors()를 활성화하여 CORS 정책을 적용한다.
CorsFilter 빈(Bean)을 등록하여 특정 도메인에서 API 요청을 허용하도록 설정한다.
setAllowCredentials(true): 쿠키 및 인증 헤더 전송을 허용한다.
setAllowedOrigins(List.of("http://localhost:3000")): 특정 프론트엔드 도메인을 허용한다.
setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE")): 허용할 HTTP 메서드를 지정한다.
2. 개별 컨트롤러에서 CORS 설정하기
특정 컨트롤러에만 CORS 정책을 적용하고 싶다면, @CrossOrigin 어노테이션을 사용할 수 있다.

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
@CrossOrigin(origins = "http://localhost:3000") // 특정 도메인에서만 허용
public class SampleController {

    @GetMapping("/data")
    public String getData() {
        return "CORS가 적용된 데이터 응답";
    }
}
설정 설명
@CrossOrigin(origins = "http://localhost:3000"): 특정 도메인에서의 요청만 허용한다.
이 방식은 전역 설정보다 세부적인 정책을 설정할 때 유용하다.
CORS 설정 시 주의할 점
JWT 기반 인증을 사용할 경우, CORS와 함께 setAllowCredentials(true)를 설정해야 한다.

브라우저에서 Authorization 헤더가 포함된 요청을 보낼 때 필요하다.
Access-Control-Allow-Credentials 헤더가 true일 때, Access-Control-Allow-Origin은 * (와일드카드)를 사용할 수 없다.
개발 환경과 배포 환경에서 다르게 설정해야 한다.

로컬 개발 환경에서는 http://localhost:3000 등 개발 도메인을 허용하지만,
운영 환경에서는 https://myapp.com과 같이 실제 도메인만 허용해야 한다.
Spring Security를 사용하면 반드시 cors()를 활성화해야 한다.

Spring Security의 기본 정책은 CORS를 차단하므로, http.cors()를 명시적으로 추가해야 한다.
학습자의 사고를 돕기 위한 질문
CORS(Cross-Origin Resource Sharing) 정책이 적용되지 않으면 어떤 문제가 발생할 수 있는가?

웹 브라우저의 보안 정책을 고려하여 설명해보라.
Spring Boot에서 CORS 설정을 적용하는 가장 쉬운 방법은 무엇인가?

WebMvcConfigurer를 활용한 설정 방법을 떠올려보라.
실습 문제
문제 1: CORS 설정 적용
다음 요구사항을 만족하는 CORS 설정을 구현하시오.

모든 도메인에서 API를 호출할 수 있도록 허용한다.
GET, POST, PUT, DELETE 요청을 허용한다.
헤더(Authorization, Content-Type)를 포함하여 요청할 수 있도록 설정한다.
7.2. CSRF(Cross-Site Request Forgery) 방어
CSRF(Cross-Site Request Forgery, 크로스 사이트 요청 위조)는 공격자가 사용자의 인증된 세션을 악용하여 의도하지 않은 요청을 서버에 보내도록 유도하는 공격 기법이다. CSRF 공격이 성공하면 사용자가 의도하지 않은 요청을 수행하게 되며, 계정 변경, 결제 요청, 게시물 작성 등의 작업이 악의적으로 실행될 수 있다.

CSRF 공격의 동작 원리
사용자가 웹사이트(A)에 로그인하여 세션이 생성됨.
공격자가 악성 웹사이트(B)에 접근하도록 유도.
B 사이트에 접속하면, 사용자 세션을 이용하여 A 사이트로 요청을 전송.
서버는 요청이 사용자의 실제 요청인지 공격자의 조작인지 구분할 수 없음.
결과적으로 사용자의 세션을 악용하여 원치 않는 동작이 실행됨.
CSRF 공격을 방어하는 방법
CSRF 공격을 방어하는 대표적인 방법은 CSRF 토큰을 활용하는 것이다. CSRF 토큰은 서버에서 발급한 난수값을 클라이언트가 요청 시 함께 전송하도록 강제하는 방식이다.

Spring Security에서는 기본적으로 CSRF 보호 기능이 활성화되어 있다. 하지만 JWT를 사용하는 경우 CSRF 보호 기능을 비활성화하는 것이 일반적이다.

Spring Security에서 CSRF 설정
CSRF 보호를 적용하거나 해제하는 방법은 다음과 같다.

CSRF 보호 활성화 (폼 기반 로그인 시)
CSRF 보호 비활성화 (JWT 기반 인증 시)
1. CSRF 보호 활성화
만약 세션 기반 인증을 사용하는 경우, CSRF 보호 기능을 유지해야 한다. Spring Security는 자동으로 CSRF 토큰을 생성하여 폼 제출 시 포함하도록 한다.

CSRF 보호를 활성화하는 기본적인 방법은 다음과 같다.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().enable() // CSRF 보호 활성화
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/login", "/register").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(); // 기본 로그인 폼 활성화

        return http.build();
    }
}
설정 설명
csrf().enable(): CSRF 보호를 활성화한다.
로그인 폼 기반 인증을 사용할 경우, Spring Security는 자동으로 CSRF 토큰을 생성하고 HTML 폼에 추가한다.
Spring Security는 CSRF 토큰을 X-CSRF-TOKEN 헤더를 통해 전달하도록 요구한다.
2. CSRF 보호 비활성화 (JWT 기반 인증 시)
JWT 기반 인증을 사용하는 경우 서버가 상태를 저장하지 않으므로, CSRF 보호가 필요하지 않다. 따라서 CSRF 설정을 비활성화해야 한다.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable() // CSRF 보호 비활성화
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll() // 공개 API
                .anyRequest().authenticated()
            );

        return http.build();
    }
}
설정 설명
csrf().disable(): JWT 기반 인증에서 CSRF 보호를 비활성화한다.
CSRF 보호를 비활성화해야 하는 이유:
JWT는 HTTP 헤더에 포함되므로 CSRF 공격의 대상이 될 가능성이 낮다.
CSRF는 쿠키 기반 인증을 공격하는 방식이므로, JWT를 사용할 경우 기본적으로 불필요하다.
CSRF 토큰을 사용한 보호 방식
CSRF 보호를 유지하면서 REST API 요청을 처리하고 싶다면, CSRF 토큰을 헤더에 포함하여 전송해야 한다.

클라이언트 측 (JavaScript, React 등)

fetch("/api/protected", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "X-CSRF-TOKEN": getCsrfToken(), // CSRF 토큰 포함
  },
  body: JSON.stringify({ data: "value" }),
})
  .then((response) => response.json())
  .then((data) => console.log(data));
Spring Security에서 CSRF 토큰 설정
Spring Security에서 CsrfTokenRepository를 활용하여 CSRF 토큰을 커스텀하게 설정할 수 있다.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) // 쿠키 기반 CSRF 토큰 사용
            )
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
            );

        return http.build();
    }
}
설정 설명
CookieCsrfTokenRepository.withHttpOnlyFalse()
CSRF 토큰을 쿠키로 저장하고 클라이언트가 이를 읽을 수 있도록 HttpOnly 속성을 비활성화한다.
클라이언트는 쿠키에서 CSRF 토큰을 읽어와 요청 헤더에 포함해야 한다.
JWT 사용 시 CSRF 보호가 필요 없는 이유
JWT는 상태를 저장하지 않는다 → 서버가 세션을 유지하지 않으므로 CSRF 공격 대상이 아님.
쿠키가 필요하지 않다 → JWT는 HTTP 헤더(Authorization)에 포함되므로 브라우저의 쿠키 정책과 무관.
API 요청이 기본적으로 보안 처리가 가능하다 → JWT 기반 인증을 사용할 경우, Bearer Token을 포함한 요청만 인증 가능하도록 설정하면 충분하다.
학습자의 사고를 돕기 위한 질문
CSRF 공격이 발생할 수 있는 상황을 설명하라.

사용자가 로그인된 상태에서 악성 웹사이트를 방문하는 시나리오를 떠올려보라.
JWT 기반 인증 시스템에서 CSRF 보호가 불필요한 이유는 무엇인가?

JWT의 인증 방식과 CSRF 보호의 연관성을 고려하여 설명해보라.
실습 문제
문제 1: CSRF 보호 설정
다음 요구사항을 만족하는 CSRF 보호 설정을 구현하시오.

JWT 기반 인증을 사용할 경우 CSRF 보호를 비활성화한다.
세션 기반 인증을 사용할 경우 CSRF 보호를 활성화한다.
7.3. HTTPS 적용 및 보안 강화
웹 애플리케이션 보안을 강화하는 가장 기본적인 방법 중 하나는 HTTPS(HTTP Secure) 프로토콜을 적용하는 것이다. HTTPS는 HTTP와 다르게 TLS(Transport Layer Security) 또는 SSL(Secure Sockets Layer) 프로토콜을 사용하여 데이터 전송을 암호화한다. 이를 통해 클라이언트와 서버 간의 통신이 중간자 공격(Man-in-the-Middle Attack), 데이터 변조(Tampering), 정보 탈취(Sniffing) 등의 보안 위협으로부터 보호된다.

HTTPS 적용의 필요성
데이터 암호화: HTTPS는 클라이언트와 서버 간의 데이터 전송을 암호화하여 악의적인 사용자가 데이터를 가로채도 내용을 해독할 수 없도록 한다.
데이터 무결성: 중간자 공격을 방지하여 데이터가 전송 중 변경되지 않도록 보호한다.
사용자 신뢰성 확보: HTTPS가 적용된 사이트는 브라우저에서 보안 아이콘(자물쇠 표시)이 나타나며, 사용자에게 신뢰를 줄 수 있다.
검색 엔진 최적화(SEO) 개선: Google 등 검색 엔진은 HTTPS가 적용된 사이트를 우선적으로 노출하는 경향이 있다.
API 보안 강화: RESTful API를 HTTPS로 보호하면, 클라이언트와 서버 간의 요청 및 응답 데이터가 보호된다.
Spring Boot에서 HTTPS 적용하기
Spring Boot 애플리케이션에서 HTTPS를 활성화하려면, 다음과 같은 설정을 진행해야 한다.

SSL 인증서 준비: HTTPS를 사용하려면 SSL 인증서가 필요하다. 보통 Let’s Encrypt(무료), DigiCert, GlobalSign 등의 인증 기관(CA)에서 발급받을 수 있다.
Spring Boot 설정 파일 수정: HTTPS를 활성화하려면 application.properties 또는 application.yml에 SSL 관련 설정을 추가해야 한다.
서버 포트 변경: 기본 HTTP(80 또는 8080) 대신 HTTPS(443 또는 8443) 포트를 사용하도록 변경해야 한다.
1. HTTPS를 위한 SSL 인증서 준비
HTTPS를 활성화하려면 SSL 인증서가 필요하다. 직접 인증서를 생성할 수도 있으며, 상용 서비스를 이용할 수도 있다.

KeyStore를 이용하여 인증서 생성

keytool -genkey -alias myssl -keyalg RSA -keystore keystore.p12 -storetype PKCS12 -validity 365 -keysize 2048
위 명령어는 RSA 알고리즘을 사용하여 PKCS12 형식의 인증서를 생성하며, 유효기간은 365일이다.

2. application.properties 또는 application.yml 설정
Spring Boot에서 HTTPS를 활성화하려면, server.ssl.* 속성을 설정해야 한다.

application.properties

server.port=8443
server.ssl.enabled=true
server.ssl.key-store=classpath:keystore.p12
server.ssl.key-store-password=changeit
server.ssl.key-store-type=PKCS12
server.ssl.key-alias=myssl
설정 설명

server.port=8443: HTTPS 기본 포트인 8443을 사용한다.
server.ssl.enabled=true: HTTPS를 활성화한다.
server.ssl.key-store=classpath:keystore.p12: SSL 인증서 파일 경로를 설정한다.
server.ssl.key-store-password=changeit: SSL 인증서의 비밀번호를 설정한다.
server.ssl.key-store-type=PKCS12: 사용되는 키스토어 유형을 지정한다.
server.ssl.key-alias=myssl: 사용할 인증서의 alias를 지정한다.
3. HTTP 요청을 HTTPS로 리다이렉트
기존 HTTP(포트 8080 또는 80)를 HTTPS(포트 8443)로 자동 리다이렉트하려면, Spring Security 설정을 추가해야 한다.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.embedded.tomcat.ConfigurableTomcatWebServerFactory;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .requiresChannel(channel ->
                channel.anyRequest().requiresSecure()) // 모든 요청을 HTTPS로 강제
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll() // 공개 API
                .anyRequest().authenticated()
            );

        return http.build();
    }

    // HTTP를 HTTPS로 자동 리다이렉트
    @Bean
    public WebServerFactoryCustomizer<ConfigurableTomcatWebServerFactory> tomcatRedirect() {
        return factory -> factory.addAdditionalTomcatConnectors(httpToHttpsRedirectConnector());
    }

    private static org.apache.catalina.connector.Connector httpToHttpsRedirectConnector() {
        org.apache.catalina.connector.Connector connector =
            new org.apache.catalina.connector.Connector(org.apache.coyote.http11.Http11NioProtocol.class.getName());
        connector.setScheme("http");
        connector.setPort(8080); // HTTP 요청 포트
        connector.setSecure(false);
        connector.setRedirectPort(8443); // HTTPS로 리다이렉트
        return connector;
    }
}
설정 설명

requiresChannel().anyRequest().requiresSecure(): 모든 요청을 HTTPS로 강제한다.
requestMatchers("/public/**").permitAll(): /public/** 경로는 보안 없이 접근 가능하도록 설정한다.
httpToHttpsRedirectConnector(): HTTP(8080)로 들어오는 요청을 HTTPS(8443)로 리다이렉트한다.
4. HTTPS 적용 후 보안 강화
HSTS(HTTP Strict Transport Security) 적용: HSTS는 HTTPS를 강제하는 보안 정책이다.
TLS 최신 버전 사용: 가능하면 TLS 1.2 이상을 사용하고, SSL 3.0이나 TLS 1.0은 비활성화한다.
보안 헤더 설정: 추가적인 보안을 위해 응답 헤더를 설정할 수 있다.
http
    .headers(headers -> headers
        .httpStrictTransportSecurity(hsts -> hsts
            .includeSubDomains(true)
            .maxAgeInSeconds(31536000) // 1년간 HTTPS 강제
        )
    );
CSP(Content Security Policy) 적용: 악성 스크립트 실행을 방지한다.
HTTPS 사용 시 고려할 사항
HTTPS 적용 시 성능 문제

암호화 및 복호화 과정이 추가되므로, 트래픽이 많을 경우 성능 저하가 발생할 수 있다.
HTTP/2 및 Keep-Alive 옵션을 활성화하여 성능을 개선할 수 있다.
인증서 갱신 및 관리

Let’s Encrypt를 사용하면 자동으로 인증서를 갱신할 수 있다.
인증서 만료 시 서비스가 중단될 수 있으므로, 모니터링 및 갱신 주기를 관리해야 한다.
클라이언트와의 호환성

일부 오래된 브라우저 및 운영체제에서는 최신 TLS 프로토콜을 지원하지 않을 수 있다.
TLS 1.2 이상을 사용하면서, 필요한 경우 낮은 버전의 TLS를 부분적으로 지원할 수도 있다.
학습자의 사고를 돕기 위한 질문
HTTPS를 적용하지 않은 웹 애플리케이션에서 발생할 수 있는 보안 문제는 무엇인가?

네트워크 패킷 감청과 중간자 공격(Man-in-the-Middle Attack)을 고려해보라.
JWT를 HTTPS 없이 사용할 경우 발생할 수 있는 위험은 무엇인가?

토큰 탈취 및 재사용 공격을 생각해보라.
실습 문제
문제 1: HTTPS 적용 설정
다음 요구사항을 만족하는 HTTPS 설정을 구현하시오.

Spring Boot에서 HTTPS를 활성화한다.
application.properties 또는 application.yml을 사용하여 HTTPS 포트를 지정한다.
8. 인증과 보안 적용 시 유의할 점
8.1. JWT 보안 강화 방법
JWT(Json Web Token)는 인증과 권한 부여에서 널리 사용되는 방식이지만, 몇 가지 보안 취약점을 내포하고 있다. 따라서 안전한 JWT 사용을 위해 적절한 보안 강화 방법이 필요하다. JWT 보안 강화를 위해 고려해야 할 사항들을 정리하면 다음과 같다.

1. 토큰의 만료 시간 설정 및 갱신 전략
JWT는 기본적으로 Stateless 방식이므로, 토큰이 유효한 동안 서버 측에서 상태를 저장하지 않는다. 하지만, 토큰이 무제한으로 유효할 경우 토큰 탈취(Replay Attack) 같은 보안 문제가 발생할 수 있다.

Access Token은 짧은 만료 시간을 설정해야 한다. 일반적으로 15분~1시간이 적절하다.
Refresh Token은 상대적으로 긴 만료 시간을 설정해야 한다. 일반적으로 7일~30일로 설정한다.
만료된 Access Token을 갱신하기 위해 Refresh Token을 사용한다.
토큰의 만료 시간을 설정하는 예제

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import java.util.Date;

public class JwtUtil {
    private static final String SECRET_KEY = "mySecretKey"; // 보안 강화를 위해 환경 변수로 설정
    private static final long ACCESS_TOKEN_EXPIRATION = 15 * 60 * 1000; // 15분
    private static final long REFRESH_TOKEN_EXPIRATION = 7 * 24 * 60 * 60 * 1000; // 7일

    public static String generateAccessToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + ACCESS_TOKEN_EXPIRATION))
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }

    public static String generateRefreshToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + REFRESH_TOKEN_EXPIRATION))
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }
}
설정 설명

setExpiration()을 이용해 토큰의 만료 시간을 설정한다.
Access Token은 15분으로 설정해 짧게 유지하며, Refresh Token은 7일로 설정해 비교적 길게 유지한다.
2. Refresh Token을 이용한 인증 유지 방식
Access Token이 만료될 경우, 사용자는 새롭게 로그인하지 않고 Refresh Token을 이용해 새로운 Access Token을 발급받을 수 있다.

Refresh Token 사용 시 유의할 점:

Refresh Token은 반드시 서버에 저장해야 한다. (DB 또는 Redis 사용)
Refresh Token은 Access Token보다 길게 유지하지만, 영구적이지 않아야 한다.
Refresh Token도 탈취될 수 있으므로 저장소에 안전하게 보관해야 한다.
Refresh Token 재사용 공격을 방지하기 위해 사용 시 새로운 Refresh Token을 발급한다.
Refresh Token을 이용한 인증 흐름

사용자가 로그인하면 Access Token과 Refresh Token을 발급받는다.
Access Token이 만료되면 클라이언트는 Refresh Token을 사용해 새로운 Access Token을 요청한다.
서버는 Refresh Token을 검증한 후 새 Access Token을 발급한다.
새로운 Refresh Token도 함께 갱신하고, 기존 Refresh Token을 폐기한다.
Refresh Token을 검증하고 새로운 Access Token을 발급하는 API 예제

@RestController
@RequestMapping("/auth")
public class AuthController {

    @Autowired
    private TokenService tokenService;

    @PostMapping("/refresh")
    public ResponseEntity<?> refreshAccessToken(@RequestBody Map<String, String> request) {
        String refreshToken = request.get("refreshToken");
        if (refreshToken == null || !tokenService.validateRefreshToken(refreshToken)) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid refresh token");
        }

        String newAccessToken = tokenService.generateAccessToken(tokenService.extractUsername(refreshToken));
        String newRefreshToken = tokenService.generateRefreshToken(tokenService.extractUsername(refreshToken));

        return ResponseEntity.ok(Map.of("accessToken", newAccessToken, "refreshToken", newRefreshToken));
    }
}
설정 설명

Refresh Token이 유효한지 확인한 후 새로운 Access Token을 생성한다.
Refresh Token을 재사용하는 공격을 방지하기 위해 Refresh Token도 새롭게 발급한다.
3. JWT 서명(Signature) 보안 강화
JWT의 Signature는 변조를 방지하는 중요한 역할을 하므로, 보안 강화를 위해 강력한 서명 알고리즘과 비밀 키 관리 전략이 필요하다.

서명 알고리즘 선택

HS256(HMAC with SHA-256) → 일반적으로 사용되지만, 비밀 키가 노출될 경우 취약함.
RS256(RSA with SHA-256) → 공개 키/개인 키 방식을 사용하여 보안성이 높음.
ES256(ECDSA with SHA-256) → 보안성이 가장 높지만, 성능 오버헤드가 있음.
비밀 키를 안전하게 관리

환경 변수 또는 AWS Secrets Manager, HashiCorp Vault 같은 보안 저장소를 이용해 관리해야 한다.
소스 코드 내에 비밀 키를 직접 노출하지 않아야 한다.
RS256 알고리즘을 사용한 JWT 생성 예제

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.util.Date;

public class JwtUtil {
    private static PrivateKey privateKey;

    static {
        try {
            KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
            keyPairGen.initialize(2048);
            KeyPair keyPair = keyPairGen.generateKeyPair();
            privateKey = keyPair.getPrivate();
        } catch (Exception e) {
            throw new RuntimeException("Error initializing keys");
        }
    }

    public static String generateJwt(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 15 * 60 * 1000)) // 15분
                .signWith(SignatureAlgorithm.RS256, privateKey)
                .compact();
    }
}
설정 설명

RSA 키 쌍을 생성하여, 개인 키로 JWT를 서명한다.
공개 키를 이용하여 클라이언트에서 검증할 수도 있다.
4. JWT 보관 위치 보안
JWT는 클라이언트에서 보관해야 하는데, 보관 방식에 따라 보안이 달라진다.

보관 방법	장점	단점
로컬 스토리지(LocalStorage)	사용이 간편하고 세션이 만료되지 않음	XSS(Cross-Site Scripting) 공격에 취약
세션 스토리지(SessionStorage)	XSS 공격에 일부 보호됨	세션이 닫히면 토큰이 삭제됨
HTTP-Only Secure 쿠키	XSS 및 CSRF 공격에 강함	일부 브라우저에서 제약이 있을 수 있음
가장 안전한 방식

JWT는 HTTP-Only Secure 쿠키에 저장하는 것이 가장 안전하다.
클라이언트에서 localStorage에 저장하는 것은 XSS 공격에 매우 취약하므로 지양해야 한다.
실습 문제
문제 1: JWT 토큰 보안 강화
다음 요구사항을 만족하는 JWT 보안 강화를 구현하시오.

Refresh Token을 도입하여 Access Token이 만료되었을 때 재발급할 수 있도록 한다.
Refresh Token을 데이터베이스에 저장하고 일정 시간이 지나면 폐기하도록 설정한다.
8.2. Spring Security 설정 시 주의할 점
Spring Security는 강력한 보안 기능을 제공하지만, 설정을 잘못하면 인증 및 인가 과정에서 심각한 보안 문제가 발생할 수 있다. 따라서 Spring Security 설정 시 몇 가지 주의해야 할 사항을 정리하여 안정적인 보안 환경을 구축해야 한다.

1. 공개 API와 보호된 API를 명확하게 구분하기
Spring Security를 사용할 때, 보호해야 할 API와 공개해야 할 API를 명확하게 구분하는 것이 중요하다. 모든 API를 인증이 필요한 상태로 설정하면 프론트엔드에서 정상적인 요청도 차단될 수 있으며, 반대로 인증이 필요 없는 상태로 설정하면 보안 취약점이 발생할 수 있다.

API 접근 제어를 명확하게 설정하는 예제

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()  // 공개 API
                .requestMatchers("/admin/**").hasRole("ADMIN") // 관리자 전용 API
                .requestMatchers("/user/**").hasRole("USER") // 일반 사용자 전용 API
                .anyRequest().authenticated() // 그 외 모든 요청은 인증 필요
            )
            .formLogin(withDefaults()) // 기본 로그인 설정
            .httpBasic(withDefaults()); // HTTP 기본 인증 활성화

        return http.build();
    }
}
설정 설명

/public/** 경로는 누구나 접근 가능하도록 permitAll() 설정.
/admin/**은 관리자(ROLE_ADMIN)만 접근 가능하도록 설정.
/user/**는 일반 사용자(ROLE_USER)만 접근 가능하도록 설정.
그 외 모든 API는 인증된 사용자만 접근할 수 있도록 anyRequest().authenticated() 설정.
주의해야 할 점

API별 접근 제어 규칙을 명확히 지정하지 않으면, 보안이 취약한 경로가 생길 수 있다.
permitAll()을 남용하지 않도록 주의해야 한다. 예를 들어, permitAll()이 포함된 API에서 중요한 데이터를 반환하면 보안이 무너질 수 있다.
2. 필터 체인(Filter Chain) 설정 순서의 중요성
Spring Security에서 필터 체인의 순서는 인증 및 보안 정책 적용에 매우 중요한 역할을 한다. 필터 체인의 순서를 잘못 지정하면 의도한 대로 보안이 적용되지 않거나 인증 과정이 정상적으로 수행되지 않을 수 있다.

올바른 필터 체인 설정 예제

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // CSRF 보호 비활성화 (JWT 사용 시 필요)
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // 세션을 사용하지 않는 Stateless 방식
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(new JwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class) // JWT 인증 필터 적용
            .formLogin(withDefaults());

        return http.build();
    }
}
설정 설명

addFilterBefore(new JwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)를 사용하여 JWT 필터를 기본 로그인 필터보다 먼저 실행하도록 설정.
SessionCreationPolicy.STATELESS를 사용하여 Spring Security가 세션을 생성하지 않도록 설정(JWT 방식에서는 Stateless가 필요).
csrf.disable()을 사용하여 JWT 기반 인증에서 CSRF 보호를 비활성화(이유: CSRF는 세션을 사용하는 경우에 필요).
필터 순서 설정이 중요한 이유

필터가 실행되는 순서가 잘못되면, UsernamePasswordAuthenticationFilter가 먼저 실행되어 JWT 필터가 작동하지 않거나 인증이 되지 않는 문제가 발생할 수 있다.
addFilterBefore()와 addFilterAfter()를 적절히 활용하여 인증 필터의 실행 순서를 조정해야 한다.
3. 패스워드 인코딩을 반드시 적용하기
사용자 패스워드는 반드시 암호화(Encoding) 하여 저장해야 한다. 일반 텍스트(Plain Text)로 저장하면 데이터베이스가 유출될 경우 심각한 보안 문제가 발생할 수 있다.

Spring Security에서 패스워드 암호화 적용 예제

@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

@Bean
public UserDetailsService userDetailsService(PasswordEncoder passwordEncoder) {
    UserDetails user = User.withUsername("user")
            .password(passwordEncoder.encode("password")) // 비밀번호 암호화 저장
            .roles("USER")
            .build();

    return new InMemoryUserDetailsManager(user);
}
설정 설명

BCryptPasswordEncoder를 사용하여 패스워드를 단방향 암호화한다.
비밀번호를 encode() 메서드를 통해 암호화한 후 저장한다.
주의해야 할 점

평문(Plain Text) 비밀번호를 직접 저장하면 안 된다.
BCryptPasswordEncoder는 랜덤 솔트를 포함하여 보안성을 높인다. 따라서 같은 비밀번호라도 저장할 때마다 다른 값이 생성된다.
데이터베이스에서 사용자의 비밀번호를 조회할 때도 반드시 matches() 메서드를 사용하여 비교해야 한다.
if (passwordEncoder.matches(rawPassword, encodedPassword)) {
    System.out.println("비밀번호 일치");
}
4. CORS 정책을 정확히 설정하기
CORS(Cross-Origin Resource Sharing)는 다른 도메인에서 API 요청을 보낼 때 보안 정책을 설정하는 기능이다. 설정을 잘못하면, 클라이언트에서 API 요청이 차단될 수 있다.

Spring Security에서 CORS 설정 예제

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> cors.configurationSource(request -> {
                CorsConfiguration config = new CorsConfiguration();
                config.setAllowedOrigins(List.of("https://trusted-client.com")); // 허용할 출처
                config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
                config.setAllowCredentials(true);
                config.setAllowedHeaders(List.of("Authorization", "Content-Type"));
                return config;
            }))
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            );

        return http.build();
    }
}
설정 설명

setAllowedOrigins()를 사용하여 특정 도메인만 허용(모든 도메인을 허용하지 않도록 한다).
setAllowedMethods()를 사용하여 허용할 HTTP 메서드를 지정.
setAllowCredentials(true)를 설정하여 쿠키 및 인증 헤더를 포함할 수 있도록 한다.
setAllowedHeaders()를 설정하여 특정 요청 헤더만 허용.
주의해야 할 점

CORS 정책을 잘못 설정하면, 브라우저에서 API 요청이 차단될 수 있다.
setAllowedOrigins("*")을 사용하여 모든 출처를 허용하는 것은 보안상 위험하므로 피해야 한다.
클라이언트 도메인을 정확히 지정하여 허용하는 것이 바람직하다.
8.3. 인증과 인가를 적용할 때의 실무적 고려사항
Spring Security와 JWT 기반 인증을 적용할 때는 단순히 기능 구현만 중요한 것이 아니라 실무에서 발생할 수 있는 문제점과 해결 방안을 고려하는 것이 필수적이다. 특히 대규모 서비스에서의 인증 구조 설계, 보안 및 확장성을 고려한 인증 정보 저장 방식 등 여러 요소를 신중하게 검토해야 한다.

1. 대규모 서비스에서의 인증 구조 설계
대규모 서비스에서 인증 시스템을 구축할 때 가장 중요한 것은 부하 분산(Scalability)과 보안 유지(Security) 이다. 단순한 인증 방식(예: 세션 기반 인증)은 한 서버에서만 동작하기 때문에, 다수의 서버가 존재하는 환경에서는 세션 동기화 문제가 발생할 수 있다.

세션 기반 인증의 문제점

서버 확장 시 인증 상태 동기화 필요: 사용자가 로그인한 상태를 모든 서버가 공유해야 한다.
로드 밸런서를 사용할 경우 세션 유지 문제 발생: 세션이 특정 서버에 저장되면, 이후의 요청이 다른 서버로 전달될 경우 인증이 풀릴 수 있다.
해결책: JWT 및 Stateless 인증 도입

JWT 사용: JWT는 자체적으로 인증 정보를 포함하고 있어 서버에 세션을 저장할 필요가 없다.
Stateless 방식: 서버 확장 시 인증 상태를 공유하지 않아도 되므로, 수평 확장(Scaling Out) 이 용이하다.
JWT 기반 인증 구조

[클라이언트] → JWT 포함 요청 → [API 서버] → JWT 검증 → [인증 완료]
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
                                    throws ServletException, IOException {
        String token = resolveToken(request);

        if (token != null && validateToken(token)) {
            Authentication auth = getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(auth);
        }

        filterChain.doFilter(request, response);
    }
}
장점

인증 상태를 서버가 관리할 필요 없이 클라이언트가 JWT를 포함하여 요청하기만 하면 된다.
로드 밸런서와 무관하게 서버 확장 가능(각 서버에서 JWT를 검증할 수 있음).
클라이언트가 JWT를 활용하여 다른 서비스와도 연동할 수 있다.
2. 인증 정보 저장 방식 및 확장성 고려
JWT 기반 인증을 적용할 때는 어떤 정보를 어디에 저장할 것인지가 중요하다. 특히 보안 및 확장성을 고려할 때 다음과 같은 요소들을 고려해야 한다.

(1) 액세스 토큰과 리프레시 토큰을 분리하여 사용 JWT 기반 인증에서는 액세스 토큰(Access Token)과 리프레시 토큰(Refresh Token)을 분리하는 방식이 일반적이다.

Access Token: 짧은 유효 기간을 가지며, API 요청 시 포함되는 토큰.
Refresh Token: 상대적으로 긴 유효 기간을 가지며, Access Token이 만료될 경우 새로운 Access Token을 발급하는 데 사용됨.
public class TokenProvider {
    public String generateAccessToken(Authentication authentication) {
        return Jwts.builder()
                .setSubject(authentication.getName())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 15)) // 15분 유효
                .signWith(SignatureAlgorithm.HS512, SECRET_KEY)
                .compact();
    }

    public String generateRefreshToken(Authentication authentication) {
        return Jwts.builder()
                .setSubject(authentication.getName())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24 * 7)) // 7일 유효
                .signWith(SignatureAlgorithm.HS512, SECRET_KEY)
                .compact();
    }
}
(2) Refresh Token을 안전하게 저장하는 방법 Refresh Token을 클라이언트 측(브라우저 로컬스토리지 등)에 저장하면 보안 문제가 발생할 수 있다. 따라서 서버 측에 저장하는 방식이 바람직하다.

안전한 저장 방법:
Redis에 Refresh Token을 저장하여 빠른 조회가 가능하도록 한다.
데이터베이스(DB)에 암호화된 상태로 저장하여 보안성을 높인다.
Redis를 활용한 Refresh Token 저장 예제

@Component
public class RefreshTokenService {
    private final RedisTemplate<String, String> redisTemplate;

    public void saveRefreshToken(String username, String refreshToken) {
        redisTemplate.opsForValue().set(username, refreshToken, 7, TimeUnit.DAYS);
    }

    public boolean validateRefreshToken(String username, String refreshToken) {
        String storedToken = redisTemplate.opsForValue().get(username);
        return storedToken != null && storedToken.equals(refreshToken);
    }
}
(3) Access Token을 HTTP 헤더에 포함하여 전송

JWT는 기본적으로 Authorization 헤더에 포함하여 전송하는 방식이 일반적이다.
헤더를 통해 전달하면, XSS 공격을 방지할 수 있다.
http
    .authorizeHttpRequests(auth -> auth
        .requestMatchers("/api/public").permitAll()
        .anyRequest().authenticated()
    )
    .addFilterBefore(new JwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
3. 보안성을 높이기 위한 추가 고려사항
JWT 기반 인증 시스템을 적용할 때 추가적인 보안 강화 기법을 고려해야 한다.

1) JWT 서명(Signature) 강화 JWT의 Signature는 서명 알고리즘을 선택하여 보호할 수 있다. HMAC-SHA512 또는 RSA 서명을 사용하는 것이 일반적이다.

Jwts.builder()
    .setSubject("user")
    .signWith(SignatureAlgorithm.HS512, SECRET_KEY) // 강력한 해싱 알고리즘 사용
    .compact();
2) 토큰 탈취 방지를 위한 HTTPS 적용 JWT는 토큰이 노출되면 누구나 사용할 수 있기 때문에, 반드시 HTTPS를 적용하여 통신을 암호화해야 한다.

3) 사용하지 않는 토큰을 즉시 폐기 로그아웃 시 기존 Refresh Token을 폐기하고 새로 로그인할 때만 사용할 수 있도록 한다.

public void revokeRefreshToken(String username) {
    redisTemplate.delete(username);
}
4) 동시 로그인 방지

동일 계정으로 여러 기기에서 로그인하지 못하도록 설정할 수 있다.
이를 위해 로그인 시마다 Refresh Token을 업데이트하는 방식이 효과적이다.
5) JWT 클레임(Claim) 최소화

JWT에는 불필요한 정보를 담지 않고, 최소한의 정보만 포함해야 한다.
예를 들어, 사용자 역할(role)이나 기본적인 사용자 ID만 담는 것이 바람직하다.
연습 문제
문제 1: Spring Security 기본 설정
다음 요구사항을 만족하는 Spring Security 설정 클래스를 작성하시오.

SecurityConfig 클래스를 생성한다.
@EnableWebSecurity와 @Configuration 애노테이션을 활용하여 보안 설정을 적용한다.
모든 요청을 인증하도록 설정하되, /public 엔드포인트는 인증 없이 접근 가능하도록 한다.
기본 로그인 폼을 활성화한다.
로그인 성공 시 사용자를 /home으로 리디렉트하도록 설정한다.
문제 2: In-Memory 사용자 인증 설정
다음 요구사항을 만족하는 In-Memory 인증 설정을 구현하시오.

UserDetailsService를 구현하여 In-Memory 방식으로 사용자 정보를 저장한다.

아래의 사용자 정보를 추가한다.

사용자명	비밀번호	역할
admin	admin123	ROLE_ADMIN
user	user123	ROLE_USER
BCryptPasswordEncoder를 사용하여 비밀번호를 암호화한 후 저장한다.

Spring Security 설정을 통해 인증이 필요하도록 구성한다.

문제 3: Database 연동을 통한 사용자 인증
다음 요구사항을 만족하는 Spring Security 사용자 인증 설정을 구현하시오.

H2 또는 MySQL을 이용하여 사용자 정보를 저장한다.

아래와 같은 테이블을 생성하고 데이터를 저장한다.

ID	사용자명	비밀번호	역할
1	admin	(암호화)	ROLE_ADMIN
2	user	(암호화)	ROLE_USER
사용자 정보를 조회하는 UserDetailsService를 구현하여 데이터베이스에서 사용자 정보를 가져오도록 설정한다.

BCryptPasswordEncoder를 이용하여 비밀번호를 암호화하고 저장한다.

문제 4: JWT 토큰 생성 및 서명
다음 요구사항을 만족하는 JWT 발급 클래스를 구현하시오.

JwtTokenProvider 클래스를 생성한다.
사용자명을 포함한 JWT를 생성하는 generateToken(String username) 메서드를 구현한다.
JWT의 만료 시간을 1시간으로 설정한다.
JWT의 서명(Signature)에는 HMAC SHA256 알고리즘을 사용한다.
문제 5: JWT 인증 필터 구현
다음 요구사항을 만족하는 JWT 인증 필터를 구현하시오.

OncePerRequestFilter를 상속하는 JwtAuthenticationFilter 클래스를 작성한다.
HTTP 요청의 Authorization 헤더에서 JWT를 추출하는 메서드를 작성한다.
토큰을 검증하고 검증된 사용자의 정보를 SecurityContext에 저장하는 로직을 구현한다.
인증되지 않은 요청의 경우 403 상태 코드(Forbidden)를 반환하도록 한다.
문제 6: 특정 API 보호 설정
다음 요구사항을 만족하는 Spring Security 설정을 구현하시오.

/admin 엔드포인트는 ROLE_ADMIN 권한을 가진 사용자만 접근할 수 있도록 설정한다.
/user 엔드포인트는 ROLE_USER 또는 ROLE_ADMIN 권한을 가진 사용자만 접근할 수 있도록 설정한다.
인증되지 않은 사용자는 로그인 페이지로 리디렉트되도록 설정한다.
Spring Security의 http.authorizeRequests()를 사용하여 위의 정책을 적용한다.
문제 7: Role 기반 접근 제어
다음 요구사항을 만족하는 사용자 역할(Role) 기반 보안 설정을 구현하시오.

@PreAuthorize("hasRole('ADMIN')")를 사용하여 getAdminData() 메서드는 ROLE_ADMIN만 접근 가능하도록 설정한다.
@Secured("ROLE_USER")을 사용하여 getUserData() 메서드는 ROLE_USER 또는 ROLE_ADMIN만 접근 가능하도록 설정한다.
인증되지 않은 사용자가 접근할 경우 403 상태 코드(Forbidden)를 반환하도록 한다.
문제 8: CORS 설정 적용
다음 요구사항을 만족하는 CORS 설정을 구현하시오.

모든 도메인에서 API를 호출할 수 있도록 허용한다.
GET, POST, PUT, DELETE 요청을 허용한다.
허용된 헤더(Authorization, Content-Type)를 지정하여 요청할 수 있도록 설정한다.
Spring Boot의 WebMvcConfigurer를 사용하여 CORS 설정을 적용한다.
문제 9: CSRF 보호 설정
다음 요구사항을 만족하는 CSRF 보호 설정을 구현하시오.

JWT 기반 인증을 사용할 경우 CSRF 보호를 비활성화한다.
세션 기반 인증을 사용할 경우 CSRF 보호를 활성화한다.
http.csrf().disable()을 활용하여 특정 요청에 대해 CSRF 보호를 비활성화한다.
CSRFTokenRepository를 활용하여 CSRF 토큰을 저장하고 검증하는 설정을 추가한다.
문제 10: HTTPS 활성화
다음 요구사항을 만족하는 HTTPS 설정을 구현하시오.

Spring Boot에서 HTTPS를 활성화한다.
application.properties 또는 application.yml을 사용하여 HTTPS 포트를 8443으로 지정한다.
server.ssl.key-store, server.ssl.key-store-password 등의 설정을 추가하여 HTTPS 적용이 가능하도록 한다.
HTTP 요청이 들어오면 자동으로 HTTPS로 리디렉트되도록 설정한다.
답안
1. 인증과 인가의 개념
1.1 인증(Authentication)과 인가(Authorization)의 차이
1.1.1 질문에 대한 답안
사용자가 로그인했을 때 이를 "인증"이라고 할 수 있는 이유는 무엇인가?

로그인 과정에서 사용자의 신원을 확인하는 단계이기 때문이다. 사용자가 제공한 자격 증명(예: 아이디와 비밀번호)이 올바른지 확인하여 신뢰할 수 있는 사용자인지를 판단한다.
로그인한 사용자가 특정 관리자 페이지에 접근하지 못하도록 하는 것은 "인가"라고 할 수 있는가?

그렇다. 인증을 통과한 사용자가 모든 자원에 접근할 수 있는 것은 아니므로, 특정 권한을 가진 사용자만 접근하도록 제어하는 과정이 필요하다. 이를 "인가(Authorization)"라고 한다.
1.2 인증 방식의 비교
1.2.1 질문에 대한 답안
세션 기반 인증(Session-based Authentication)과 토큰 기반 인증(Token-based Authentication)의 주요 차이는 무엇인가?

세션 기반 인증은 서버가 사용자의 로그인 상태를 유지하며, 사용자 정보가 세션에 저장된다. 반면, 토큰 기반 인증은 클라이언트가 JWT 등의 토큰을 발급받아 요청마다 포함하여 인증을 수행하며, 서버가 별도로 세션을 유지하지 않는다.
세션 기반 인증이 여러 개의 서버에서 관리될 때 발생할 수 있는 문제는 무엇인가?

분산 환경에서는 세션을 여러 서버 간에 공유해야 하는데, 이를 위해 별도의 세션 저장소(예: Redis)가 필요하다. 또한, 서버 간 동기화가 필요하여 시스템 복잡성이 증가할 수 있다.
2. Spring Security 개요
2.1 Spring Security란?
2.1.1 질문에 대한 답안
Spring Security는 어떻게 애플리케이션의 보안을 강화하는가?

Spring Security는 인증(Authentication)과 인가(Authorization)를 제공하며, CSRF 보호, CORS 설정, 보안 필터 체인 등을 통해 애플리케이션을 보호한다.
Spring Security를 사용하면 직접 인증 로직을 구현할 필요가 없는 이유는 무엇인가?

Spring Security는 다양한 인증 방법을 지원하는 내장 기능을 제공하며, 이를 쉽게 설정하여 사용할 수 있다. 또한, UserDetailsService를 통해 사용자 정보를 로드하는 기능도 내장되어 있다.
2.2 Spring Security의 주요 기능
2.2.1 질문에 대한 답안
Spring Security에서 AuthenticationManager는 어떤 역할을 하는가?

AuthenticationManager는 사용자의 로그인 요청을 처리하고 인증이 성공했는지를 확인하는 역할을 한다. 인증이 완료되면 SecurityContext에 사용자 정보를 저장한다.
Spring Security의 SecurityContext는 무엇을 저장하며 어떤 역할을 하는가?

SecurityContext는 현재 인증된 사용자의 정보를 저장하며, 요청이 처리되는 동안 인증 상태를 유지하는 역할을 한다.
3. Spring Security 설정 및 인증 구현
3.1 Spring Security 설정 기본
3.1.1 실습 문제에 대한 답안
문제 1: Spring Security 기본 설정

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(withDefaults());
        return http.build();
    }
}
문제 2: 기본 로그인 설정

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin").hasRole("ADMIN")
                .requestMatchers("/user").hasAnyRole("USER", "ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(withDefaults());
        return http.build();
    }
}
3.2 사용자 인증 구현
3.2.1 실습 문제에 대한 답안
문제 1: In-Memory 사용자 인증 설정

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.withDefaultPasswordEncoder()
                .username("admin")
                .password("admin123")
                .roles("ADMIN")
                .build();

        UserDetails user = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user123")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, user);
    }
}
문제 2: Database 연동을 통한 사용자 인증

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String password;
    private String role;
}
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
@Service
public class CustomUserDetailsService implements UserDetailsService {
    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        return User.withUsername(user.getUsername())
                .password(user.getPassword())
                .roles(user.getRole())
                .build();
    }
}
4. JWT(Json Web Token) 개념과 활용
4.1 JWT의 개념과 필요성
4.1.1 질문에 대한 답안
JWT(Json Web Token) 기반 인증이 세션 기반 인증과 비교하여 가지는 장점은 무엇인가?

서버에서 별도의 세션을 유지할 필요 없이 클라이언트가 자체적으로 인증 정보를 저장하고 요청 시 포함하여 전송할 수 있다.
JWT를 사용할 때 고려해야 할 보안 취약점은 무엇인가?

토큰이 탈취되면 악용될 가능성이 있으며, 이를 방지하기 위해 HTTPS를 사용하고 토큰 만료 시간을 적절히 설정해야 한다.
4.2 JWT의 구조
4.2.1 질문에 대한 답안
JWT의 주요 구성 요소는 무엇이며, 각각 어떤 역할을 수행하는가?

Header: 토큰의 타입과 서명 알고리즘을 포함한다.
Payload: 사용자 정보 및 기타 클레임(Claim)을 저장한다.
Signature: 토큰의 무결성을 보장하기 위해 서명된 값이다.
JWT의 Payload에 저장하는 정보가 많아지면 어떤 문제가 발생할 수 있는가?

토큰의 크기가 커지면 네트워크 요청 시 데이터 전송량이 증가하여 성능 저하를 유발할 수 있다.
5. Spring Security + JWT 적용
5.1. JWT 기반 인증을 위한 Spring Security 설정
5.1.1 실습 문제에 대한 답안
문제 1: Spring Security에 JWT 필터 추가

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, JwtAuthenticationFilter jwtAuthFilter) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/login").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
문제 2: JWT 인증 필터 생성

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;

    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String token = jwtTokenProvider.resolveToken(request);

        if (token != null && jwtTokenProvider.validateToken(token)) {
            Authentication authentication = jwtTokenProvider.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        filterChain.doFilter(request, response);
    }
}
5.2. JWT 발급 및 검증 로직 구현
5.2.1 실습 문제에 대한 답안
문제 1: JWT 토큰 발급 서비스 구현

@Component
public class JwtTokenProvider {

    private final String secretKey = "mySecretKey";
    private final long validityInMilliseconds = 3600000; // 1시간

    public String generateToken(String username) {
        Claims claims = Jwts.claims().setSubject(username);
        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInMilliseconds);

        return Jwts.builder()
            .setClaims(claims)
            .setIssuedAt(now)
            .setExpiration(validity)
            .signWith(SignatureAlgorithm.HS256, secretKey)
            .compact();
    }
}
문제 2: JWT 검증 서비스 구현

public boolean validateToken(String token) {
    try {
        Jws<Claims> claims = Jwts.parser()
            .setSigningKey(secretKey)
            .parseClaimsJws(token);
        return !claims.getBody().getExpiration().before(new Date());
    } catch (Exception e) {
        return false;
    }
}
6. API 요청 보호 및 권한 관리
6.1. 특정 API 보호 설정
6.1.1 실습 문제에 대한 답안
문제 1: 특정 API 보호 설정

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin").hasRole("ADMIN")
                .requestMatchers("/user").hasAnyRole("USER", "ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults());

        return http.build();
    }
}
6.2. Role 기반 접근 제어
6.2.1 실습 문제에 대한 답안
문제 1: Role 기반 접근 제어 설정

@RestController
@RequestMapping("/api")
public class RoleController {

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping("/admin")
    public String getAdminData() {
        return "Admin Access";
    }

    @Secured("ROLE_USER")
    @GetMapping("/user")
    public String getUserData() {
        return "User Access";
    }
}
7. 보안 고려사항 및 추가 설정
7.1. CORS(Cross-Origin Resource Sharing) 설정
7.1.1 실습 문제에 대한 답안
문제 1: CORS 설정 적용

@Configuration
public class CorsConfig {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                    .allowedOrigins("*")
                    .allowedMethods("GET", "POST", "PUT", "DELETE")
                    .allowedHeaders("Authorization", "Content-Type");
            }
        };
    }
}
7.2. CSRF(Cross-Site Request Forgery) 방어
7.2.1 실습 문제에 대한 답안
문제 1: CSRF 보호 설정

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults());

        return http.build();
    }
}
7.3. HTTPS 적용 및 보안 강화
7.3.1 실습 문제에 대한 답안
문제 1: HTTPS 적용 설정

server:
  port: 8443
  ssl:
    key-store: classpath:keystore.p12
    key-store-password: changeit
    key-store-type: PKCS12
    key-alias: tomcat
8. 인증과 보안 적용 시 유의할 점
8.1. JWT 보안 강화 방법
8.1.1 실습 문제에 대한 답안
문제 1: JWT 토큰 보안 강화

@Entity
public class RefreshToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String token;
    private String username;
    private Date expiryDate;
}
public String generateRefreshToken(String username) {
    String refreshToken = UUID.randomUUID().toString();
    RefreshToken token = new RefreshToken();
    token.setToken(refreshToken);
    token.setUsername(username);
    token.setExpiryDate(new Date(System.currentTimeMillis() + 86400000)); // 1일
    refreshTokenRepository.save(token);
    return refreshToken;
}
9. 연습 문제에 대한 답안
9.1 Spring Security 기본 설정

정답:
Spring Security를 설정하여 기본적인 인증을 적용한다.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .defaultSuccessUrl("/home", true)
            )
            .logout(logout -> logout.logoutSuccessUrl("/"));

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("password")
            .roles("USER")
            .build();
        return new InMemoryUserDetailsManager(user);
    }
}
9.2 In-Memory 사용자 인증 설정

정답:
In-Memory 방식으로 사용자 정보를 저장하고 인증을 처리한다.

@Bean
public UserDetailsService userDetailsService() {
    UserDetails admin = User.withDefaultPasswordEncoder()
        .username("admin")
        .password("admin123")
        .roles("ADMIN")
        .build();

    UserDetails user = User.withDefaultPasswordEncoder()
        .username("user")
        .password("user123")
        .roles("USER")
        .build();

    return new InMemoryUserDetailsManager(admin, user);
}
9.3 Database 연동을 통한 사용자 인증

정답:
MySQL 또는 H2 데이터베이스를 사용하여 사용자 정보를 저장하고 인증을 처리한다.

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.provisioning.JdbcUserDetailsManager;
import javax.sql.DataSource;

@Bean
public UserDetailsService userDetailsService(DataSource dataSource) {
    return new JdbcUserDetailsManager(dataSource);
}
9.4 JWT 토큰 생성 및 서명

정답:
사용자의 정보를 포함한 JWT를 생성한다.

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import java.util.Date;

public class JwtTokenProvider {
    private static final String SECRET_KEY = "mySecretKey";

    public String generateToken(String username) {
        return Jwts.builder()
            .setSubject(username)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + 3600000))
            .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
            .compact();
    }
}
9.5 JWT 인증 필터 구현

정답:
JWT를 추출하여 검증하고 SecurityContext에 저장한다.

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {

    private static final String SECRET_KEY = "mySecretKey";

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
        throws ServletException, IOException {
        String token = request.getHeader("Authorization");

        if (token != null && token.startsWith("Bearer ")) {
            try {
                Claims claims = Jwts.parser()
                    .setSigningKey(SECRET_KEY)
                    .parseClaimsJws(token.replace("Bearer ", ""))
                    .getBody();
                SecurityContextHolder.getContext().setAuthentication(null);
            } catch (SignatureException e) {
                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            }
        }
        chain.doFilter(request, response);
    }
}
9.6 특정 API 보호 설정

정답:
Spring Security를 사용하여 특정 API 엔드포인트 보호 설정을 추가한다.

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/admin").hasRole("ADMIN")
            .requestMatchers("/user").hasAnyRole("USER", "ADMIN")
            .anyRequest().authenticated()
        )
        .formLogin()
        .and()
        .logout();

    return http.build();
}
9.7 Role 기반 접근 제어

정답:
@PreAuthorize와 @Secured를 사용하여 역할 기반 접근을 설정한다.

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.access.annotation.Secured;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class RoleController {

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping("/admin")
    public String getAdminData() {
        return "Admin Data";
    }

    @Secured("ROLE_USER")
    @GetMapping("/user")
    public String getUserData() {
        return "User Data";
    }
}
9.8 CORS 설정 적용

정답:
Spring Boot에서 CORS 설정을 적용하여 모든 도메인에서 요청을 허용한다.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                    .allowedOrigins("*")
                    .allowedMethods("GET", "POST", "PUT", "DELETE")
                    .allowedHeaders("Authorization", "Content-Type");
            }
        };
    }
}
9.9 CSRF 보호 설정

정답:
JWT 기반 인증을 사용할 경우 CSRF 보호를 비활성화하고, 세션 기반 인증에서는 활성화한다.

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable())  // JWT 사용 시 CSRF 보호 비활성화
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
        .formLogin();
    return http.build();
}
9.10 HTTPS 활성화

정답:
Spring Boot에서 HTTPS를 활성화하고, HTTP 요청을 HTTPS로 리디렉트한다.

# application.properties 설정
server.port=8443
server.ssl.enabled=true
server.ssl.key-store=classpath:keystore.p12
server.ssl.key-store-password=mypassword
server.ssl.key-store-type=PKCS12
import org.springframework.boot.web.server.ConfigurableServletWebServerFactory;
import org.springframework.boot.web.server.Ssl;
import org.springframework.boot.web.servlet.server.ServletWebServerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class HttpsConfig {

    @Bean
    public ServletWebServerFactory servletContainer() {
        ConfigurableServletWebServerFactory factory = new ServletWebServerFactory();
        Ssl ssl = new Ssl();
        ssl.setEnabled(true);
        ssl.setKeyStore("classpath:keystore.p12");
        ssl.setKeyStorePassword("mypassword");
        factory.setSsl(ssl);
        return factory;
    }
}
닫기
