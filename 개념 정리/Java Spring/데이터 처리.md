# 데이터 계층의 개념
## 데이터 계층이란?
데이터 계층(Data Layer)이란 애플리케이션 내에서 데이터를 저장, 관리, 조작하는 역할을 담당하는 계층을 의미한다.<br>
Spring Boot에서는 데이터 계층을 별도로 분리하여 관리함으로써 애플리케이션의 구조를 명확하게 하고, 유지보수성을 높인다.

전형적인 Spring Boot 애플리케이션에서 데이터 계층은 다음과 같은 흐름을 따른다.<br>
```Controller → Service → Repository → Database```<br>
각 계층은 특정한 역할을 수행하며, 이 계층 구조를 통해 애플리케이션이 보다 유연하고 확장 가능하게 설계될 수 있다.

------------------
## 데이터 계층의 역할과 필요성
데이터 계층을 분리하는 이유는 비즈니스 로직과 데이터 저장 로직을 명확하게 구분하고, 애플리케이션의 유지보수성과 확장성을 향상시키기 위해서이다.<br>
데이터 계층이 없거나 모든 로직이 한 곳에 집중되어 있으면 다음과 같은 문제점이 발생할 수 있다.

**코드가 복잡해지고, 유지보수가 어렵다.** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 저장 및 조회 로직이 여러 곳에서 직접 실행되면 코드가 중복되고, 수정이 어렵다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예를 들어, 데이터베이스의 테이블 구조가 변경되면 관련된 모든 코드에서 수정이 필요하다.

**비즈니스 로직과 데이터 처리 로직이 뒤섞인다.** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스에서 데이터를 가져오는 과정과, 데이터를 가공하여 처리하는 로직이 하나의 메서드 안에 섞여 있다면, 코드가 읽기 어려워지고 변경 시 리스크가 커진다.

**테스트와 확장이 어렵다.** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 계층이 분리되어 있지 않으면, 단위 테스트(Unit Test)를 수행하기 어려워진다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;또한 새로운 기능을 추가하거나, 기존 데이터 저장 방식을 변경하는 것이 어렵다.

이러한 문제를 해결하기 위해, Spring Boot는 Controller - Service - Repository 구조를 통해 데이터 계층을 체계적으로 관리하도록 권장한다.

----------------
## Spring Boot의 계층 구조
Spring Boot 애플리케이션에서는 일반적으로 세 가지 주요 계층을 사용하여 데이터를 처리한다.

**컨트롤러(Controller) 계층** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트의 요청을 받아서 처리하는 역할을 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터를 직접 조작하지 않고, 서비스 계층을 호출하여 필요한 데이터를 가져오거나 수정하도록 한다.

**서비스(Service) 계층** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비즈니스 로직을 처리하는 계층이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스와 직접 상호작용하지 않으며, Repository를 통해 데이터 저장소에 접근한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터를 조작하기 전에 검증 및 변환 등의 작업을 수행한다.

**리포지토리(Repository) 계층** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스와 직접적인 연결을 담당하는 계층이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JpaRepository를 사용하여 데이터를 저장, 조회, 수정, 삭제하는 역할을 수행한다.

이제 각 계층의 역할을 구체적으로 살펴보자.

----------------
### Controller 계층: 클라이언트 요청을 처리하는 역할
컨트롤러(Controller) 계층은 클라이언트(웹 브라우저, 모바일 앱, 다른 API 요청 등)로부터 HTTP 요청을 받고, 이에 대한 응답을 반환하는 역할을 수행한다.<br>
Spring Boot에서는 ```@RestController``` 애노테이션을 사용하여 컨트롤러 클래스를 선언하며, 일반적으로 ```@RequestMapping```을 통해 URL을 매핑한다.

컨트롤러는 비즈니스 로직을 직접 수행하지 않고, 요청을 서비스 계층으로 전달하는 역할만 수행해야 한다.<br>
이를 통해 컨트롤러는 애플리케이션의 **입력과 출력만 담당하고, 실제 데이터 처리 로직은 서비스 계층에서 수행**되도록 설계할 수 있다.

다음은 간단한 UserController 예제이다.
```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    // 사용자 ID로 조회하는 API
    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable Long id) {
        UserDTO user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
}
```
이 코드에서 ```UserController```는 ```@RestController```를 통해 RESTful 웹 서비스로 동작하며,<br>
```/users/{id}``` 경로로 요청이 들어오면 ```UserService```를 호출하여 데이터를 가져온 후, 이를 클라이언트에게 반환한다.

----------------
### Service 계층: 비즈니스 로직을 담당하는 역할
서비스(Service) 계층은 애플리케이션의 핵심 로직을 수행하는 계층이다.<br>
이 계층에서는 단순한 CRUD 연산뿐만 아니라, 데이터 검증, 트랜잭션 처리, 도메인 로직 적용 등의 중요한 역할을 수행한다.

서비스 계층의 역할은 다음과 같다.

**비즈니스 로직을 구현**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단순히 데이터를 가져오는 것이 아니라, 데이터를 변환하거나 추가적인 로직을 수행할 수 있다.

**데이터의 유효성을 검사**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트가 요청한 데이터가 올바른지 확인하는 역할을 수행한다.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예를 들어, 사용자의 이메일이 중복되지 않았는지 검사하는 등의 로직이 포함될 수 있다.

**트랜잭션을 관리**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스에 여러 개의 변경 사항이 있을 때, 하나의 작업으로 묶어 트랜잭션을 처리할 수 있다.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;트랜잭션이 실패하면 롤백하여 데이터 정합성을 유지할 수 있다.

다음은 UserService의 예제 코드이다.
```java
@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // 사용자 조회
    public UserDTO getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다."));
        return new UserDTO(user);
    }
}
```
이 코드에서 ```UserService```는 ```UserRepository```를 통해 데이터베이스에서 사용자 정보를 가져온다.<br>
데이터가 존재하지 않으면 예외를 발생시키고, 데이터를 변환하여 반환한다.

---------------
### Repository 계층: 데이터 저장 및 조회를 담당하는 역할
리포지토리(Repository) 계층은 데이터베이스와 직접적인 상호작용을 담당하는 계층이다.<br>
Spring Boot에서는 ```Spring Data JPA```를 사용하여 데이터베이스와 연결하며,<br>
JPA를 통해 복잡한 SQL을 직접 작성하지 않고도 데이터를 쉽게 저장하고 조회할 수 있다.

리포지토리 계층은 데이터베이스와의 직접적인 연결을 담당하며, 다음과 같은 역할을 수행한다.

**데이터 조회 및 저장**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스에서 데이터를 검색하거나, 새로운 데이터를 저장한다.

**쿼리 최적화**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 접근을 효율적으로 수행하기 위해 필요한 경우 적절한 인덱스를 설정하거나, 쿼리를 최적화할 수 있다.

**JPA를 활용한 자동 쿼리 생성**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findById(), findAll() 등의 메서드를 사용하여 간편하게 데이터를 조회할 수 있다.

다음은 UserRepository의 예제 코드이다.
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
```
위 코드에서 ```JpaRepository<User, Long>```을 상속받으면 기본적인 CRUD 기능이 자동으로 제공된다.<br>
또한, ```findByEmail()```과 같은 메서드를 선언하면, 메서드 명을 기반으로 JPA가 자동으로 SQL 쿼리를 생성하여 실행한다.

Spring Boot에서 데이터 계층을 분리하면 비즈니스 로직과 데이터 저장 로직이 명확히 구분되며,<br>
이를 통해 코드의 재사용성, 유지보수성, 확장성이 크게 향상된다.

------------
## JDBC(Java Database Connectivity)란?
JDBC(Java Database Connectivity) 는 자바에서 데이터베이스와 연결하기 위해 사용되는 표준 API이다.<br>
JDBC를 사용하면 애플리케이션에서 직접 SQL을 작성하여 데이터베이스와 상호작용할 수 있다.

JDBC는 기본적으로 다음과 같은 과정으로 데이터베이스와 연동된다.

**JDBC 드라이버 로드**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;애플리케이션이 데이터베이스와 통신하기 위해 JDBC 드라이버를 로드한다.

**데이터베이스 연결(Connection) 생성**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDBC의 DriverManager를 통해 데이터베이스 연결을 생성한다.

**SQL 실행(Statement)** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQL 쿼리를 실행하여 데이터를 조회하거나 삽입, 수정, 삭제한다.

**결과(ResultSet) 처리**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;조회한 데이터를 ResultSet 객체를 통해 받아서 처리한다.

**자원 해제(Connection Close)** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스 연결을 종료하여 리소스를 반환한다.

다음은 JDBC를 사용하여 MySQL 데이터베이스에서 데이터를 조회하는 예제 코드이다.
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class JdbcExample {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String user = "root";
        String password = "password";

        try (Connection conn = DriverManager.getConnection(url, user, password);
             PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users");
             ResultSet rs = stmt.executeQuery()) {

            while (rs.next()) {
                System.out.println("ID: " + rs.getInt("id") + ", Name: " + rs.getString("name"));
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
#### JDBC의 장점
+ 데이터베이스에 직접 접근할 수 있어 성능이 빠르다.
+ 모든 데이터베이스에서 표준 API를 사용할 수 있다.
+ 복잡한 SQL을 직접 작성할 수 있어 데이터베이스 최적화가 가능하다.

#### JDBC의 단점
+ SQL을 직접 작성해야 하므로 코드가 길어지고 가독성이 떨어진다.
+ 데이터베이스에 따라 SQL 문법이 다를 수 있어 이식성이 떨어진다.
+ 데이터베이스와의 연결을 수동으로 관리해야 하므로, 유지보수가 어렵다.

-----------------
## JPA(Java Persistence API)란?
JPA(Java Persistence API)는 객체 지향 프로그래밍 방식으로 데이터베이스를 다룰 수 있도록 지원하는 Java 표준 ORM(Object-Relational Mapping) 기술이다.<br>
즉, SQL을 직접 작성하지 않고도 객체(Entity)와 데이터베이스 테이블 간의 매핑을 통해 데이터를 조작할 수 있다.

JPA는 다음과 같은 방식으로 동작한다.

**엔티티(Entity) 클래스 정의**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스의 테이블과 매핑되는 클래스를 @Entity 애노테이션을 이용해 정의한다.

**Persistence Context를 통한 데이터 저장 및 조회**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntityManager를 사용하여 객체를 데이터베이스에 저장하고 조회한다.

**JPQL(Java Persistence Query Language) 사용 가능**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA는 SQL이 아닌 객체 지향 쿼리인 JPQL을 제공하여, 객체 필드를 기준으로 데이터 조회가 가능하다.

다음은 JPA를 사용하여 사용자 정보를 조회하는 예제 코드이다.
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    // Getter, Setter
}
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByName(String name);
}
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> getUsersByName(String name) {
        return userRepository.findByName(name);
    }
}
```
#### JPA의 장점
+ SQL을 직접 작성하지 않아도 되므로 코드가 간결해지고 유지보수가 편리하다.
+ 데이터베이스 벤더에 종속되지 않으므로 이식성이 뛰어나다.
+ 객체 지향적인 방식으로 데이터를 처리할 수 있다.

#### JPA의 단점
+ 내부적으로 SQL을 자동 생성하므로, 성능 최적화가 어렵다.
+ 학습 곡선이 가파르며, 기존 SQL 기반 개발 방식과 다르므로 적응이 필요하다.

----------------
## Spring Data JPA란?
Spring Data JPA는 JPA를 보다 쉽게 사용할 수 있도록 도와주는 Spring의 서브 프로젝트이다.<br>
기본적인 CRUD 기능을 자동으로 제공하며, 별도의 SQL을 작성하지 않고도 데이터를 조회하고 수정할 수 있도록 지원한다.

Spring Data JPA를 사용하면 개발자가 직접 구현해야 하는 코드가 줄어들고, 유지보수가 편리해진다.

Spring Data JPA의 주요 특징은 다음과 같다.

**JpaRepository 인터페이스 제공**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```JpaRepository```를 상속받으면 기본적인 CRUD 메서드(save(), findById(), delete() 등)를 자동으로 사용할 수 있다.

**메서드 이름 기반 쿼리(Query Methods)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```findByName(String name)```과 같이 메서드 명만으로 자동으로 SQL이 생성된다.

**페이징 및 정렬 지원**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pageable을 사용하여 간편하게 페이징 처리가 가능하다.

다음은 Spring Data JPA를 사용하여 사용자 정보를 조회하는 예제 코드이다.
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByName(String name);
}
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> getUsersByName(String name) {
        return userRepository.findByName(name);
    }
}
```
#### Spring Data JPA의 장점
+ JPA를 더욱 쉽게 사용할 수 있도록 지원한다.
+ 기본적인 CRUD 기능이 자동으로 제공되므로 개발 생산성이 향상된다.
+ 데이터베이스에 맞춰 복잡한 SQL을 직접 작성할 필요가 없다.

#### Spring Data JPA의 단점
+ 내부적으로 SQL이 자동 생성되므로, 성능 최적화가 어렵다.
+ JPA의 깊은 이해가 필요하며, 잘못된 설정으로 인해 예상치 못한 쿼리가 실행될 수 있다.

Spring Boot에서는 JDBC, JPA, Spring Data JPA를 활용하여 데이터베이스와 연동할 수 있으며,<br>
각 방식의 특성과 장단점을 고려하여 프로젝트에 적절한 방식을 선택해야 한다.

----------------------
## 엔티티(Entity)와 테이블 매핑
### 엔티티(Entity)의 개념
Spring Boot에서 JPA를 활용하여 데이터베이스와 연동할 때, 데이터베이스의 테이블과 매핑되는 자바 클래스를 엔티티(Entity)라고 한다.<br>
즉, 엔티티는 데이터베이스의 한 테이블을 객체지향적으로 표현한 클래스이며, 각 인스턴스는 테이블의 한 행(Row)에 해당한다.

JPA에서는 ```@Entity``` 애노테이션을 이용하여 클래스를 엔티티로 선언할 수 있다.<br>
다음은 간단한 User 엔티티를 정의하는 예제이다.
```java
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private int age;

    // 기본 생성자 필수 (JPA는 기본 생성자가 필요함)
    public User() {}

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getter & Setter
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```
위의 코드에서 ```User``` 클래스는 데이터베이스의 ```user``` 테이블과 매핑된다.<br>
클래스의 각 필드는 테이블의 컬럼(Column)에 대응하며, ```@Id```는 기본 키를 나타낸다.

--------------
## 엔티티(Entity)의 특징
**데이터베이스 테이블과 1:1 매핑된다.** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;하나의 엔티티는 하나의 데이터베이스 테이블과 매칭된다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예를 들어 User 엔티티가 있으면, 이를 저장할 데이터베이스 테이블 user가 존재해야 한다.

**객체 지향적인 데이터 관리를 가능하게 한다.** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQL을 직접 다루는 것이 아니라, 자바 객체를 통해 데이터를 조작할 수 있다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@Entity``` 애노테이션을 사용해야 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;엔티티 클래스로 인식되려면 반드시 @Entity 애노테이션을 붙여야 한다.

**기본 생성자가 필요하다.** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA는 엔티티 객체를 생성할 때 기본 생성자를 필요로 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;따라서 반드시 public User() {}와 같은 기본 생성자를 제공해야 한다.

**필드는 private으로 선언하고, Getter/Setter를 제공해야 한다.** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA는 기본적으로 필드에 직접 접근하는 것이 아니라, Getter/Setter 메서드를 통해 데이터를 조작한다.

-------------
## 엔티티의 기본 키(Primary Key)
모든 엔티티는 반드시 기본 키(Primary Key) 를 가져야 한다.<br>
기본 키는 ```@Id``` 애노테이션을 사용하여 지정할 수 있으며, 키를 자동으로 생성하려면 ```@GeneratedValue```를 사용할 수 있다.

기본 키를 생성하는 전략에는 다음과 같은 방식이 있다.

```IDENTITY```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스의 AUTO_INCREMENT 기능을 사용하여 자동 증가.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MySQL, MariaDB 등의 데이터베이스에서 많이 사용된다.

```SEQUENCE```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스의 시퀀스(Sequence)를 사용하여 기본 키를 생성.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Oracle, PostgreSQL에서 주로 사용된다.

```TABLE```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;별도의 테이블을 만들어 기본 키를 관리하는 방식.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;거의 사용되지 않음.

```AUTO```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스에 따라 적절한 기본 키 전략을 자동 선택.

아래는 @GeneratedValue를 사용하여 자동 증가하는 기본 키를 설정하는 예제이다.
```java
@Entity
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private double price;

    public Product() {}

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    // Getter & Setter
}
```
위 코드에서 ```id``` 필드는 ```IDENTITY``` 전략을 사용하여 자동 증가하는 기본 키가 된다.

----------------
## 엔티티 객체의 라이프사이클
JPA에서는 엔티티 객체가 데이터베이스와 연동되면서 라이프사이클(Lifecycle) 을 가진다.<br>
엔티티 객체는 다음과 같은 4가지 상태를 가진다.

**비영속(Transient)** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;엔티티 객체가 new를 통해 생성되었지만, 아직 EntityManager에 저장되지 않은 상태.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스와 관계가 없는 단순한 자바 객체 상태.

**영속(Managed)** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntityManager를 통해 persist()가 호출되면, 해당 객체는 영속 상태가 된다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 상태에서는 JPA가 해당 객체를 관리하며, 변경 사항을 자동으로 반영한다.

**준영속(Detached)** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detach()를 호출하면 객체는 영속성 컨텍스트에서 분리되며, 데이터베이스와의 연결이 끊긴다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;더 이상 자동 변경 감지가 되지 않는다.

**삭제(Removed)** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove()가 호출되면 데이터베이스에서 해당 객체가 삭제된다.

아래는 라이프사이클을 예제로 설명한 코드이다.
```java
@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    public Customer() {}
    public Customer(String name) {
        this.name = name;
    }
}
public class JpaLifecycleExample {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("example-unit");
        EntityManager em = emf.createEntityManager();

        // 비영속 상태 (Transient)
        Customer customer = new Customer("John Doe");

        em.getTransaction().begin();

        // 영속 상태 (Managed)
        em.persist(customer);

        // 준영속 상태 (Detached)
        em.detach(customer);

        // 삭제 상태 (Removed)
        em.remove(customer);

        em.getTransaction().commit();
        em.close();
        emf.close();
    }
}
```
위 코드에서는 ```customer``` 객체가 생성된 후 ```persist()``` 메서드를 통해 영속 상태로 변경되고,<br>
이후 ```detach()```를 통해 준영속 상태가 되며, ```remove()```를 호출하면 삭제된다.


## 주요 애노테이션
Spring Boot에서 JPA를 활용하여 엔티티를 정의할 때, 다양한 애노테이션을 사용할 수 있다.<br>
이 애노테이션들은 엔티티와 데이터베이스 테이블 간의 매핑을 정의하고, JPA가 이를 통해 자동으로 테이블을 생성하고 관리할 수 있도록 돕는다.<br>
여기서는 엔티티 설계에서 가장 중요한 애노테이션을 하나씩 상세하게 다룬다.

-------------
### @Entity
```@Entity``` 애노테이션은 해당 클래스가 JPA 엔티티임을 선언하는 역할을 한다.<br>
JPA에서 엔티티는 반드시 ```@Entity``` 애노테이션이 있어야 인식된다.
```java
import jakarta.persistence.Entity;
 
@Entity
public class Product {
    private Long id;
    private String name;
}
```
위와 같이 ```@Entity```를 선언하면 JPA는 해당 클래스를 데이터베이스 테이블과 연결된 엔티티로 인식한다.<br>
만약 ```@Entity``` 애노테이션이 없으면, JPA가 해당 클래스를 엔티티로 처리하지 않으며, 테이블과의 매핑도 이루어지지 않는다.

#### 주의사항
```@Entity``` 애노테이션이 선언된 클래스는 반드시 기본 생성자(default constructor)를 가져야 한다.<br>
JPA는 엔티티 클래스를 관리할 때 기본 생성자를 사용하여 객체를 생성하기 때문이다.
```java
@Entity
public class User {
    private Long id;
    private String name;

    // 기본 생성자 (필수)
    public User() {}
}
```
-------------
### @Table
기본적으로 엔티티 클래스의 이름은 테이블 이름과 동일하게 매핑된다.<br>
하지만 테이블 이름을 명시적으로 설정하고 싶다면 ```@Table``` 애노테이션을 사용한다.
```java
import jakarta.persistence.Entity;
import jakarta.persistence.Table;

@Entity
@Table(name = "users") // 테이블명을 "users"로 지정
public class User {
    private Long id;
    private String name;
}
```
이렇게 설정하면 ```User``` 엔티티는 ```users```라는 테이블과 매핑된다.
특정한 스키마(schema)를 지정하고 싶다면 ```schema``` 속성을 사용할 수도 있다.
```java
@Table(name = "users", schema = "public")
```
#### 주의사항
테이블 이름을 명시하지 않으면 클래스명이 기본적으로 테이블명이 된다.<br>
일부 데이터베이스에서는 테이블명이 대소문자를 구별하므로, 필요에 따라 명시적으로 지정하는 것이 좋다.

---------------
### @Id
```@Id``` 애노테이션은 기본 키(Primary Key) 를 설정하는 데 사용된다.<br>
모든 엔티티는 기본 키를 반드시 가져야 하며, 이를 통해 개별 데이터를 식별할 수 있다.
```java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class Product {
    @Id
    private Long id;
    private String name;
}
```
#### 주의사항
@Id를 사용하지 않으면 JPA에서 엔티티를 관리할 수 없다.<br>
기본 키 없이 엔티티를 저장하려 하면 실행 시 오류가 발생한다.

-------------
### @GeneratedValue
기본 키 값을 자동으로 생성하도록 설정할 수 있다.<br>
이를 위해 @GeneratedValue 애노테이션을 사용하며, 전략(strategy)에 따라 다양한 방식으로 자동 증가가 가능하다.
```java
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
}
```
기본 키 자동 생성 전략은 다음과 같이 네 가지가 있다.

```IDENTITY```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스가 자동 증가(AUTO_INCREMENT) 기능을 제공하는 경우 사용.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MySQL, MariaDB, PostgreSQL 등에서 자주 사용됨.

```SEQUENCE```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스의 시퀀스(Sequence)를 사용하여 기본 키를 생성.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Oracle, PostgreSQL에서 주로 사용됨.

```TABLE```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;별도의 테이블을 생성하여 기본 키 값을 관리.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;거의 사용되지 않음.

```AUTO```<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA가 데이터베이스에 따라 자동으로 적절한 전략을 선택.

---------------------
### @Column
```@Column``` 애노테이션은 필드를 특정한 테이블 컬럼(Column)과 매핑할 때 사용한다.<br>
이 애노테이션을 명시하지 않더라도, 기본적으로 필드명과 동일한 이름으로 컬럼이 생성되지만,<br>
추가적인 설정이 필요할 경우 @Column을 사용하여 속성을 지정할 수 있다.
```java
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class Customer {
    @Id
    private Long id;

    @Column(name = "customer_name", length = 100, nullable = false)
    private String name;
}
```
위 코드에서 ```@Column``` 애노테이션을 통해 다음과 같은 설정을 추가했다.

```name = "customer_name"```→ 컬럼명을 ```customer_name```으로 지정.<br>
```length = 100``` → 문자열 길이를 100자로 제한.<br>
```nullable = false``` → 해당 필드는 ```NULL```을 허용하지 않음.

#### 자주 사용되는 속성

```name``` → 데이터베이스의 컬럼명을 지정.<br>
```length``` → 문자열의 최대 길이를 지정.<br>
```nullable``` → false로 설정하면 NULL을 허용하지 않음.<br>
```unique``` → true로 설정하면 해당 컬럼의 값이 유일해야 함.<br>
```updatable``` → false로 설정하면 값 변경이 불가능.

-----------------
### @Transient
일부 필드는 데이터베이스 컬럼으로 저장하지 않아야 할 수도 있다.<br>
예를 들어, 임시로 계산된 값을 저장하는 필드는 데이터베이스에 저장할 필요가 없다.<br>
이 경우 ```@Transient``` 애노테이션을 사용하여 JPA가 해당 필드를 관리하지 않도록 설정할 수 있다.
```java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Transient;

@Entity
public class Order {
    @Id
    private Long id;

    private double price;
    private double discount;

    @Transient
    private double discountedPrice;

    public double getDiscountedPrice() {
        return price - discount;
    }
}
```
위 코드에서 discountedPrice 필드는 @Transient로 선언되어 있어 데이터베이스에 저장되지 않는다.

**사용 예시**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비즈니스 로직을 처리하는 계산된 필드.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스와 무관한 UI 관련 정보.

---------------
### @Lob
```@Lob``` 애노테이션은 큰 데이터(LOB: Large Object)를 저장할 때 사용된다.<br>
일반적으로 텍스트 데이터(Clob) 또는 바이너리 데이터(Blob) 를 저장하는 데 활용된다.
```java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Lob;

@Entity
public class Document {
    @Id
    private Long id;

    @Lob
    private String content;
}
```
위 코드에서 content 필드는 큰 크기의 문자열 데이터를 저장할 수 있도록 설정되었다.

---------
### @Enumerated
```@Enumerated``` 애노테이션은 Java의 ```enum```타입을 데이터베이스 컬럼과 매핑할 때 사용된다.
```java
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Id;

@Entity
public class Task {
    @Id
    private Long id;

    @Enumerated(EnumType.STRING)
    private Status status;

    public enum Status {
        PENDING, IN_PROGRESS, COMPLETED
    }
}
```
```EnumType.ORDINAL``` → 정수 값(0, 1, 2...)으로 저장됨 (비추천).<br>
```EnumType.STRING``` → ```PENDING, IN_PROGRESS``` 등 문자열로 저장됨 (권장).

-----------
## 엔티티 설계 시 고려할 사항
Spring Boot에서 엔티티(Entity)를 설계할 때 고려해야 할 중요한 요소들이 있다.<br>
JPA를 사용하여 엔티티를 설계할 때는 객체 지향 프로그래밍과 관계형 데이터베이스(RDBMS)의 차이점을 이해하고,
올바른 패턴을 적용해야 한다.<br>
여기에서는 엔티티 설계 시 반드시 고려해야 할 요소들을 다룬다.

### 객체 지향 모델과 관계형 모델 간의 차이점
JPA를 활용하여 데이터베이스를 설계할 때는 객체 지향 모델과 관계형 데이터베이스 모델 간의 차이를 이해하는 것이 중요하다.<br>
객체 지향 프로그램과 관계형 데이터베이스 간에는 다음과 같은 구조적 차이가 있다.

**객체 지향 모델**<br>
개념적으로는 객체 간의 관계(참조) 를 기반으로 데이터가 관리된다.<br>
메모리상에서 객체 간 참조(Reference) 를 통해 관계를 맺는다.<br>
객체의 캡슐화, 상속, 다형성 등의 개념이 사용된다.

### 관계형 데이터베이스 모델

데이터를 테이블의 행(row)과 열(column) 로 표현한다.<br>
엔티티 간의 관계를 외래 키(Foreign Key) 를 통해 관리한다.<br>
정규화(Normalization) 를 통해 데이터를 효율적으로 저장한다.
```java
@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(mappedBy = "customer")
    private List<Order> orders;
}
```
위 코드에서 ```Customer``` 엔티티는 ```Order``` 엔티티와 1:N(One-to-Many) 관계를 갖는다.<br>
객체 지향적으로 보면 ```Customer``` 객체가 ```Order``` 리스트를 포함하고 있지만,<br>
관계형 데이터베이스에서는 ```Order``` 테이블이 ```customer_id``` 라는 외래 키(Foreign Key) 를 통해 관계를 맺는다.

---------
### 일반적인 엔티티 설계 패턴
엔티티 설계를 할 때는 다음과 같은 원칙을 지켜야 한다.

**기본 키(PK)로 Long 타입의 ID 사용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA에서는 기본 키로 ```Long``` 타입의 값을 사용하는 것이 일반적이다.<br>
UUID 등을 활용할 수도 있지만, ```@GeneratedValue(strategy = GenerationType.IDENTITY)``` 와 함께 ```Long``` 타입을 사용하면 자동 증가(Auto Increment) 기능을 활용할 수 있다.
```java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
}
```
#### Getter, Setter의 사용 제한
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA 엔티티에서는 불필요한 setter 메서드를 지양하는 것이 좋다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;대신, 생성자 또는 명확한 메서드를 통해 데이터 변경을 유도 해야 한다.
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    protected User() {} // 기본 생성자 (필수)

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```
위와 같이 setter 를 제거하고, 생성자와 getter 만을 제공하면,<br>
불필요한 데이터 변경을 방지할 수 있다.

**연관 관계를 설정할 때 ```@ManyToOne```을 우선 고려**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA에서는 N:1 관계```(@ManyToOne)```을 우선적으로 설정하고, 필요할 경우 ```@OneToMany``` 를 추가하는 것이 좋다.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;양방향 관계를 설정할 때는 **연관 관계의 주인(owner)을 명확하게 지정**해야 한다.
```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;
}
```
위 코드에서 Order 엔티티는 Customer 엔티티를 참조하는 N:1 관계를 가진다.<br>
이 경우 외래 키(FK)는 ```Order``` 테이블 에 위치하게 된다.

--------------------
### 연관 관계를 설정할 때의 고려 사항
양방향 연관 관계를 설정할 때 ```mappedBy```를 명확히 지정해야 한다.<br>
연관 관계의 주인(Owner)을 지정하지 않으면 JPA가 두 개의 외래 키를 생성하는 문제가 발생할 수 있다.
```java
@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(mappedBy = "customer")
    private List<Order> orders;
}
```
위 코드에서 ```@OneToMany(mappedBy = "customer")``` 를 설정하지 않으면,<br>
JPA는 ```Customer``` 와 ```Order``` 각각에 별도의 외래 키를 추가하려고 시도한다.

```@JoinColumn```을 명시적으로 지정하여 테이블 명을 명확하게 관리할 수 있다.
```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "customer_id") // 외래 키 컬럼 명을 명시적으로 지정
    private Customer customer;
}
```
위와 같이 ```@JoinColumn(name = "customer_id")``` 를 명확하게 지정하면,<br>
JPA가 자동으로 생성하는 컬럼명을 변경할 수 있다.

**Cascade 옵션을 신중히 사용해야 한다.**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```CascadeType.ALL``` 을 설정하면 부모 엔티티 삭제 시 자식 엔티티도 삭제될 수 있으므로 주의해야 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;대부분의 경우 ```CascadeType.PERSIST``` 또는 ```CascadeType.MERGE``` 를 사용하여 불필요한 삭제를 방지하는 것이 좋다.
```java
@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Order> orders;
}
```
위 코드에서 ```orphanRemoval = true``` 를 추가하면,<br>
부모 엔티티에서 자식 엔티티를 제거하면 자동으로 데이터베이스에서도 삭제된다.

------------------
## 데이터 정규화와 성능 최적화
**정규화(Normalization)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA를 사용할 때도 기본적인 정규화 원칙을 따르는 것이 중요하다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;반복되는 데이터는 별도의 테이블로 분리하고, 외래 키를 사용하여 참조하는 방식이 일반적이다.<br>

**조회 성능 최적화**<br>
```@OneToMany(fetch = FetchType.LAZY)``` 설정을 기본값으로 지정하여,<br>
불필요한 데이터를 즉시 조회하지 않도록 한다.
```java
@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(mappedBy = "customer", fetch = FetchType.LAZY)
    private List<Order> orders;
}
```
```FetchType.LAZY``` 를 사용하면 연관된 엔티티를 필요할 때만 조회할 수 있어 성능이 향상된다.<br>
```FetchType.EAGER``` 를 사용하면 즉시 로딩되지만, 불필요한 조인이 발생할 수 있다.

-------------------
## Repository 계층의 역할
Spring Boot에서 데이터를 다루는 과정에서 Repository 계층은 필수적인 요소다.<br>
Repository 계층은 데이터베이스와 직접 상호작용하며, 비즈니스 로직을 담당하는 Service 계층과 분리되어 있다.<br>
이는 책임을 명확히 분리하고, 유지보수를 용이하게 하며, 코드의 재사용성을 높이는 중요한 원칙이다.

### Repository 계층의 주요 역할
**데이터 저장, 조회, 수정, 삭제 (CRUD) 처리**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Repository 계층은 기본적으로 데이터베이스의 CRUD(Create, Read, Update, Delete) 연산을 담당한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```save(), findById(), findAll(), deleteById()``` 등의 메서드를 활용하여 데이터를 조작할 수 있다.

**비즈니스 로직과 데이터 접근 로직의 분리**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터를 조작하는 로직을 Service 계층과 Repository 계층으로 나누면 유지보수가 용이해진다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Service 계층에서는 비즈니스 규칙을 다루고, Repository 계층은 단순한 데이터 조작만 수행한다.

**데이터베이스에 대한 의존성 감소**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Data JPA를 활용하면 데이터베이스 구현 방식에 대한 의존성을 줄일 수 있다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스가 변경되더라도 Repository 계층만 수정하면 나머지 코드는 그대로 유지할 수 있다.

------------------
## Repository 계층의 기본 구조
Spring Boot에서 Repository 계층은 인터페이스 형태로 선언되며, ```JpaRepository<T, ID>``` 를 상속받아 사용한다.<br>
이렇게 하면 기본적인 CRUD 메서드를 자동으로 제공받을 수 있다.
```java
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
}
```
위 코드에서 ```JpaRepository<User, Long>``` 를 상속받았기 때문에<br>
별도의 SQL 쿼리를 작성하지 않아도 자동으로 데이터베이스 연동이 가능하다.

```User``` → 이 Repository가 다룰 엔티티(Entity)<br>
```Long``` → 기본 키(PK)의 데이터 타입

-----------------
## Repository 계층과 Service 계층의 역할 분리
아래와 같은 방식으로 Service 계층에서 Repository 계층을 사용하여 데이터를 조작한다.
```java
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```
위 코드를 통해 **비즈니스 로직(Service 계층)과 데이터베이스 접근(Repository 계층)이 명확히 분리**된다.<br>
이 방식은 유지보수와 확장성을 높이는 데 중요한 역할을 한다.

--------------
### 데이터 계층의 역할 분리가 필요한 이유
**단일 책임 원칙(Single Responsibility Principle, SRP)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Service```는 비즈니스 로직을 담당하고,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Repository```는 데이터베이스와 상호작용하는 역할을 담당한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;역할이 분리되면, 특정 계층의 변경이 다른 계층에 영향을 미치지 않아 유지보수가 쉬워진다.

**테스트 용이성(Testability)** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Service``` 계층을 테스트할 때 실제 데이터베이스가 필요하지 않다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Mock Repository``` 를 활용하여 테스트가 가능하며, 이는 단위 테스트(Unit Test)를 효과적으로 수행할 수 있도록 돕는다.

**유지보수와 확장성 향상**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스가 변경되더라도, Repository 계층만 수정하면 된다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 기능이 추가될 경우, Service 계층을 변경하더라도<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Repository 코드는 그대로 유지할 수 있다.

----------------
## 기본 CRUD 연산
Spring Data JPA를 사용하면 **기본적인 데이터 조작(저장, 조회, 수정, 삭제)** 을 쉽게 수행할 수 있다.<br>
JPA는 ```JpaRepository``` 인터페이스를 제공하며, 이를 상속받으면 별도의 SQL을 작성하지 않고도 CRUD 연산을 수행할 수 있다.

---------------
### CRUD란?
CRUD는 데이터 조작의 기본적인 4가지 기능을 의미한다.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create (생성) → 데이터를 저장<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read (읽기) → 데이터를 조회<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Update (수정) → 기존 데이터를 변경<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete (삭제) → 데이터를 제거

Spring Data JPA는 이 기능을 간단한 메서드 호출만으로 실행할 수 있도록 도와준다.

----------------
### 기본 CRUD 메서드
Spring Data JPA에서 제공하는 JpaRepository를 상속하면 아래와 같은 기본적인 CRUD 메서드를 사용할 수 있다.

|메서드|설명|
|:---|:---|
|save(entity)|엔티티를 저장하거나 업데이트|
|findById(id)|특정 ID에 해당하는 데이터를 조회|
|findAll()|모든 데이터를 조회|
|deleteById(id)|특정 ID에 해당하는 데이터를 삭제|
|delete(entity)|엔티티 자체를 삭제|

이제 각각의 메서드에 대해 예제와 함께 살펴보자.

### 데이터 저장 (Create - save)
데이터를 저장할 때는 ```save()``` 메서드를 사용한다.<br>
이 메서드는 새로운 데이터 삽입뿐만 아니라, 기존 데이터 업데이트에도 사용된다.
```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```
위의 ```UserRepository```는 ```JpaRepository<User, Long>```을 상속받아 기본적인 CRUD 기능을 제공한다.<br>
이제 ```save()``` 메서드를 사용하여 새로운 데이터를 저장해 보자.
```java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public User createUser(String name, int age) {
        User user = new User();
        user.setName(name);
        user.setAge(age);
        return userRepository.save(user); // 데이터 저장
    }
}
```
```save()``` 메서드를 호출하면 데이터베이스에 새로운 User 객체가 저장된다.<br>
만약 동일한 ID를 가진 User 객체가 존재한다면 해당 데이터를 업데이트한다.

-----------
### 데이터 조회 (Read - findById, findAll)
데이터를 조회할 때는 ```findById()```와 ```findAll()```을 사용할 수 있다.
```java
import java.util.List;
import java.util.Optional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id); // ID를 이용한 조회
    }

    public List<User> getAllUsers() {
        return userRepository.findAll(); // 전체 데이터 조회
    }
}
```
```findById(id)``` : 특정 ID에 해당하는 데이터를 조회하며, Optional<User> 을 반환한다.
Optional을 사용하면 데이터가 존재하지 않을 경우 NullPointerException을 방지할 수 있다.<br>
```findAll()``` : 테이블의 모든 데이터를 조회한다.

-------------
### 데이터 수정 (Update - save)
데이터를 수정할 때도 ```save()``` 메서드를 사용한다.<br>
단, 기존 데이터를 먼저 조회한 후, 변경한 값을 다시 ```save()``` 메서드를 이용해 저장해야 한다.
```java
import java.util.Optional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public User updateUser(Long id, String newName, int newAge) {
        Optional<User> userOptional = userRepository.findById(id);

        if (userOptional.isPresent()) {
            User user = userOptional.get();
            user.setName(newName);
            user.setAge(newAge);
            return userRepository.save(user); // 수정된 데이터 저장
        } else {
            throw new RuntimeException("User not found with id: " + id);
        }
    }
}
```
기존 데이터를 ```findById(id)```로 조회한 후 값을 수정하고 다시 ```save()```를 호출한다.<br>
```save()```는 ID가 존재하면 업데이트, 존재하지 않으면 새 데이터로 저장한다.

-----------
### 데이터 삭제 (Delete - deleteById, delete)
데이터를 삭제할 때는 ```deleteById(id)``` 또는 ```delete(entity)```를 사용할 수 있다.
```java
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public void deleteUser(Long id) {
        userRepository.deleteById(id); // ID를 이용한 데이터 삭제
    }
}
```
```deleteById(id)``` : ID를 이용해 데이터를 삭제한다.<br>
```delete(entity)``` : 엔티티 객체를 직접 삭제할 수도 있다.

-------------
### CRUD 예제 실행 흐름 정리
**데이터 저장**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```save()``` 호출 → 새로운 데이터 저장

**데이터 조회**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```findById(id)``` → 특정 ID 조회<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```findAll()``` → 전체 데이터 조회

**데이터 수정**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```findById(id)```로 기존 데이터 가져오기<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;필드 값 수정 후 ```save()``` 호출

**데이터 삭제**<br>
```deleteById(id)```로 특정 데이터 삭제

-----------
## 쿼리 메서드(Query Method)
Spring Data JPA에서는 **개발자가 직접 쿼리를 작성하지 않아도 메서드의 이름만으로 자동으로 SQL을 생성하는 기능**을 제공한다.<br>
이 기능을 **쿼리 메서드(Query Method)** 라고 하며, **메서드 네이밍 규칙을 활용하여 데이터 조회를 수행**할 수 있다.

---------------
### 쿼리 메서드의 개념
일반적으로 데이터 조회를 위해서는 SQL을 작성해야 하지만, Spring Data JPA에서는 **메서드의 이름만으로도 SQL이 자동 생성**된다.<br>
예를 들어 ```findByName(String name)```이라는 메서드를 작성하면, 내부적으로 ```SELECT * FROM user WHERE name = ?```와 같은 SQL이 자동 실행된다.

즉, **메서드 명을 보고 어떤 SQL이 실행될지 쉽게 예측할 수 있다.**<br>
이는 **SQL을 직접 작성할 필요 없이 편리하게 데이터 조회 로직을 구현할 수 있도록 도와준다.**

---------------
### 쿼리 메서드의 네이밍 규칙
Spring Data JPA에서는 메서드 이름을 특정 규칙에 따라 작성하면 자동으로 SQL을 생성할 수 있다.

|키워드|SQL 변환 결과|
|:---|:---|
|```findByName(String name)```|```SELECT * FROM user WHERE name = ?```|
|```findByAgeGreaterThan(int age)```|```SELECT * FROM user WHERE age > ?```|
|```findByEmailContaining(String email)```|```SELECT * FROM user WHERE email LIKE %?%```|
|```findByCreatedAtBetween(Date start, Date end)```|```SELECT * FROM user WHERE created_at BETWEEN ? AND ?```|
이처럼 **쿼리 메서드는 메서드명을 기반으로 SQL을 자동 생성**하며, 다양한 키워드를 활용하여 세부적인 조건을 추가할 수 있다.

---------------
### 기본적인 쿼리 메서드 예제
Spring Data JPA에서 쿼리 메서드를 활용하는 기본적인 방법을 살펴보자.

엔티티(Entity) 정의
```java
import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private int age;

    @Column(unique = true)
    private String email;

    @Column
    private LocalDateTime createdAt = LocalDateTime.now();

    // Getter, Setter 생략
}
```
쿼리 메서드가 포함된 Repository 인터페이스 작성

```java
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {

    // 이름으로 조회
    Optional<User> findByName(String name);

    // 특정 나이 이상인 사용자 조회
    List<User> findByAgeGreaterThan(int age);

    // 이메일에 특정 문자열이 포함된 사용자 조회
    List<User> findByEmailContaining(String email);

    // 특정 날짜 범위 내에서 생성된 사용자 조회
    List<User> findByCreatedAtBetween(LocalDateTime start, LocalDateTime end);
}
```

서비스(Service) 계층에서 쿼리 메서드 사용
```java
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public Optional<User> getUserByName(String name) {
        return userRepository.findByName(name); // 이름으로 검색
    }

    public List<User> getUsersByAge(int age) {
        return userRepository.findByAgeGreaterThan(age); // 특정 나이 이상 사용자 조회
    }

    public List<User> searchByEmail(String email) {
        return userRepository.findByEmailContaining(email); // 이메일 포함 검색
    }

    public List<User> getUsersByDateRange(LocalDateTime start, LocalDateTime end) {
        return userRepository.findByCreatedAtBetween(start, end); // 날짜 범위 검색
    }
}
```

컨트롤러(Controller)에서 서비스 호출
```java
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/name/{name}")
    public Optional<User> getUserByName(@PathVariable String name) {
        return userService.getUserByName(name);
    }

    @GetMapping("/age/{age}")
    public List<User> getUsersByAge(@PathVariable int age) {
        return userService.getUsersByAge(age);
    }

    @GetMapping("/email/{email}")
    public List<User> searchByEmail(@PathVariable String email) {
        return userService.searchByEmail(email);
    }

    @GetMapping("/created-at")
    public List<User> getUsersByDateRange(@RequestParam LocalDateTime start, @RequestParam LocalDateTime end) {
        return userService.getUsersByDateRange(start, end);
    }
}
```
-----------------
### 쿼리 메서드에서 지원하는 연산자
쿼리 메서드에서 사용할 수 있는 다양한 연산자를 알아보자.

|키워드|설명|예제|
|:---|:---|:---|
|And|AND 조건 추가|findByNameAndAge(String name, int age)|
|Or|OR 조건 추가|findByNameOrEmail(String name, String email)|
|GreaterThan|초과 비교 (>)|findByAgeGreaterThan(int age)|
|LessThan|미만 비교 (<)|findByAgeLessThan(int age)|
|Between|값 범위 지정|findByAgeBetween(int start, int end)|
|Like|특정 패턴 검색|findByNameLike(String name)|
|Containing|부분 문자열 포함|findByEmailContaining(String email)|
|OrderBy|정렬 조건 추가|findByNameOrderByAgeDesc(String name)|

------------
### 쿼리 메서드의 한계점과 해결 방법
쿼리 메서드는 메서드 명만으로 SQL을 자동 생성하는 강력한 기능을 제공하지만,<br>
복잡한 쿼리를 작성하기에는 한계가 있다.<br>
특히, **다중 조건이 포함된 복잡한 검색 쿼리**는 메서드명이 너무 길어져 가독성이 떨어질 수 있다.

이러한 한계를 해결하는 방법은 다음과 같다.

**@Query 애노테이션 사용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;직접 SQL을 작성할 수 있도록 지원한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복잡한 조건을 처리하는데 유리하다.
```java
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u WHERE u.name = :name AND u.age > :age")
    List<User> findUsersByNameAndAge(@Param("name") String name, @Param("age") int age);
}
```
**Specification을 활용한 동적 쿼리 작성**<br>
```Specification<T>```을 사용하여 조건을 동적으로 추가할 수 있다.<br>
검색 조건이 여러 개일 경우 유용하다.

-----------
## 관계 매핑과 엔티티 간 연관 관계
Spring Data JPA에서는 객체 지향적인 방식으로 데이터베이스의 테이블 간 관계를 정의할 수 있도록 여러 가지 연관 관계 매핑을 제공한다.<br>
관계형 데이터베이스에서는 테이블 간 ```1:1(One-to-One), 1:N(One-to-Many), N:1(Many-to-One), N:M(Many-to-Many)``` 등의 관계가 존재하며, 이를 객체 모델에서도 표현해야 한다.

------------
### 엔티티 간 관계의 중요성
객체 간 관계를 올바르게 설정하면 **데이터 일관성을 유지할 수 있고, 객체 지향적인 방식으로 데이터를 관리할 수 있다.**<br>
그러나 관계 매핑을 잘못 설정하면 **불필요한 쿼리가 실행되거나 성능 문제가 발생할 수 있다.**<br>
따라서 각 관계의 특징을 명확히 이해하고 상황에 맞게 적용하는 것이 중요하다.

------------------
### JPA에서 제공하는 주요 관계 매핑
|관계 유형|설명|애노테이션|
|:---|:---|:---|
|1:1 관계 (One-to-One)|하나의 엔티티가 다른 엔티티와 1:1로 매핑됨|@OneToOne|
|1:N 관계 (One-to-Many)|하나의 엔티티가 여러 개의 엔티티와 관계를 가짐|@OneToMany|
|N:1 관계 (Many-to-One)|여러 개의 엔티티가 하나의 엔티티와 관계를 가짐|@ManyToOne|
|N:M 관계 (Many-to-Many)|여러 개의 엔티티가 여러 개의 엔티티와 관계를 맺음|@ManyToMany|

------------
### 1:1 관계 (One-to-One)
1:1 관계는 한 개의 엔티티가 다른 하나의 엔티티와 연결될 때 사용된다.<br>
예를 들어, 사용자(User)와 사용자 상세 정보(UserDetail) 가 1:1 관계를 가질 수 있다.

User 엔티티
```java
import jakarta.persistence.*;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private UserDetail userDetail;

    // Getter, Setter 생략
}
```

UserDetail 엔티티
```java
import jakarta.persistence.*;

@Entity
public class UserDetail {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String address;

    private String phoneNumber;

    @OneToOne
    @JoinColumn(name = "user_id")
    private User user;

    // Getter, Setter 생략
}
```
```@OneToOne(mappedBy = "user")```miuramanamiseomanami : UserDetail 엔티티가 User 엔티티를 참조하는 양방향 관계를 나타냄.

----------------
### 1:N 관계 (One-to-Many) & N:1 관계 (Many-to-One)
1:N 관계에서는 한 개의 엔티티가 여러 개의 엔티티와 관계를 가질 수 있다.<br>
이 관계는 반대로 보면 N:1 관계이며, 다수의 엔티티가 하나의 엔티티를 참조하는 구조이다.

부모 엔티티 (User)
```java
import jakarta.persistence.*;
import java.util.List;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Post> posts;

    // Getter, Setter 생략
}
```

자식 엔티티 (Post)
```java
import jakarta.persistence.*;

@Entity
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    private String content;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    // Getter, Setter 생략
}
```
```@OneToMany(mappedBy = "user")``` : User 엔티티가 여러 개의 Post 엔티티를 가질 수 있음.<br>
```@ManyToOne``` : Post 엔티티는 User 엔티티를 참조함.<br>
```@JoinColumn(name = "user_id")``` : 외래 키(FK)를 지정하여 데이터베이스에서 관계를 맺음.

-------------------------
### N:M 관계 (Many-to-Many)
N:M 관계는 두 개의 엔티티가 서로 다대다(Many-to-Many)로 연결되는 구조이다.<br>
예를 들어, 학생(Student)과 강의(Course)는 여러 학생이 여러 강의를 수강할 수 있는 관계이다.
```java
Student 엔티티
import jakarta.persistence.*;
import java.util.Set;

@Entity
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses;

    // Getter, Setter 생략
}
```

Course 엔티티
```
import jakarta.persistence.*;
import java.util.Set;

@Entity
public class Course {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    @ManyToMany(mappedBy = "courses")
    private Set<Student> students;

    // Getter, Setter 생략
}
```
```@ManyToMany``` : 두 개의 엔티티가 서로 다대다 관계로 연결됨.<br>
```@JoinTable``` : 중간 테이블(student_course)을 생성하여 관계를 관리함.<br>
```mappedBy = "courses"``` : 연결된 반대편 엔티티에서 관계를 관리함.

---------------
### 연관 관계의 방향성
JPA에서는 관계를 **단방향(Bidirectional) 또는 양방향(Unidirectional)** 으로 설정할 수 있다.<br>
양방향 관계에서는 한쪽에서 데이터를 추가했을 때 **반대쪽에서도 자동으로 반영되도록 설정해야 한다.**<br>
하지만 **양방향 관계는 데이터의 복잡성을 증가시킬 수 있으므로 반드시 필요한 경우에만 사용**하는 것이 좋다.

---------------
#### 단방향 관계 예제
```java
@Entity
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;

    // Getter, Setter 생략
}
```
Order 엔티티에서 Customer 엔티티를 참조하지만, Customer는 Order를 모름.<br>

#### 양방향 관계 예제
```java
@Entity
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "customer")
    private List<Order> orders;

    // Getter, Setter 생략
}
```
Order가 Customer를 참조하고, Customer도 Order 리스트를 관리하는 양방향 관계.

----------
### 연관 관계 설정 시 주의할 점
**불필요한 양방향 관계를 피할 것**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단방향 관계로도 충분히 데이터를 조회할 수 있는 경우 양방향 관계를 사용하지 말아야 한다.

**지연 로딩(LAZY) 사용**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@OneToMany```와 같은 관계에서는 기본적으로 지연 로딩(LAZY Loading) 을 설정하는 것이 좋다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EAGER(즉시 로딩)를 사용하면 불필요한 데이터가 한 번에 로드될 수 있어 성능 문제가 발생할 수 있다.

**CascadeType과 orphanRemoval 사용**<br>
```CascadeType.ALL```을 설정하면 부모 엔티티 삭제 시 자식 엔티티도 함께 삭제되므로 데이터 관리가 편리해진다.<br>
```orphanRemoval = true```를 설정하면 부모와의 관계가 끊어진 자식 엔티티는 자동으로 삭제된다.

---------------
## FetchType과 성능 고려 사항
### FetchType의 개념
JPA에서 **연관 관계를 설정할 때, 데이터를 어떻게 가져올지(Fetching Strategy)를 결정하는 방식**을 제공하는데, 이를 ```FetchType```이라고 한다.<br>
```FetchType```을 설정하지 않으면 기본값이 자동으로 적용되지만, 연관 관계의 성격에 따라 적절한 ```FetchType```을 지정해야 성능을 최적화할 수 있다.

JPA에서는 다음과 같은 두 가지 방식의 ```FetchType```을 제공한다.

|FetchType|설명|
|:---|:---|
|EAGER|연관된 엔티티를 즉시 로딩 (즉, 한 번의 조회로 모두 가져옴)|
|LAZY|연관된 엔티티를 지연 로딩 (실제로 필요할 때 쿼리를 실행하여 가져옴)|

----------
### EAGER(즉시 로딩)
즉시 로딩(EAGER)은 **데이터를 조회할 때 연관된 엔티티도 한꺼번에 조회하는 방식**이다.<br>
즉, JPA가 ```JOIN```을 사용하여 관련된 엔티티를 한 번의 SQL 실행으로 가져온다.

예를 들어, User 엔티티가 여러 개의 Post 엔티티를 가지고 있을 때 ```FetchType.EAGER```를 설정하면,
User 엔티티를 조회할 때 자동으로 Post 엔티티까지 함께 조회된다.
```java
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "user", fetch = FetchType.EAGER)
    private List<Post> posts;
}
```
이렇게 설정하면 User 엔티티를 조회할 때, 연관된 Post 엔티티도 **JOIN 쿼리로 함께 가져온다.**<br>
즉, 다음과 같은 SQL이 실행된다.
```
SELECT u.id, u.name, p.id, p.title, p.content
FROM user u
LEFT JOIN post p ON u.id = p.user_id
WHERE u.id = ?;
```
-----------
### EAGER 로딩의 문제점
EAGER 로딩은 처음부터 필요한 데이터들을 모두 가져와 **즉시 사용 가능한 상태로 만들어 준다는 장점**이 있다.<br>
하지만 **모든 관계에서 EAGER 로딩을 사용하면 불필요한 데이터를 가져오는 문제**가 발생할 수 있다.

#### 문제 1: 불필요한 JOIN 연산
연관된 데이터가 많을수록 불필요한 ```JOIN``` 연산이 많아져 쿼리 성능이 저하될 수 있다.<br>
특히 1:N 관계에서 **부모 엔티티(User)를 조회할 때 자식 엔티티(Post)까지 항상 불러와야 한다면, 불필요한 데이터 조회가 발생할 가능성이 크다.**

#### 문제 2: N+1 문제
EAGER 로딩을 사용하면 N+1 문제가 발생할 수 있다.<br>
즉, **기본 데이터를 가져오기 위한 1번의 쿼리와, 각 데이터에 대한 추가적인 N개의 쿼리가 실행되는 현상**이 발생할 수 있다.

예를 들어, 여러 개의 User 데이터를 조회하는 상황을 가정하면 다음과 같은 쿼리가 실행될 수 있다.
```
SELECT * FROM user; -- 1번 실행
SELECT * FROM post WHERE user_id = 1; -- N번 실행
SELECT * FROM post WHERE user_id = 2;
SELECT * FROM post WHERE user_id = 3;
...
```
결과적으로 **사용자가 많아질수록 데이터베이스 부하가 커질 수 있다.**<br>
따라서, **반드시 필요한 경우가 아니라면 EAGER 로딩을 피해야 한다.**

-------------
### LAZY(지연 로딩)
지연 로딩(LAZY)은 **필요할 때만 데이터를 가져오는 방식**이다.<br>
즉, **객체가 처음 로드될 때 연관된 엔티티를 즉시 불러오지 않고, 실제로 필요할 때 쿼리를 실행하여 가져온다.**
```java
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Post> posts;
}
```
이렇게 설정하면, **User를 조회할 때 Post 데이터를 가져오지 않는다.**<br>
대신 posts 필드에 접근하는 순간, Post 데이터를 조회하는 쿼리가 실행된다.
```
User user = entityManager.find(User.class, 1L); // User만 조회
List<Post> posts = user.getPosts(); // 여기서 Post를 조회하는 SQL 실행
```
이때 실행되는 SQL은 다음과 같다.
```
SELECT * FROM user WHERE id = 1; -- 첫 번째 쿼리 실행
SELECT * FROM post WHERE user_id = 1; -- posts 필드 접근 시 실행
```
----------
### LAZY 로딩의 장점
LAZY 로딩을 사용하면 **필요한 시점에만 데이터를 가져오기 때문에, 불필요한 데이터 조회를 줄일 수 있다.**<br>
즉, 연관된 엔티티가 많더라도 **필요한 데이터만 가져와 성능을 최적화할 수 있다.**<br>
+ 불필요한 데이터 조회를 줄여 성능 최적화 가능
+ N+1 문제를 최소화할 수 있음
+ 대량의 데이터 로딩 시 성능 개선 가능

그러나 잘못 사용하면 성능 문제를 유발할 수도 있다.<br>
예를 들어, Lazy 로딩된 데이터가 반복적으로 호출되면, 그때마다 추가적인 쿼리가 실행되어 성능이 저하될 수 있다.<br>
이런 문제를 방지하기 위해 JOIN FETCH를 사용하여 한 번의 쿼리로 필요한 데이터를 가져오는 방법이 있다.

-----------
### LAZY 로딩 + JOIN FETCH 사용
LAZY 로딩을 사용하되, 필요한 데이터는 ```JOIN FETCH```를 사용하여 한 번에 조회할 수 있다.
```
@Query("SELECT u FROM User u JOIN FETCH u.posts WHERE u.id = :id")
User findUserWithPosts(@Param("id") Long id);
```
이렇게 하면, User 엔티티를 조회할 때 연관된 Post 데이터도 한 번의 쿼리로 가져올 수 있다.
```
SELECT u.*, p.*
FROM user u
JOIN post p ON u.id = p.user_id
WHERE u.id = ?;
```
이 방법을 사용하면 LAZY 로딩이면서도 N+1 문제를 방지할 수 있다.

----------
#### FetchType 설정 시 고려할 사항
**기본적으로는 FetchType.LAZY를 사용해야 한다.**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;불필요한 데이터 로딩을 방지하고 성능을 최적화할 수 있다.

**EAGER 로딩을 무분별하게 사용하지 말아야 한다.**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;쿼리 성능 저하 및 N+1 문제가 발생할 가능성이 크다.

**데이터가 반드시 필요한 경우, JOIN FETCH를 사용해야 한다.**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;필요한 경우 한 번의 쿼리로 데이터를 가져오는 것이 효율적이다.

**컬렉션 관계(1:N, N:M)에서는 LAZY가 기본값이다.**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컬렉션을 EAGER로 설정하면, 불필요한 JOIN이 발생할 가능성이 크다.<br>

**단일 엔티티 관계(1:1, N:1)에서는 기본값을 신중히 설정해야 한다.**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본적으로는 LAZY를 권장하지만, 정말 자주 사용되는 관계라면 EAGER로 설정할 수도 있다.

-----------
## Cascade 옵션과 데이터 삭제 처리
### Cascade 옵션의 개념
JPA에서 Cascade(영속성 전이) 는 부모 엔티티의 작업(저장, 삭제 등)이 자식 엔티티에도 영향을 미치도록 설정하는 기능이다.<br>
즉, 부모 엔티티가 변경될 때, 연관된 자식 엔티티에도 자동으로 같은 작업이 적용된다.

Cascade 옵션은 다음과 같은 경우에 유용하다.
+ 부모 엔티티와 자식 엔티티가 함께 저장되거나 삭제되어야 할 때
+ 자식 엔티티가 부모 엔티티에 완전히 종속될 때
+ 부모 엔티티에서 데이터 변경 시, 자식 엔티티에도 같은 작업을 적용할 때

--------------
### Cascade 옵션의 종류
JPA에서 제공하는 ```CascadeType``` 옵션은 다음과 같다.
|CascadeType|설명|
|:---|:---|
|ALL|부모 엔티티의 모든 변경 사항이 자식 엔티티에도 적용됨.|
|PERSIST|부모 엔티티 저장 시 자식 엔티티도 자동으로 저장됨.|
|MERGE|부모 엔티티 변경 시 자식 엔티티도 함께 병합됨.|
|REMOVE|부모 엔티티 삭제 시 자식 엔티티도 함께 삭제됨.|
|REFRESH|부모 엔티티 갱신 시 자식 엔티티도 함께 갱신됨.|
|DETACH|부모 엔티티가 detach() 될 때 자식도 detach 됨.|

------------
### CascadeType.ALL
```CascadeType.ALL```을 설정하면 부모 엔티티의 모든 작업이 자식 엔티티에도 적용된다.<br>
즉, 부모 엔티티가 **저장, 수정, 삭제, 병합, detach** 될 때 자식 엔티티도 동일한 작업이 수행된다.
```java
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<Post> posts = new ArrayList<>();
}
```
이렇게 설정하면 **User 엔티티를 저장하거나 삭제할 때 Post 엔티티도 자동으로 저장/삭제**된다.
```java
User user = new User();
user.setName("홍길동");

Post post1 = new Post("첫 번째 글", user);
Post post2 = new Post("두 번째 글", user);

user.getPosts().add(post1);
user.getPosts().add(post2);

entityManager.persist(user);  // user 저장 시 posts도 자동 저장됨
```
이때 실행되는 SQL은 다음과 같다.
```sql
INSERT INTO user (name) VALUES ('홍길동');
INSERT INTO post (title, user_id) VALUES ('첫 번째 글', 1);
INSERT INTO post (title, user_id) VALUES ('두 번째 글', 1);
```
주의점:<br>
```CascadeType.ALL```을 사용하면 부모 엔티티 삭제 시 자식 엔티티도 자동 삭제되므로 실수로 데이터가 손실될 위험이 있다.<br>

따라서, 자식 엔티티가 독립적으로 존재할 필요가 있다면 ALL을 사용하지 않는 것이 좋다.

-----------
### CascadeType.PERSIST
```CascadeType.PERSIST```를 설정하면 부모 엔티티를 저장할 때만 자식 엔티티도 자동으로 저장된다.
```java
@OneToMany(mappedBy = "user", cascade = CascadeType.PERSIST)
private List<Post> posts = new ArrayList<>();
```
이렇게 설정하면 **부모를 저장할 때 자식도 저장되지만, 부모가 삭제될 때 자식이 자동 삭제되지 않는다.**
```java
User user = new User();
user.setName("김철수");

Post post = new Post("안녕하세요", user);
user.getPosts().add(post);

entityManager.persist(user); // post도 자동 저장됨
```
### CascadeType.REMOVE
```CascadeType.REMOVE```를 설정하면 부모 엔티티가 삭제될 때 자식 엔티티도 자동으로 삭제된다.
```java
@OneToMany(mappedBy = "user", cascade = CascadeType.REMOVE)
private List<Post> posts = new ArrayList<>();
```
이렇게 설정하면, User 엔티티를 삭제할 때, 연관된 Post 엔티티도 자동으로 삭제된다.
```java
User user = entityManager.find(User.class, 1L);
entityManager.remove(user); // user 삭제 시 post도 삭제됨
```
이때 실행되는 SQL은 다음과 같다.
```sql
DELETE FROM post WHERE user_id = 1;
DELETE FROM user WHERE id = 1;
```
주의점:<br>
```REMOVE```를 사용할 경우, 부모를 삭제할 때 자식 엔티티도 삭제되므로 실수로 데이터가 손실될 위험이 있다.<br>

만약 자식 데이터는 유지하고 싶다면 ```CascadeType.REMOVE``` 대신 별도로 삭제 쿼리를 실행하는 방법을 고려해야 한다.

--------
### CascadeType.MERGE
```CascadeType.MERGE```를 설정하면 부모 엔티티를 변경할 때, 자식 엔티티도 자동으로 변경된다.
```java
@OneToMany(mappedBy = "user", cascade = CascadeType.MERGE)
private List<Post> posts = new ArrayList<>();
```
```java
User user = entityManager.find(User.class, 1L);
user.setName("변경된 사용자");

for (Post post : user.getPosts()) {
    post.setTitle("변경된 제목");
}

entityManager.merge(user); // user와 post가 함께 업데이트됨
```
이때 실행되는 SQL은 다음과 같다.
```sql
UPDATE user SET name = '변경된 사용자' WHERE id = 1;
UPDATE post SET title = '변경된 제목' WHERE user_id = 1;
```
주의점:<br>
```MERGE```는 데이터를 수정할 때 자동으로 반영되지만, 삭제 작업에는 적용되지 않는다.

-------
### CascadeType.REFRESH
```CascadeType.REFRESH```를 설정하면 부모 엔티티를 갱신할 때 자식 엔티티도 자동으로 갱신된다.
```java
@OneToMany(mappedBy = "user", cascade = CascadeType.REFRESH)
private List<Post> posts = new ArrayList<>();
```
```java
User user = entityManager.find(User.class, 1L);
entityManager.refresh(user); // user가 DB에서 다시 조회될 때, posts도 함께 갱신됨
```
이때 실행되는 SQL은 다음과 같다.
```sql
SELECT * FROM user WHERE id = 1;
SELECT * FROM post WHERE user_id = 1;
```
주의점:<br>
```REFRESH```는 데이터를 강제로 새로고침하는 역할을 하므로, 자주 사용할 필요는 없다.

---------------
### CascadeType.DETACH
```CascadeType.DETACH```를 설정하면 부모 엔티티가 detach 될 때, 자식 엔티티도 detach 된다.
```java
@OneToMany(mappedBy = "user", cascade = CascadeType.DETACH)
private List<Post> posts = new ArrayList<>();
```
```java
User user = entityManager.find(User.class, 1L);
entityManager.detach(user); // user와 posts가 영속성 컨텍스트에서 제거됨
```
이렇게 하면, user 엔티티와 연관된 posts도 함께 detach 되어 JPA의 관리 대상에서 벗어나게 된다.<br>
즉, 이후 변경 사항이 있어도 DB에 반영되지 않는다.

-----------
### Cascade 옵션 선택 가이드
**자식이 독립적으로 존재할 필요가 없다면** → ```CascadeType.ALL```<br>
**부모 저장 시 자식도 자동 저장되도록 하려면** → ```CascadeType.PERSIST```
**부모 삭제 시 자식도 함께 삭제해야 한다면** → ```CascadeType.REMOVE```
**부모가 변경될 때 자식도 함께 반영해야 한다면** → ```CascadeType.MERGE```
**부모 엔티티를 강제로 새로고침해야 한다면** → ```CascadeType.REFRESH```
**부모가 detach될 때 자식도 detach 되어야 한다면** → ```CascadeType.DETACH```

-----------
## 트랜잭션 관리
### 트랜잭션의 개념
트랜잭션의 정의
트랜잭션(Transaction)은 데이터베이스에서 논리적인 작업 단위를 의미한다.
즉, 하나의 트랜잭션은 여러 개의 데이터 조작 작업을 하나로 묶어 원자성을 보장하는 개념이다.

트랜잭션의 핵심 목표는 데이터의 무결성과 일관성을 유지하는 것이다.
만약 여러 개의 작업이 수행되는 도중 하나라도 실패하면, 전체 트랜잭션을 롤백(Rollback) 하여 데이터베이스를 원래 상태로 되돌린다.

트랜잭션의 특징: ACID 원칙
트랜잭션은 ACID(Atomicity, Consistency, Isolation, Durability) 원칙을 따라야 한다.

원칙	설명
원자성(Atomicity)	모든 작업이 하나의 단위로 실행되며, 일부만 성공하는 상태는 없음.
일관성(Consistency)	트랜잭션이 성공적으로 완료되면 데이터베이스는 일관된 상태를 유지해야 함.
격리성(Isolation)	여러 트랜잭션이 동시에 실행될 때 서로 영향을 미치지 않아야 함.
지속성(Durability)	트랜잭션이 완료되면 변경 사항이 영구적으로 저장되어야 함.
트랜잭션의 필요성
트랜잭션이 없으면 다음과 같은 문제들이 발생할 수 있다.

데이터 손실
여러 개의 SQL 문이 실행되다가 중간에 장애가 발생하면 일부만 저장되고 일부는 손실될 수 있다.
데이터 불일치
한 사용자가 데이터를 변경하는 동안 다른 사용자가 같은 데이터를 조회하면 데이터가 일관되지 않을 수 있다.
데이터 무결성 위반
한 트랜잭션에서 여러 개의 SQL 연산이 수행될 때, 일부만 성공하면 데이터 무결성이 깨질 가능성이 있다.
트랜잭션 예제
다음은 송금(이체) 시스템에서 트랜잭션이 필요한 이유를 설명하는 예제이다.

public void transferMoney(Long senderId, Long receiverId, int amount) {
    Account sender = accountRepository.findById(senderId).orElseThrow();
    Account receiver = accountRepository.findById(receiverId).orElseThrow();

    sender.withdraw(amount);
    receiver.deposit(amount);

    accountRepository.save(sender);
    accountRepository.save(receiver);
}
위 코드를 보면 송금하는 과정에서 두 개의 데이터베이스 업데이트 작업이 필요하다.

sender 계좌에서 withdraw(amount) 실행 (출금)
receiver 계좌에서 deposit(amount) 실행 (입금)
두 계좌 정보를 accountRepository.save()를 통해 저장
만약 출금은 성공했지만 입금 과정에서 예외가 발생하면, 데이터가 불일치한 상태가 된다.
즉, sender의 돈은 줄었지만 receiver의 돈은 증가하지 않는 문제가 발생할 수 있다.

트랜잭션을 적용한 예제
위 문제를 해결하려면 모든 작업을 하나의 트랜잭션으로 묶고, 중간에 오류가 발생하면 롤백해야 한다.

import org.springframework.transaction.annotation.Transactional;

@Transactional
public void transferMoney(Long senderId, Long receiverId, int amount) {
    Account sender = accountRepository.findById(senderId).orElseThrow();
    Account receiver = accountRepository.findById(receiverId).orElseThrow();

    sender.withdraw(amount);
    receiver.deposit(amount);

    accountRepository.save(sender);
    accountRepository.save(receiver);
}
이제 @Transactional 애노테이션을 적용하면 다음과 같은 동작을 수행한다.

transferMoney() 메서드가 실행되면 하나의 트랜잭션이 시작된다.
withdraw()와 deposit()이 실행되면서 데이터가 변경된다.
accountRepository.save()를 통해 데이터베이스에 저장되지만, 모든 작업이 성공해야만 반영된다.
만약 중간에 예외가 발생하면 자동으로 롤백(Rollback)되어 원래 상태로 복구된다.
트랜잭션이 필요한 주요 상황
Spring Boot 애플리케이션에서 트랜잭션이 필요한 대표적인 경우는 다음과 같다.

여러 개의 테이블을 동시에 변경할 때
예: 주문을 생성하면서 동시에 재고를 감소시키는 경우
일괄 업데이트(배치 연산)를 실행할 때
예: 특정 조건에 맞는 다수의 데이터를 한 번에 변경하는 경우
중간에 예외 발생 시 모든 작업을 롤백해야 할 때
예: 사용자 회원가입을 처리하면서, 이메일 인증을 실패하면 회원정보를 삭제해야 하는 경우
동시에 여러 사용자가 동일한 데이터를 변경할 때
예: 하나의 게시글에 대한 좋아요(Like) 수를 여러 사용자가 동시에 증가시키는 경우
트랜잭션과 성능 고려
트랜잭션은 데이터의 무결성을 유지하는 데 필수적이지만, 잘못 사용하면 성능 저하를 초래할 수 있다.
다음과 같은 사항을 고려하여 적절하게 사용하는 것이 중요하다.

트랜잭션 유지 시간을 최소화할 것

트랜잭션이 길어질수록 데이터베이스에 락(Lock)이 걸릴 가능성이 높아진다.
트랜잭션 안에서는 최소한의 작업만 수행하고 빠르게 종료해야 한다.
트랜잭션 범위를 최소화할 것

모든 메서드에 트랜잭션을 적용하면 불필요한 데이터 롤백이 발생할 수 있다.
DB 변경이 필요한 비즈니스 로직에만 적용하는 것이 좋다.
읽기 전용 작업에서는 트랜잭션을 최소화할 것

@Transactional(readOnly = true)를 사용하면 데이터 변경이 없는 조회 쿼리에서 성능을 최적화할 수 있다.
@Transactional(readOnly = true)
public List<User> getAllUsers() {
    return userRepository.findAll();
}
위처럼 설정하면 데이터 변경이 발생하지 않으며,
JPA 내부에서 불필요한 쓰기 락이 발생하지 않도록 최적화된다.

5.2. @Transactional 애노테이션
@Transactional의 개념
Spring에서 트랜잭션을 관리하기 위해 가장 많이 사용하는 애노테이션이 @Transactional이다.
이 애노테이션은 하나의 메서드를 트랜잭션 단위로 묶어 주는 역할을 하며, 해당 메서드가 성공적으로 실행되면 자동으로 커밋(commit) 되고, 중간에 예외가 발생하면 롤백(rollback) 된다.

@Transactional 애노테이션의 적용 위치
Spring에서는 @Transactional을 클래스나 메서드 레벨에서 선언할 수 있다.

클래스 레벨에서 선언
클래스의 모든 메서드에 트랜잭션이 적용된다.
import org.springframework.transaction.annotation.Transactional;

@Transactional
@Service
public class AccountService {
    public void deposit(Long accountId, int amount) {
        // 입금 로직
    }

    public void withdraw(Long accountId, int amount) {
        // 출금 로직
    }
}
메서드 레벨에서 선언
특정 메서드에만 트랜잭션을 적용할 수 있다.
@Service
public class AccountService {
    @Transactional
    public void transferMoney(Long senderId, Long receiverId, int amount) {
        // 송금 로직
    }
}
이처럼 메서드 레벨에서 선언하면 해당 메서드가 실행될 때만 트랜잭션이 적용된다.

@Transactional의 주요 속성
@Transactional 애노테이션은 다양한 속성을 통해 트랜잭션의 동작을 제어할 수 있다.

속성명	설명	기본값
propagation	트랜잭션 전파 방식 지정	REQUIRED
isolation	트랜잭션 격리 수준 설정	DEFAULT
readOnly	읽기 전용 트랜잭션 여부 설정	false
rollbackFor	특정 예외 발생 시 롤백 처리	RuntimeException 및 Error
noRollbackFor	특정 예외가 발생해도 롤백하지 않음	없음
각 속성에 대한 자세한 설명은 아래에서 다룬다.

1) propagation (트랜잭션 전파 방식)
트랜잭션 전파(Propagation)는 이미 실행 중인 트랜잭션이 있을 때 새로운 트랜잭션을 어떻게 처리할 것인지를 결정하는 속성이다.
Spring은 다음과 같은 전파 유형을 제공한다.

전파 유형	설명
REQUIRED	기본값. 기존 트랜잭션이 있으면 참여, 없으면 새로 생성
REQUIRES_NEW	기존 트랜잭션이 있어도 무시하고 항상 새로운 트랜잭션을 생성
SUPPORTS	기존 트랜잭션이 있으면 참여, 없으면 트랜잭션 없이 실행
NOT_SUPPORTED	트랜잭션 없이 실행
MANDATORY	반드시 기존 트랜잭션이 있어야 하며, 없으면 예외 발생
NEVER	트랜잭션 없이 실행하며, 기존 트랜잭션이 있으면 예외 발생
NESTED	기존 트랜잭션 내부에서 별도의 트랜잭션을 생성하여 실행
예제:

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void createAccount() {
    // 항상 새로운 트랜잭션에서 실행됨
}
2) isolation (트랜잭션 격리 수준)
트랜잭션 격리 수준은 동시에 여러 트랜잭션이 실행될 때 데이터 일관성을 유지하기 위한 설정이다.

격리 수준	설명
DEFAULT	기본 설정 (데이터베이스 설정을 따름)
READ_UNCOMMITTED	다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있음 (Dirty Read 가능)
READ_COMMITTED	다른 트랜잭션에서 커밋된 데이터만 읽을 수 있음 (Dirty Read 방지)
REPEATABLE_READ	같은 트랜잭션 내에서 동일한 데이터를 조회하면 항상 같은 결과 반환 (Non-repeatable Read 방지)
SERIALIZABLE	가장 엄격한 격리 수준, 동시 실행 방지 (성능 저하)
예제:

@Transactional(isolation = Isolation.REPEATABLE_READ)
public void processOrder() {
    // 동일한 데이터를 여러 번 읽어도 항상 같은 값을 보장
}
3) readOnly (읽기 전용 트랜잭션)
읽기 전용 트랜잭션을 설정하면 데이터 변경이 불가능하며, 단순 조회 성능이 최적화된다.

예제:

@Transactional(readOnly = true)
public List<User> getAllUsers() {
    return userRepository.findAll();
}
위 메서드는 데이터 변경이 발생하지 않는 읽기 전용 트랜잭션을 사용한다.
이 설정을 통해 불필요한 쓰기 락(write lock) 을 방지하고 성능을 향상시킬 수 있다.

4) rollbackFor (특정 예외 발생 시 롤백)
기본적으로 @Transactional은 RuntimeException과 Error가 발생했을 때만 롤백한다.
하지만 rollbackFor 속성을 사용하면 체크 예외(Checked Exception) 발생 시에도 롤백을 수행할 수 있다.

예제:

@Transactional(rollbackFor = Exception.class)
public void processPayment() throws Exception {
    // 체크 예외(Exception) 발생 시에도 롤백됨
}
이렇게 설정하면 Exception이 발생해도 롤백이 수행된다.

5) noRollbackFor (특정 예외 발생 시 롤백하지 않음)
특정 예외가 발생해도 롤백하지 않도록 설정할 수도 있다.

예제:

@Transactional(noRollbackFor = CustomException.class)
public void updateOrder() throws CustomException {
    // CustomException 발생 시 롤백되지 않음
}
위 코드에서는 CustomException이 발생해도 롤백되지 않으며, 데이터 변경이 유지된다.

@Transactional의 동작 방식
Spring의 @Transactional 애노테이션은 AOP(Aspect-Oriented Programming) 기반으로 동작한다.
즉, 프록시(Proxy) 객체를 생성하여 트랜잭션을 자동으로 관리한다.

트랜잭션이 적용되는 방식은 다음과 같다.

트랜잭션 시작
@Transactional이 선언된 메서드가 실행되면 새로운 트랜잭션이 시작된다.
비즈니스 로직 실행
메서드 내의 SQL 쿼리들이 실행된다.
정상 완료 시 커밋
예외 없이 메서드가 종료되면 자동으로 commit() 실행
예외 발생 시 롤백
RuntimeException 또는 지정된 예외 발생 시 자동으로 rollback() 실행
5.3. 트랜잭션 전파와 격리 수준
트랜잭션 전파(Propagation)
트랜잭션 전파(Propagation)는 하나의 메서드가 실행될 때 기존 트랜잭션이 있는 경우 이를 어떻게 처리할 것인지를 결정하는 설정이다.
Spring에서는 여러 개의 트랜잭션이 존재할 때 이를 제어하기 위해 7가지 전파 수준을 제공한다.

전파 수준	설명
REQUIRED	기본값. 기존 트랜잭션이 있으면 참여하고, 없으면 새 트랜잭션 생성
REQUIRES_NEW	기존 트랜잭션을 무시하고 항상 새로운 트랜잭션을 생성
SUPPORTS	기존 트랜잭션이 있으면 참여하고, 없으면 트랜잭션 없이 실행
NOT_SUPPORTED	트랜잭션 없이 실행 (기존 트랜잭션이 있으면 잠시 중단)
MANDATORY	반드시 기존 트랜잭션이 있어야 하며, 없으면 예외 발생
NEVER	트랜잭션 없이 실행해야 하며, 기존 트랜잭션이 있으면 예외 발생
NESTED	기존 트랜잭션 내부에서 별도의 트랜잭션을 실행
1) REQUIRED (기본값)
기본 전파 방식으로, 기존 트랜잭션이 있으면 참여하고, 없으면 새로운 트랜잭션을 생성한다.

@Transactional(propagation = Propagation.REQUIRED)
public void processOrder() {
    // 기존 트랜잭션이 있으면 해당 트랜잭션 내에서 실행
    // 없으면 새로운 트랜잭션이 생성됨
}
기존 트랜잭션이 있다면 재사용된다.
기존 트랜잭션이 없을 경우, 새로운 트랜잭션이 생성된다.
2) REQUIRES_NEW
항상 새로운 트랜잭션을 생성하며, 기존 트랜잭션이 있더라도 무시하고 별도의 트랜잭션을 실행한다.

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void createUser() {
    // 항상 새로운 트랜잭션을 생성하여 실행됨
}
기존 트랜잭션이 존재하더라도 무시하고 독립적인 트랜잭션을 실행한다.
독립적으로 실행되므로 이전 트랜잭션이 롤백되어도 영향을 받지 않는다.
주로 로그 저장 또는 이력 관리 등에 사용된다.
3) SUPPORTS
트랜잭션이 있으면 참여하고, 없으면 트랜잭션 없이 실행된다.

@Transactional(propagation = Propagation.SUPPORTS)
public void logActivity() {
    // 기존 트랜잭션이 있으면 참여하고, 없으면 트랜잭션 없이 실행됨
}
기존 트랜잭션이 존재하면 참여한다.
기존 트랜잭션이 없으면 트랜잭션 없이 실행된다.
읽기 전용 메서드에 적합하다.
4) NOT_SUPPORTED
트랜잭션을 사용하지 않고 실행하며, 기존 트랜잭션이 있으면 이를 일시적으로 중단한다.

@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void fetchLargeData() {
    // 기존 트랜잭션이 있더라도 트랜잭션 없이 실행됨
}
기존 트랜잭션이 있으면 일시적으로 중단하고 실행된다.
트랜잭션이 필요하지 않은 대용량 데이터 조회 등에 적합하다.
5) MANDATORY
반드시 기존 트랜잭션이 존재해야 하며, 없으면 예외를 발생시킨다.

@Transactional(propagation = Propagation.MANDATORY)
public void updateAccountBalance() {
    // 기존 트랜잭션이 없으면 예외 발생
}
기존 트랜잭션이 없으면 예외 발생 (TransactionRequiredException).
기존 트랜잭션이 있을 경우, 해당 트랜잭션에서 실행된다.
6) NEVER
트랜잭션 없이 실행해야 하며, 기존 트랜잭션이 있으면 예외가 발생한다.

@Transactional(propagation = Propagation.NEVER)
public void processNonTransactionalTask() {
    // 기존 트랜잭션이 있으면 예외 발생
}
기존 트랜잭션이 존재하면 IllegalTransactionStateException 발생.
트랜잭션이 필요 없는 메서드에서 사용된다.
7) NESTED
기존 트랜잭션이 있으면 별도의 중첩된 트랜잭션을 생성하고, 없으면 새로운 트랜잭션을 생성한다.

@Transactional(propagation = Propagation.NESTED)
public void nestedTransactionExample() {
    // 부모 트랜잭션 내에서 별도의 트랜잭션으로 실행됨
}
기존 트랜잭션 내에서 별도의 트랜잭션이 실행됨.
부모 트랜잭션이 롤백되면, 중첩된 트랜잭션도 롤백된다.
트랜잭션 격리 수준 (Isolation)
트랜잭션 격리 수준(Isolation)은 동시에 여러 트랜잭션이 실행될 때 데이터 일관성을 유지하는 방식을 정의한다.
Spring에서는 다음과 같은 4가지 격리 수준을 지원한다.

격리 수준	설명
DEFAULT	기본 설정 (데이터베이스 설정을 따름)
READ_UNCOMMITTED	다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있음 (Dirty Read 가능)
READ_COMMITTED	다른 트랜잭션에서 커밋된 데이터만 읽을 수 있음 (Dirty Read 방지)
REPEATABLE_READ	동일한 데이터를 여러 번 읽어도 항상 같은 값을 보장 (Non-repeatable Read 방지)
SERIALIZABLE	가장 엄격한 격리 수준, 동시 실행 방지 (성능 저하)
1) READ_UNCOMMITTED
Dirty Read(더티 리드) 허용: 다른 트랜잭션에서 커밋되지 않은 데이터도 읽을 수 있다.
데이터 불일치 가능성이 높으며, 가장 낮은 수준의 격리를 제공한다.
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void readUncommittedExample() {
    // 다른 트랜잭션에서 커밋되지 않은 데이터도 읽을 수 있음
}
2) READ_COMMITTED (기본값)
Dirty Read 방지: 다른 트랜잭션에서 커밋된 데이터만 읽을 수 있다.
대부분의 관계형 데이터베이스에서 기본적으로 사용되는 설정이다.
@Transactional(isolation = Isolation.READ_COMMITTED)
public void readCommittedExample() {
    // 커밋된 데이터만 읽을 수 있음
}
3) REPEATABLE_READ
Non-repeatable Read 방지: 같은 데이터를 여러 번 조회해도 값이 변하지 않는다.
MySQL에서 기본적으로 사용되는 설정이다.
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void repeatableReadExample() {
    // 동일한 데이터를 여러 번 읽어도 같은 값 보장
}
4) SERIALIZABLE
가장 엄격한 격리 수준으로, 동시 실행을 방지한다.
트랜잭션 간 충돌이 없지만 성능이 저하될 가능성이 크다.
@Transactional(isolation = Isolation.SERIALIZABLE)
public void serializableExample() {
    // 가장 높은 수준의 데이터 일관성 유지
}
6. DTO와 데이터 반환 방식
6.1. DTO(Data Transfer Object)의 개념
DTO(Data Transfer Object)는 데이터 전송을 위한 객체로, 애플리케이션 내부에서 데이터를 이동할 때 사용된다. 일반적으로 계층 간의 데이터 전달을 목적으로 하며, 도메인 모델(Entity)과 분리된다.

DTO와 Entity의 차이점
DTO는 주로 컨트롤러와 서비스 계층 간의 데이터 교환을 위해 사용되며, Entity는 데이터베이스와 직접적으로 매핑되는 객체이다. 이 두 객체는 목적과 역할이 다르므로 분리하는 것이 좋다.

구분	DTO (Data Transfer Object)	Entity (JPA Entity)
목적	클라이언트와 데이터 교환	데이터베이스와 매핑
역할	응답 및 요청 데이터를 포함	데이터 저장 및 조작
변경 가능 여부	클라이언트 요청에 따라 가변적	데이터베이스 설계에 따라 고정적
위치	컨트롤러 ↔ 서비스 계층 간 사용	데이터베이스 ↔ 애플리케이션 간 사용
보안	민감한 데이터 제외 가능	모든 필드가 포함될 가능성이 있음
DTO를 사용하는 이유
보안성 강화: Entity를 직접 노출하면 불필요한 데이터까지 노출될 위험이 있음.
유연성 제공: 클라이언트의 요구에 맞게 DTO를 커스텀할 수 있음.
계층 간 명확한 책임 분리: Service 계층에서 Entity를 다루고, Controller 계층에서는 DTO를 다룸으로써 역할이 구분됨.
성능 최적화: Entity에는 필요 없는 컬럼이 포함될 수 있으므로, DTO를 활용하여 필요한 데이터만 클라이언트로 전달 가능.
DTO 예제 코드
DTO는 주로 데이터를 담기 위한 단순한 클래스이며, @Getter, @Setter, @AllArgsConstructor 등을 활용하여 생성된다.

public class UserDto {
    private String name;
    private String email;

    public UserDto(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }
}
이 DTO는 클라이언트에게 사용자 정보(name, email)만 전달하고, 민감한 데이터(예: 비밀번호)는 제외할 수 있다.

Entity와 DTO를 변환하는 방법
Entity와 DTO는 서로 변환이 필요하다. 이를 위해 수동 또는 자동 변환 방법을 사용할 수 있다.

수동 변환
public class UserService {
    public UserDto convertToDto(User user) {
        return new UserDto(user.getName(), user.getEmail());
    }
}
자동 변환 (ModelMapper 활용)
ModelMapper modelMapper = new ModelMapper();
UserDto userDto = modelMapper.map(user, UserDto.class);
학습자의 사고를 돕기 위한 질문
DTO와 엔티티(Entity)의 차이점은 무엇인가?

계층 간 데이터 전달의 역할을 고려하여 답해보라.
왜 클라이언트에 직접 엔티티를 반환하는 것이 위험할 수 있는가?

보안성과 응답 데이터의 최적화를 고려하여 답해보라.
6.2. Entity를 그대로 반환하지 않는 이유
Spring Boot 애플리케이션에서 데이터베이스와 직접적으로 연결된 Entity를 API 응답으로 반환하지 않는 것이 일반적이다. Entity를 그대로 반환하는 것은 여러 가지 문제를 일으킬 수 있으며, 이를 방지하기 위해 DTO(Data Transfer Object)를 사용한다.

Entity를 직접 반환하는 경우의 문제점
Entity를 직접 반환하면 다음과 같은 문제가 발생할 수 있다.

보안 문제

Entity에는 클라이언트에게 노출해서는 안 되는 민감한 정보(예: 비밀번호, 사용자 권한, 내부 관리 ID 등) 가 포함될 수 있다.
API가 그대로 Entity를 반환하면, 원하지 않는 데이터가 그대로 외부로 노출될 가능성이 높아진다.
데이터 일관성 문제

Entity는 데이터베이스의 테이블과 1:1 매핑되며, 모든 컬럼이 포함될 수밖에 없다.
클라이언트에 불필요한 정보를 제공하게 되며, 이를 관리하기 어렵다.
예를 들어, 사용자 정보를 반환할 때 비밀번호 필드까지 포함된다면 보안상의 치명적인 문제가 발생할 수 있다.
불필요한 데이터 전송

Entity는 일반적으로 많은 필드를 가지며, API 응답으로 필요하지 않은 데이터를 포함할 수 있다.
네트워크 트래픽을 최소화하기 위해 필요한 데이터만을 선택적으로 전달하는 것이 중요하다.
예를 들어, User 엔티티에 20개의 필드가 있다고 가정하면, 클라이언트에 필요한 필드는 name과 email뿐일 수도 있다. 하지만 Entity를 반환하면 모든 필드가 전송된다.
JPA 연관관계에 따른 성능 문제 (Lazy Loading)

Entity는 연관된 객체를 포함할 수 있으며, 이를 직접 반환할 경우 Lazy Loading과 같은 성능 문제가 발생할 수 있다.
예를 들어, User 엔티티가 List<Order>를 가지고 있을 때, User 객체를 반환하면 Order 목록도 함께 조회될 수 있다.
특히, JSON 직렬화 과정에서 무한 루프(Circular Reference) 문제가 발생할 수도 있다.
API 응답의 유연성 부족

Entity는 데이터베이스 설계에 의존적이지만, 클라이언트에서 필요한 응답 형태는 다를 수 있다.
예를 들어, User 엔티티에는 firstName과 lastName 필드가 있지만, 클라이언트에서는 fullName이 필요할 수도 있다.
DTO를 사용하면 이러한 요구사항을 쉽게 반영할 수 있다.
Entity를 직접 반환하는 경우의 예제
만약 Entity를 직접 반환하면 다음과 같은 문제가 발생할 수 있다.

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserRepository userRepository;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
    }
}
위 코드는 User Entity를 그대로 반환하는데, 여기서 발생할 수 있는 문제는 다음과 같다.

불필요한 데이터 노출: 비밀번호 필드 등 민감한 정보까지 클라이언트에 반환될 수 있다.
JPA의 Lazy Loading 문제: User 객체가 다른 연관 객체(orders 등)를 포함하면, Hibernate가 추가적인 쿼리를 실행할 수 있다.
JSON 직렬화 문제: 순환 참조(예: User → Orders → User)가 발생할 수 있다.
DTO를 사용한 안전한 데이터 반환
이러한 문제를 해결하기 위해 DTO를 사용하여 필요한 데이터만 변환해서 반환하는 것이 일반적이다.

User 엔티티
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;
    private String password; // 민감한 정보

    // Getter, Setter 생략
}
User DTO
public class UserDto {
    private String name;
    private String email;

    public UserDto(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // Getter, Setter 생략
}
DTO 변환 후 반환하는 API
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public UserDto getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }
}
Service에서 Entity를 DTO로 변환
@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public UserDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return new UserDto(user.getName(), user.getEmail());
    }
}
이제 API 응답에는 name과 email만 포함되며, 비밀번호와 같은 민감한 데이터는 클라이언트에 노출되지 않는다.

DTO를 사용할 때의 장점
보안 강화: 민감한 데이터 노출 방지.
API 응답의 유연성 제공: 클라이언트 요구에 맞게 응답을 조정할 수 있음.
불필요한 데이터 전송 방지: 필요한 데이터만 반환하여 네트워크 트래픽 절감.
JPA Lazy Loading 문제 해결: DTO로 변환하는 시점에서 필요한 데이터만 가져옴.
학습자의 사고를 돕기 위한 질문
데이터베이스 엔티티를 그대로 반환했을 때 생길 수 있는 보안 문제는 무엇인가?

민감한 데이터 노출 가능성을 고려하여 답해보라.
엔티티의 변경 사항이 API 응답에 미치는 영향을 최소화하려면 어떤 방법을 사용해야 하는가?

API 안정성과 유지보수성을 고려하여 답해보라.
6.3. DTO 변환 방식
Spring Boot에서 DTO(Data Transfer Object) 를 변환하는 방법에는 여러 가지가 있으며, 이 방식들은 각기 다른 장점과 단점을 가지고 있다. 기본적으로 DTO 변환은 Entity를 DTO로 변환하거나 DTO를 Entity로 변환하는 작업을 의미한다. 이러한 변환을 효과적으로 수행하기 위해서는 수동 변환, 라이브러리를 활용한 자동 변환, 또는 Spring의 기능을 활용하는 방법들이 있다.

1. 수동 변환 방식 (Hand-coded Mapping)
수동 변환 방식은 직접 코드로 Entity와 DTO 간의 변환을 수행하는 방법이다. 이 방식은 단순하고 직관적이지만, 변환할 필드가 많아질 경우 코드가 복잡해질 수 있다.

Entity 클래스
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    private String password; // DTO에는 포함하지 않음

    // Getter, Setter 생략
}
DTO 클래스
public class UserDto {
    private String name;
    private String email;

    public UserDto(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // Getter, Setter 생략
}
Service에서 변환 처리
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public UserDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return new UserDto(user.getName(), user.getEmail()); // 수동 변환
    }
}
이 방법은 직관적이고 간단하지만, 변환할 DTO의 수가 많아지거나, 변환 로직이 복잡해질 경우 코드가 중복될 가능성이 크다.

2. ModelMapper를 활용한 자동 변환
ModelMapper는 Entity와 DTO 간의 매핑을 자동으로 수행하는 라이브러리이다. 이를 사용하면 반복되는 변환 코드를 줄일 수 있다.

ModelMapper Bean 등록
@Configuration
public class ModelMapperConfig {
    @Bean
    public ModelMapper modelMapper() {
        return new ModelMapper();
    }
}
Service에서 ModelMapper 사용
@Service
public class UserService {
    private final UserRepository userRepository;
    private final ModelMapper modelMapper;

    public UserService(UserRepository userRepository, ModelMapper modelMapper) {
        this.userRepository = userRepository;
        this.modelMapper = modelMapper;
    }

    public UserDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return modelMapper.map(user, UserDto.class); // 자동 변환
    }
}
ModelMapper의 장점
개발자가 직접 매핑 코드를 작성하지 않아도 되어 코드가 간결해진다.
객체 간 매핑 규칙을 정의할 수도 있다.
ModelMapper의 단점
내부적으로 리플렉션(Reflection)을 사용하므로, 성능이 다소 떨어질 수 있다.
필드 이름이 다르면 자동 매핑이 동작하지 않으며, 명시적인 매핑 규칙을 설정해야 한다.
3. MapStruct를 활용한 컴파일 타임 변환
MapStruct는 ModelMapper와 유사하지만 컴파일 타임에 변환 코드를 생성한다. 따라서 성능이 더 우수하며, 실무에서도 많이 사용된다.

의존성 추가
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct</artifactId>
    <version>1.5.3.Final</version>
</dependency>
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-processor</artifactId>
    <version>1.5.3.Final</version>
    <scope>provided</scope>
</dependency>
DTO 변환 Mapper 인터페이스 생성
@Mapper(componentModel = "spring")
public interface UserMapper {
    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    UserDto toDto(User user);
}
Service에서 MapStruct 활용
@Service
public class UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;

    public UserService(UserRepository userRepository, UserMapper userMapper) {
        this.userRepository = userRepository;
        this.userMapper = userMapper;
    }

    public UserDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return userMapper.toDto(user); // 자동 변환
    }
}
MapStruct의 장점
컴파일 타임에 변환 코드가 생성되므로 성능이 우수하다.
리플렉션을 사용하지 않으므로 실행 속도가 빠르다.
복잡한 매핑 로직을 직접 설정할 수 있다.
MapStruct의 단점
인터페이스를 따로 작성해야 하므로 초기 설정이 번거로울 수 있다.
DTO 변환 로직이 동적으로 변경되는 경우 적용하기 어렵다.
4. Spring Projection을 활용한 DTO 반환
Spring Data JPA에서는 @Query를 이용하여 필요한 데이터만 조회하고, DTO로 직접 변환하는 기능을 제공한다.

DTO를 위한 Projection 인터페이스
public interface UserProjection {
    String getName();
    String getEmail();
}
Repository에서 Projection을 활용한 조회
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u.name AS name, u.email AS email FROM User u WHERE u.id = :id")
    UserProjection findUserById(@Param("id") Long id);
}
Controller에서 Projection을 사용하여 반환
@RestController
@RequestMapping("/users")
public class UserController {
    private final UserRepository userRepository;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @GetMapping("/{id}")
    public UserProjection getUser(@PathVariable Long id) {
        return userRepository.findUserById(id);
    }
}
Spring Projection의 장점
SQL 실행 단계에서 필요한 데이터만 조회하므로 성능이 우수하다.
DTO 변환이 필요 없이 바로 인터페이스를 통해 결과를 반환할 수 있다.
Spring Projection의 단점
복잡한 변환 로직을 구현하기 어렵다.
Repository에 의존적인 구조가 된다.
실습 문제
문제 1: DTO 클래스 작성
아래 요구사항을 만족하는 UserDTO 클래스를 작성하시오.

필드:
id (Long)
name (String)
email (String)
User 엔티티에서 필요한 데이터만 전달하도록 설계할 것.
문제 2: DTO 변환 메서드 작성
아래 요구사항을 만족하는 DTO 변환 메서드를 UserService에 추가하시오.

UserDTO를 반환하는 convertToDto(User user) 메서드 작성.
List<User>를 List<UserDTO>로 변환하는 convertToDtoList(List<User> users) 메서드 작성.
7. 데이터 처리 시 고려해야 할 실무 패턴
7.1. Service Layer에서의 비즈니스 로직 처리
Spring Boot에서 Service Layer(서비스 계층) 는 비즈니스 로직을 처리하는 핵심적인 계층이다.
이 계층은 Repository Layer(데이터 접근 계층)와 Controller Layer(웹 요청을 처리하는 계층) 사이에서 동작하며, 주요 역할은 다음과 같다.

비즈니스 로직을 구현하여 데이터 처리의 일관성을 유지.
Repository 계층과의 명확한 역할 분리를 통해 유지보수성을 높임.
트랜잭션 관리를 담당하여 데이터의 일관성을 보장.
1. Service Layer의 구조
Spring Boot 애플리케이션에서 Service Layer의 일반적인 구성 방식은 다음과 같다.

Controller → 클라이언트의 요청을 받고 Service를 호출함.
Service → 비즈니스 로직을 수행하며, Repository를 호출함.
Repository → 데이터베이스와 직접 상호작용함.
아래는 기본적인 구조를 나타낸 코드 예제이다.

@RestController
@RequestMapping("/users")
public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
        UserDto userDto = userService.getUserById(id);
        return ResponseEntity.ok(userDto);
    }
}
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public UserDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return new UserDto(user.getName(), user.getEmail());
    }
}
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
이러한 구조를 따르면 Controller는 요청을 전달하는 역할만 담당하며, Service는 비즈니스 로직을 실행하고, Repository는 데이터 저장소와 직접적인 작업을 수행하게 된다.

2. Service Layer에서의 역할 분리
Service Layer는 애플리케이션의 핵심 로직을 다루므로, 비즈니스 규칙을 정의하는 역할과 데이터 접근을 분리해야 한다.

Controller에서 비즈니스 로직을 실행하면 안 됨

잘못된 코드:
@RestController
@RequestMapping("/users")
public class UserController {
    private final UserRepository userRepository;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return ResponseEntity.ok(new UserDto(user.getName(), user.getEmail()));
    }
}
문제점:
Controller가 Repository에 직접 접근하여 비즈니스 로직이 분리되지 않음.
비즈니스 로직이 중복될 가능성이 커짐 (다른 API에서도 동일한 로직을 사용할 경우, 중복 코드가 발생함).
Service에서 데이터 가공 및 로직 수행

올바른 코드:
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public UserDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return new UserDto(user.getName(), user.getEmail());
    }
}
장점:
비즈니스 로직이 Service 계층에서 관리되므로, 유지보수가 용이함.
Controller는 요청을 받아서 전달하는 역할만 수행하고, 비즈니스 로직을 담당하지 않음.
다른 API에서도 동일한 로직을 재사용할 수 있음.
3. Service Layer에서의 트랜잭션 관리
Service 계층에서 트랜잭션을 관리하면 데이터의 일관성을 보장할 수 있다.
Spring에서는 @Transactional을 활용하여 트랜잭션을 쉽게 관리할 수 있다.

@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public void updateUser(Long id, String name, String email) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        user.setName(name);
        user.setEmail(email);
    }
}
@Transactional의 역할
트랜잭션이 시작되면, 모든 작업이 하나의 단위로 실행됨.
오류 발생 시 모든 작업이 롤백됨, 즉, 데이터의 무결성이 유지됨.
Service 계층에서 트랜잭션을 관리하는 것이 일반적이며, Repository 계층에서 관리하는 것은 지양해야 함.
4. Service Layer에서의 예외 처리
Service Layer에서 예외 처리를 적절히 수행하면 안정적인 애플리케이션 운영이 가능하다.
예외 처리는 체계적인 예외 메시지 전달과 오류 발생 시 적절한 조치를 수행하는 것이 중요하다.

예외 처리 적용 전

@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public UserDto getUserById(Long id) {
        User user = userRepository.findById(id).get(); // NoSuchElementException 발생 가능
        return new UserDto(user.getName(), user.getEmail());
    }
}
문제점:
.get()을 사용할 경우 데이터가 없으면 NoSuchElementException이 발생하여 프로그램이 중단될 수 있음.
예외 메시지가 명확하지 않음.
예외 처리 적용 후

@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public UserDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User with id " + id + " not found"));
        return new UserDto(user.getName(), user.getEmail());
    }
}

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
개선된 점:
orElseThrow()를 사용하여 명확한 예외 메시지를 제공.
사용자 정의 예외(UserNotFoundException)를 활용하여 보다 직관적인 예외 처리 가능.
5. Service Layer에서의 데이터 검증
데이터를 저장하거나 수정할 때는 입력값을 검증하는 것이 중요하다.
Spring Boot에서는 @Valid와 @Validated를 사용하여 요청 데이터를 검증할 수 있다.

DTO에서 검증 규칙 정의

public class UserDto {
    @NotBlank
    private String name;

    @Email
    @NotBlank
    private String email;
}
@NotBlank → 빈 문자열을 허용하지 않음.
@Email → 이메일 형식인지 검증.
Service에서 데이터 검증 적용

@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public UserDto createUser(@Valid UserDto userDto) {
        User user = new User();
        user.setName(userDto.getName());
        user.setEmail(userDto.getEmail());
        userRepository.save(user);
        return new UserDto(user.getName(), user.getEmail());
    }
}
7.2. 페이징 및 대량 데이터 처리
데이터가 많아지면 한 번에 모든 데이터를 불러오는 것은 성능 문제를 야기할 수 있다.
특히 대량의 데이터가 포함된 테이블을 조회할 경우, 서버의 부하 증가와 응답 속도 저하가 발생할 수 있다.
이를 방지하기 위해 페이징 처리 및 대량 데이터 처리 기법을 적용하는 것이 필수적이다.

1. 페이징(Pagination)의 개념
페이징이란 데이터를 일정 크기의 단위로 나누어 한 번에 일부 데이터만 조회하는 방식을 의미한다.
Spring Data JPA는 Pageable 인터페이스를 통해 간단한 페이징 처리를 지원한다.

페이징을 사용하면 다음과 같은 이점이 있다:
한 번에 불러오는 데이터의 양을 제한하여 성능을 향상시킴.
클라이언트에서 원하는 데이터만 조회할 수 있어, 네트워크 트래픽을 줄일 수 있음.
대량 데이터를 처리할 때 데이터베이스 부하를 최소화할 수 있음.
2. Spring Data JPA의 페이징 처리
Spring Data JPA에서는 Pageable 인터페이스와 Page<T> 객체를 활용하여 페이징 처리를 쉽게 구현할 수 있다.

기본적인 페이징 메서드
Spring Data JPA의 JpaRepository를 사용하면 자동으로 페이징을 지원하는 메서드를 생성할 수 있다.

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Page<User> findAll(Pageable pageable);
}
Page<User>: 페이징된 데이터를 담은 객체로 반환됨.
Pageable: 페이징 정보를 전달하는 객체.
PageRequest.of(page, size, sort) 메서드를 사용하여 페이징 요청을 생성할 수 있음.
Controller에서 페이징 적용
아래 코드는 페이징을 지원하는 사용자 목록 API를 구현한 예제이다.

@RestController
@RequestMapping("/users")
public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping
    public ResponseEntity<Page<UserDto>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        Page<UserDto> users = userService.getUsers(PageRequest.of(page, size, Sort.by("name").ascending()));
        return ResponseEntity.ok(users);
    }
}
@RequestParam을 이용하여 page(페이지 번호)와 size(페이지 크기)를 동적으로 지정 가능.
Sort.by("name").ascending()을 사용하여 이름 기준 오름차순 정렬.
Service에서 페이징 처리
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public Page<UserDto> getUsers(Pageable pageable) {
        return userRepository.findAll(pageable)
                .map(user -> new UserDto(user.getName(), user.getEmail()));
    }
}
API 호출 예시
GET /users?page=1&size=5
위 요청을 보내면 1페이지에서 5개의 사용자 데이터를 가져옴.

반환 데이터 예시 (JSON)
{
  "content": [
    {
      "name": "홍길동",
      "email": "hong@example.com"
    },
    {
      "name": "이순신",
      "email": "lee@example.com"
    }
  ],
  "pageable": {
    "pageNumber": 1,
    "pageSize": 5
  },
  "totalPages": 10,
  "totalElements": 50
}
"content": 실제 데이터 목록.
"totalPages": 전체 페이지 수.
"totalElements": 전체 데이터 개수.
3. 성능을 고려한 페이징 전략
페이징을 적용할 때 성능 최적화를 고려해야 할 요소들이 있다.

(1) OFFSET이 많은 경우 성능 저하 문제
LIMIT OFFSET을 사용하면 데이터가 많을 때 성능이 저하될 수 있음.
OFFSET이 클수록 불필요한 데이터를 더 많이 조회해야 하기 때문.
예를 들어, LIMIT 10 OFFSET 10000을 실행하면 10000개의 데이터를 무시한 후 10개를 조회해야 하므로 비효율적.
(2) Keyset Pagination (ID 기반 페이징)
WHERE 절을 활용하여 특정 키 값 이후의 데이터를 가져오는 방식.
성능이 좋으며, 특히 인덱스가 걸려 있는 컬럼을 기준으로 하면 효과적.
예제:

SELECT * FROM users WHERE id > 100 ORDER BY id ASC LIMIT 10;
ID가 100보다 큰 데이터를 10개만 가져옴.
OFFSET을 사용하지 않아 불필요한 데이터를 건너뛸 필요 없음.
4. 대량 데이터 처리(Bulk Processing)
페이징뿐만 아니라 대량의 데이터를 한 번에 처리해야 하는 경우도 있다.

(1) 벌크 INSERT
한 번에 여러 개의 데이터를 삽입하여 성능을 개선.
Spring Data JPA에서 기본적으로 지원하지 않으므로, EntityManager를 활용해야 함.
@PersistenceContext
private EntityManager entityManager;

@Transactional
public void bulkInsertUsers(List<User> users) {
    int batchSize = 50;
    for (int i = 0; i < users.size(); i++) {
        entityManager.persist(users.get(i));
        if (i % batchSize == 0) {
            entityManager.flush();
            entityManager.clear();
        }
    }
}
batchSize = 50: 50개씩 처리하여 메모리 사용량을 최적화.
flush()와 clear()를 사용하여 트랜잭션 메모리 과부하 방지.
(2) 벌크 UPDATE
JPA에서는 일반적인 save()를 사용할 경우, 엔티티를 하나씩 업데이트해야 함.
하지만 @Modifying 애노테이션을 사용하면 대량 데이터를 한 번에 업데이트할 수 있음.
@Modifying
@Query("UPDATE User u SET u.status = 'INACTIVE' WHERE u.lastLogin < :date")
int deactivateInactiveUsers(@Param("date") LocalDate date);
특정 날짜 이전에 로그인한 유저를 비활성화.
반환값은 영향을 받은 행(row) 개수.
(3) 벌크 DELETE
많은 데이터를 삭제할 때 DELETE FROM 쿼리를 활용.
@Modifying
@Query("DELETE FROM User u WHERE u.status = 'INACTIVE'")
int deleteInactiveUsers();
@Modifying을 사용하여 일괄 삭제를 수행.
5. 대량 데이터 처리 시 주의할 점
트랜잭션 크기 조절

너무 큰 단위의 데이터 처리는 메모리 부담이 커지고 트랜잭션 시간이 길어질 위험이 있음.
적절한 배치 크기를 설정 (batchSize = 50 정도).
인덱스 최적화

대량 데이터를 검색할 때는 WHERE 절에 사용될 컬럼에 인덱스를 추가하는 것이 중요.
ID나 날짜 필드를 기반으로 하는 검색은 효율적인 인덱스 활용이 가능.
읽기 전용 트랜잭션 활용

조회 시 @Transactional(readOnly = true)를 사용하면 불필요한 쓰기 락을 방지하여 성능이 향상됨.
@Transactional(readOnly = true)
public List<User> getActiveUsers() {
    return userRepository.findByStatus("ACTIVE");
}
학습자의 사고를 돕기 위한 질문
대량 데이터를 한 번에 조회하는 것이 성능에 어떤 영향을 미치는가?

데이터베이스 부하와 애플리케이션 성능을 고려하여 답해보라.
페이징을 사용할 때 offset과 limit을 활용하면 어떤 장점이 있는가?

쿼리 최적화를 고려하여 답해보라.
실습 문제
문제 1: 페이징 처리 적용
아래 요구사항을 만족하는 UserRepository 메서드를 작성하시오.

Page<User>를 반환하는 findAll(Pageable pageable) 메서드 구현.
PageRequest.of(int page, int size, Sort.by("name"))를 사용하여 페이지 요청.
문제 2: 조건 기반 페이징 처리
아래 요구사항을 만족하는 코드를 작성하시오.

UserRepository에서 특정 나이 이상의 사용자만 페이징 처리하여 조회하는 메서드를 추가.
Page<User>를 반환하는 findByAgeGreaterThan(int age, Pageable pageable) 구현.
7.3. 캐싱을 활용한 성능 최적화
캐싱(Cache)은 자주 사용되는 데이터를 빠르게 접근할 수 있도록 메모리에 저장하는 기술이다.
Spring Boot에서는 Spring Cache 기능을 사용하여 간단하게 캐싱을 적용할 수 있다.
캐싱을 활용하면 데이터베이스 조회 횟수를 줄이고 성능을 개선할 수 있지만,
올바르게 사용하지 않으면 데이터 정합성 문제나 메모리 과부하를 초래할 수 있다.

1. 캐싱의 개념과 필요성
캐싱(Cache)이란?

자주 사용하는 데이터를 메모리(RAM) 또는 빠른 저장소에 저장하여 조회 속도를 향상시키는 기술.
DB 또는 외부 API 호출을 최소화하여 애플리케이션 성능을 개선.
Spring Boot에서 캐싱이 필요한 경우

반복적으로 동일한 데이터를 조회해야 하는 경우
→ 예: 인기 상품 목록, 사용자 프로필 정보 등.
데이터 변경이 자주 발생하지 않는 경우
→ 예: 공통 코드 리스트, 지역 정보 등.
데이터베이스 부하를 줄여야 하는 경우
→ 동일한 쿼리가 반복 실행되는 경우 캐싱을 적용하면 성능이 향상됨.
2. Spring Boot에서 캐싱 적용 방법
Spring Boot는 Spring Cache 기능을 제공하며, 이를 사용하면 간단하게 캐싱을 적용할 수 있다.
기본적으로 캐싱은 메모리를 사용하여 데이터를 저장하지만, Redis 같은 외부 캐시 저장소와 연동할 수도 있다.

(1) 캐싱 설정 추가
Spring Boot에서 캐싱을 사용하려면 @EnableCaching 애노테이션을 추가해야 한다.

@Configuration
@EnableCaching
public class CacheConfig {
}
@EnableCaching: Spring Cache를 활성화하는 설정.
(2) @Cacheable을 이용한 캐싱
캐싱을 적용하려면 @Cacheable 애노테이션을 사용하면 된다.

@Service
public class ProductService {
    private final ProductRepository productRepository;

    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @Cacheable(value = "products", key = "#id")
    public Product getProductById(Long id) {
        System.out.println("Fetching product from DB...");
        return productRepository.findById(id).orElseThrow(() -> new RuntimeException("Product not found"));
    }
}
value = "products": "products"라는 캐시 공간을 사용.
key = "#id": id 값을 기준으로 캐싱.
메서드를 처음 호출하면 DB에서 데이터를 가져오지만, 이후 동일한 요청이 오면 캐시에서 반환.
(3) @CachePut을 이용한 캐시 갱신
@Cacheable은 캐시에 데이터가 없을 경우 저장하지만,
DB 값이 변경된 경우 즉시 캐시를 업데이트할 필요가 있다.
이때 @CachePut 을 사용하면 캐시를 자동으로 갱신할 수 있다.

@CachePut(value = "products", key = "#product.id")
public Product updateProduct(Product product) {
    return productRepository.save(product);
}
DB에 변경된 데이터를 저장하고, 동시에 캐시도 갱신.
(4) @CacheEvict을 이용한 캐시 삭제
캐싱된 데이터를 삭제해야 할 때는 @CacheEvict을 사용한다.
예를 들어, 상품이 삭제될 경우 캐시에서도 제거해야 한다.

@CacheEvict(value = "products", key = "#id")
public void deleteProduct(Long id) {
    productRepository.deleteById(id);
}
DB에서 데이터를 삭제하고, 동시에 캐시에서도 제거.
특정 키를 지정하지 않으면 전체 캐시가 삭제될 수도 있음.
(5) 전체 캐시 삭제
데이터가 변경될 경우, 특정 값뿐만 아니라 모든 캐시를 삭제해야 할 수도 있다.
이 경우 allEntries = true 옵션을 사용하면 된다.

@CacheEvict(value = "products", allEntries = true)
public void clearCache() {
    System.out.println("Clearing all product caches...");
}
"products" 캐시에 저장된 모든 데이터를 삭제.
3. 캐시 저장소 선택
Spring Boot에서는 다양한 캐시 저장소를 지원하며, 주로 사용되는 캐시 저장소는 다음과 같다:

캐시 저장소	특징
ConcurrentMapCache (기본)	Spring Boot 내장 메모리 캐시. 애플리케이션 재시작 시 캐시 삭제됨.
EhCache	자바 기반의 강력한 로컬 캐시.
Caffeine	성능이 뛰어난 고속 캐시.
Redis	분산 환경에서 사용 가능하며 영속성 지원.
Memcached	대규모 시스템에서 주로 사용되는 캐시 서버.
(1) 기본 캐시 (ConcurrentMapCache)
Spring Boot는 기본적으로 ConcurrentMapCache를 사용하여 캐싱을 관리한다.
하지만 애플리케이션이 종료되면 모든 캐시가 삭제되므로,
Redis 같은 외부 캐시 저장소를 사용하는 것이 일반적이다.

(2) Redis 캐시 연동
Redis는 속도가 빠르고, 클러스터링이 가능하며, 영속성이 보장되는 캐시 저장소이다.
Spring Boot에서 Redis를 캐시로 사용하려면 spring-boot-starter-data-redis 의존성을 추가해야 한다.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
그리고 Redis 설정을 추가한다.

@Configuration
@EnableCaching
public class RedisConfig {
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                        .entryTtl(Duration.ofMinutes(10))) // 10분간 캐싱 유지
                .build();
    }
}
Redis를 캐시 저장소로 설정.
데이터의 유효 기간(TTL)을 10분으로 설정하여 자동 삭제.
4. 캐싱의 장점과 단점
캐싱을 적용하면 큰 성능 향상을 기대할 수 있지만, 올바르게 사용하지 않으면 오히려 문제를 발생시킬 수 있다.

(1) 캐싱의 장점
데이터베이스 부하 감소 → 동일한 요청을 여러 번 수행하지 않아도 됨.
API 응답 속도 향상 → 캐시에서 바로 데이터를 가져올 수 있음.
서버 비용 절감 → 반복적인 쿼리 실행을 최소화.
(2) 캐싱의 단점
데이터 정합성 문제 → 캐시된 데이터가 오래되면 최신 데이터와 불일치가 발생할 수 있음.
메모리 사용량 증가 → 많은 데이터를 캐싱하면 메모리 과부하가 발생할 수 있음.
캐시 무효화 문제 → 필요할 때 정확히 캐시를 삭제하지 않으면, 오래된 데이터가 계속 반환될 수 있음.
5. 캐싱 적용 시 고려할 점
캐시 갱신 정책 설정

@CacheEvict, @CachePut을 적절히 사용하여 최신 데이터 유지.
TTL(Time To Live)을 설정하여 오래된 데이터가 자동 삭제되도록 설정.
캐시 저장소 선택

단일 서버: Caffeine, EhCache
분산 시스템: Redis, Memcached
적절한 캐시 크기 제한

너무 많은 데이터를 캐싱하면 메모리 부족 문제가 발생할 수 있음.
