# 프로젝트 구현
## 1. 프로젝트 환경 설정 및 구조 구성
## 프로젝트 초기화 및 의존성 설정
### Spring Boot 프로젝트 초기화란?
Spring Boot 프로젝트 초기화는 애플리케이션의 기본적인 틀을 생성하는 과정이다.<br>
이 과정에서 프로젝트의 구조를 잡고, 사용할 기술 스택을 결정하며, 필수적인 설정을 적용하게 된다.<br>
Spring Boot는 이러한 초기화 과정을 쉽게 수행할 수 있도록 Spring Initializr를 제공하며,<br>
이를 이용하면 몇 번의 클릭만으로 기본적인 프로젝트 구조와 의존성이 포함된 템플릿을 생성할 수 있다.

--------------
### Spring Initializr를 이용한 프로젝트 생성
Spring Initializr는 start.spring.io에서 제공하는 프로젝트 생성 도구로,<br>
웹 UI를 통해 필요한 라이브러리와 환경을 설정한 후, 이를 반영한 프로젝트를 다운로드할 수 있도록 지원한다.<br>
이제 Spring Initializr를 활용하여 프로젝트를 생성하는 과정을 하나씩 살펴보자.

---------------
### 1. Spring Initializr 웹사이트 접속
Spring Boot 프로젝트를 생성하려면, 먼저 Spring Initializr 웹사이트에 접속해야 한다.<br>
웹사이트에 접속하면 다양한 설정을 할 수 있는 UI가 제공되며, 여기서 프로젝트의 기본적인 정보를 입력할 수 있다.

### 2. 프로젝트 설정 선택
Spring Boot 프로젝트를 구성하기 위해 다음과 같은 설정을 선택해야 한다.

**Project: ```Maven``` 또는 ```Gradle```**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maven과 Gradle은 의존성 관리와 빌드를 담당하는 도구이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maven은 pom.xml 파일을 이용하여 정형화된 빌드 환경을 제공하는 반면,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gradle은 build.gradle을 이용하여 유연한 빌드 구성이 가능하다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;일반적으로 Maven이 더 직관적이며, 처음 Spring Boot를 접하는 개발자에게 적합하다.

**Language: ```Java```**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot는 Java, Kotlin, Groovy를 지원하지만, 대부분의 프로젝트는 Java로 개발된다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;따라서 기본적으로 Java를 선택하는 것이 일반적이다.

**Spring Boot Version: 3.x.x (최신 버전)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot는 지속적으로 업데이트되며, 안정적인 버전을 사용해야 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 3.x 버전은 Java 17 이상을 요구하므로, Java 버전도 이에 맞춰야 한다.

------------
### 3. 프로젝트 메타데이터 입력
프로젝트를 생성할 때는 기본적인 메타데이터를 입력해야 한다.<br>
이 정보는 프로젝트가 생성된 후 ```pom.xml``` 또는 ```build.gradle```에서 확인할 수 있다.

**Group: ```com.example```**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프로젝트의 그룹 ID로, 보통 도메인 형식으로 작성한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;예를 들어, 회사 도메인이 mycompany.com이라면 com.mycompany로 설정할 수 있다.

**Artifact: ```myproject```**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프로젝트의 이름을 지정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;생성된 프로젝트의 기본 폴더명이 된다.

**Name: ```myproject```**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프로젝트의 일반적인 이름을 의미한다.

**Package Name: ```com.example.myproject```**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 패키지 구조의 기본값을 설정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 값은 프로젝트의 기본 패키지 경로가 된다.

**Packaging: ```Jar```**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 프로젝트는 기본적으로 Jar 실행 파일을 생성한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;War는 웹 애플리케이션을 위한 패키징 방식으로, 별도로 WAS(Tomcat 등)를 설치해야 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot는 내장 Tomcat이 제공되므로 기본적으로 Jar를 선택하는 것이 일반적이다.

**Java Version: 17**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 3.x 버전부터는 Java 17 이상을 요구하므로, 최신 LTS 버전을 선택하는 것이 좋다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 17은 성능과 보안이 향상되었으며, 장기 지원(LTS)이 제공된다.

--------------------
### 4. 필수 의존성 추가
Spring Boot 프로젝트에서는 필요한 **라이브러리(의존성, dependencies)** 를 추가해야 한다.<br>
Spring Initializr에서 선택하면 자동으로 pom.xml(Maven) 또는 build.gradle(Gradle)에 포함된다.

**Spring Web**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot에서 웹 애플리케이션을 개발하기 위한 필수 라이브러리이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;내장된 Tomcat을 통해 Spring Boot 애플리케이션을 실행할 수 있도록 지원한다.

**Spring Boot DevTools**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;개발 편의를 위한 도구로, 코드 변경 시 자동으로 애플리케이션을 다시 로드하는 기능을 제공한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이를 통해 개발 중에 변경 사항을 즉시 확인할 수 있다.

**Lombok**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;반복적인 코드 작성을 줄여주는 라이브러리이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor``` 등의 어노테이션을 활용하여<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Getter, Setter, 생성자 등의 코드를 자동으로 생성할 수 있다.

**Spring Data JPA**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스 연동을 위한 ORM(Object Relational Mapping) 라이브러리이다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Entity, @Repository 등의 어노테이션을 활용하여<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스와 객체를 쉽게 매핑하고 조작할 수 있도록 지원한다.

**H2 Database**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;가볍고 메모리 기반으로 동작하는 데이터베이스로,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;개발 및 테스트 환경에서 빠르게 데이터 저장 및 조회가 가능하다.

----------------------
### 5. 프로젝트 다운로드 및 실행
모든 설정을 완료한 후 ```Generate``` 버튼을 클릭하면,<br>
해당 설정이 반영된 Spring Boot 프로젝트가 압축 파일(.zip) 형태로 다운로드된다.<br>
압축을 해제한 후 IntelliJ IDEA 또는 Eclipse에서 프로젝트를 불러오면 개발을 시작할 수 있다.

-----------------
### Spring Boot 프로젝트 생성 후 파일 구조
Spring Boot 프로젝트를 생성하면 기본적인 디렉터리 구조가 자동으로 생성된다.
```
myproject
├── src
│   ├── main
│   │   ├── java
│   │   │   └── com.example.myproject
│   │   │       ├── MyProjectApplication.java  # 메인 실행 파일
│   │   ├── resources
│   │       ├── application.properties  # 환경설정 파일
│   │       ├── static/  # 정적 리소스(css, js, images 등)
│   │       ├── templates/  # 템플릿(html, thymeleaf 등)
│   ├── test
│       ├── java
│       │   └── com.example.myproject
│       │       ├── MyProjectApplicationTests.java  # 테스트 파일
├── .gitignore
├── mvnw  # Maven Wrapper
├── mvnw.cmd
├── pom.xml  # Maven 의존성 및 설정 파일
```
이 구조에서 가장 중요한 파일은 MyProjectApplication.java 이다.<br>
이 파일은 Spring Boot 애플리케이션의 진입점(Entry Point) 으로, 프로젝트가 실행될 때 가장 먼저 실행되는 클래스이다.

```
package com.example.myproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyProjectApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyProjectApplication.class, args);
    }
}
```
```@SpringBootApplication``` 어노테이션은<br>
Spring Boot의 자동 설정(Auto Configuration)을 활성화하고,<br>
내장 웹 서버(Tomcat)를 실행하는 역할을 한다.

---------------
## 1-2. 프로젝트 디렉토리 및 패키지 구조 설계
Spring Boot 프로젝트를 개발할 때 올바른 디렉토리 및 패키지 구조를 설계하는 것은 유지보수성과 확장성을 높이는 핵심 요소이다.<br>
Spring Boot는 기본적으로 패키지 기반 컴포넌트 스캔(Component Scan) 방식을 사용하므로, 패키지 구조를 체계적으로 정리하는 것이 중요하다.

### Spring Boot의 기본 디렉토리 구조
Spring Boot 프로젝트를 생성하면 기본적으로 다음과 같은 디렉토리 구조를 가지게 된다.
```
myproject/
│── src/
│   ├── main/
│   │   ├── java/com/example/myproject/
│   │   │   ├── MyProjectApplication.java  <-- 애플리케이션 진입점
│   │   │   ├── controller/               <-- 컨트롤러 패키지
│   │   │   ├── service/                   <-- 서비스 패키지
│   │   │   ├── repository/                <-- 데이터 액세스 패키지
│   │   │   ├── domain/                    <-- 엔티티 패키지
│   │   │   ├── dto/                        <-- DTO 패키지
│   │   │   ├── config/                     <-- 환경 설정 패키지
│   │   │   ├── exception/                  <-- 예외 처리 패키지
│   │   ├── resources/
│   │   │   ├── application.yml  <-- 환경 설정 파일
│   │   │   ├── static/            <-- 정적 리소스 (HTML, CSS, JS)
│   │   │   ├── templates/         <-- 템플릿 엔진 (Thymeleaf, Freemarker 등)
│   ├── test/                     <-- 테스트 코드
│── pom.xml (Maven 프로젝트 설정 파일)
│── build.gradle (Gradle 프로젝트 설정 파일)
```
--------------------
### 패키지 구조 설계 원칙
Spring Boot에서 패키지를 설계할 때 계층형 아키텍처(Layered Architecture)를 기반으로 구조화하는 것이 일반적이다.<br>
이 방식은 애플리케이션을 역할별로 나누어 관리하기 쉽게 하고, 기능 간의 결합도를 낮추어 유지보수성을 높인다.

아래는 Spring Boot에서 많이 사용되는 패키지 구조 설계 방식이다.

**Controller (컨트롤러)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP 요청을 받아 적절한 서비스 계층을 호출하고, 응답을 반환하는 역할을 담당.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RestController, @RequestMapping 등을 활용하여 API 엔드포인트를 정의.

**Service (서비스)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비즈니스 로직을 처리하는 계층.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨트롤러에서 받은 요청을 검증하고, 필요한 데이터 처리를 수행한 후 결과를 반환.

**Repository (데이터 액세스)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스와의 연결을 담당하는 계층.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JpaRepository 또는 CrudRepository를 활용하여 CRUD 연산을 수행.

**Domain (엔티티)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터베이스 테이블과 매핑되는 엔티티 클래스가 포함되는 계층.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Entity, @Id, @GeneratedValue 등을 활용하여 데이터 모델을 정의.

**DTO (Data Transfer Object)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트와 서버 간 데이터 전송을 위한 객체.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;엔티티와 분리하여 데이터의 형식을 명확하게 지정.

**Config (환경 설정)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot의 설정 클래스들이 포함되는 패키지.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Configuration을 활용하여 설정 정보를 관리.

**Exception (예외 처리)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;애플리케이션 전역 예외 처리(@ControllerAdvice)를 포함하여 예외를 일괄 관리하는 패키지.<br>

-------------------
### Controller, Service, Repository 계층 간의 관계
각 계층은 아래와 같은 방식으로 서로 데이터를 주고받는다.
```
(Client)
    ↓
@Controller (API 요청 처리)
    ↓
@Service (비즈니스 로직 수행)
    ↓
@Repository (데이터베이스 액세스)
    ↓
(Database)
```
--------------
### 패키지 구조에 맞는 코드 예제
다음은 위의 패키지 구조를 적용한 기본적인 코드 예제이다.

Controller (UserController.java)
```java
package com.example.myproject.controller;

import com.example.myproject.dto.UserDto;
import com.example.myproject.service.UserService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping
    public List<UserDto> getAllUsers() {
        return userService.getAllUsers();
    }

    @PostMapping
    public UserDto createUser(@RequestBody UserDto userDto) {
        return userService.createUser(userDto);
    }
}
```

Service (UserService.java)
```java
package com.example.myproject.service;

import com.example.myproject.dto.UserDto;
import com.example.myproject.repository.UserRepository;
import com.example.myproject.domain.User;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<UserDto> getAllUsers() {
        return userRepository.findAll().stream()
                .map(user -> new UserDto(user.getId(), user.getName(), user.getEmail()))
                .collect(Collectors.toList());
    }

    public UserDto createUser(UserDto userDto) {
        User user = new User(userDto.getName(), userDto.getEmail());
        User savedUser = userRepository.save(user);
        return new UserDto(savedUser.getId(), savedUser.getName(), savedUser.getEmail());
    }
}
```

Repository (UserRepository.java)
```java
package com.example.myproject.repository;

import com.example.myproject.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```

Domain (User.java)
```java
package com.example.myproject.domain;

import jakarta.persistence.*;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;

    protected User() {}

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public Long getId() { return id; }
    public String getName() { return name; }
    public String getEmail() { return email; }
}
```

DTO (UserDto.java)
```java
package com.example.myproject.dto;

public class UserDto {
    private Long id;
    private String name;
    private String email;

    public UserDto(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    public Long getId() { return id; }
    public String getName() { return name; }
    public String getEmail() { return email; }
}
```
------------------
### Spring Boot의 패키지 스캔 원리
Spring Boot는 @SpringBootApplication이 선언된 클래스의 패키지를 기준으로<br>
하위 패키지를 자동으로 스캔(Component Scan)하여 빈(Bean)으로 등록한다.
```java
package com.example.myproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyProjectApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyProjectApplication.class, args);
    }
}
```
따라서 ```MyProjectApplication```이 위치한 ```com.example.myproject``` 패키지를 기준으로<br>
하위에 있는 controller, service, repository 패키지의 클래스들을 자동으로 감지하여 등록한다.

-------------
## 1.3. 환경 설정 파일 작성
Spring Boot 프로젝트에서는 환경 설정 파일을 활용하여 데이터베이스 연결 정보, 포트 번호, 로깅 설정, 외부 API 키 등의 다양한 설정을 관리할 수 있다.<br>
Spring Boot는 기본적으로 application.properties 또는 application.yml 두 가지 형식의 설정 파일을 지원한다.<br>
이 파일들은 프로젝트의 src/main/resources/ 디렉토리에 위치한다.

-----------
### 환경 설정 파일의 종류
**application.properties**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=value 형식의 설정 파일.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;간결하지만 계층 구조 표현이 어렵다.

**application.yml**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YAML 형식의 설정 파일.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;가독성이 좋고, 계층 구조 표현이 용이하다.

Spring Boot는 기본적으로 application.properties 또는 application.yml 파일을 자동으로 인식하여 적용한다.

------------------
### application.properties 예제
```
# 서버 기본 설정
server.port=8080

# 데이터베이스 연결 설정
spring.datasource.url=jdbc:mysql://localhost:3306/mydatabase
spring.datasource.username=root
spring.datasource.password=secret
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA 설정
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect

# 로깅 설정
logging.level.org.springframework=INFO
```

### application.yml 예제
```
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydatabase
    username: root
    password: secret
    driver-class-name: com.mysql.cj.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    database-platform: org.hibernate.dialect.MySQL8Dialect

logging:
  level:
    org.springframework: INFO
```
YAML 형식은 ```application.properties```에 비해 가독성이 뛰어나고, 계층 구조 표현이 용이하기 때문에<br>
대부분의 프로젝트에서는 ```application.yml```을 선호하는 경우가 많다.

----------------
### 다중 환경(Profile) 구성
Spring Boot는 환경에 따라 서로 다른 설정을 적용할 수 있도록 프로파일(Profile) 기능을 제공한다.<br>
이를 통해 개발(Development), 테스트(Test), 운영(Production) 환경별로 개별 설정을 유지할 수 있다.

프로파일을 적용하기 위해 다음과 같은 방법을 사용할 수 있다.

```
1. application.yml을 활용한 다중 환경 설정
spring:
  profiles:
    active: dev # 기본적으로 사용할 프로파일 설정
---
spring:
  config:
    activate:
      on-profile: dev # 개발 환경 설정
  datasource:
    url: jdbc:mysql://localhost:3306/dev_db
    username: dev_user
    password: dev_pass
    driver-class-name: com.mysql.cj.jdbc.Driver
---
spring:
  config:
    activate:
      on-profile: prod # 운영 환경 설정
  datasource:
    url: jdbc:mysql://prod-db-server:3306/prod_db
    username: prod_user
    password: prod_pass
    driver-class-name: com.mysql.cj.jdbc.Driver
```
위의 설정에서 ```spring.profiles.active=dev``` 로 지정하면 개발 환경(dev) 설정이 자동으로 적용된다.<br>
운영 환경에서는 ```spring.profiles.active=prod```로 변경하면 프로덕션 환경의 설정이 적용된다.

---------------------
### 환경 변수 또는 커맨드라인 인자를 활용한 프로파일 변경
Spring Boot 실행 시 특정 프로파일을 활성화할 수도 있다.

**환경 변수로 설정**<br>
```export SPRING_PROFILES_ACTIVE=prod```

**JVM 옵션을 이용한 실행**<br>
```java -jar myproject.jar --spring.profiles.active=prod```

**IDE에서 설정 (IntelliJ, Eclipse)**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행 설정에서 VM options 또는 Program arguments에 --spring.profiles.active=prod를 추가.

이러한 방식으로 개발, 테스트, 운영 환경에서 다른 설정을 적용할 수 있다.

----------------
### 외부 설정 파일을 활용한 환경 설정
Spring Boot는 application.yml 외에도 외부 설정 파일을 이용하여 설정을 관리할 수 있다.<br>
이를 통해 보안이 중요한 데이터베이스 비밀번호나 API 키 같은 정보를 별도의 파일에 저장할 수 있다.

**외부 환경 변수 파일(.env) 활용 예제**
```
# .env 파일
DB_URL=jdbc:mysql://localhost:3306/mydatabase
DB_USERNAME=root
DB_PASSWORD=secret
```
이후 application.yml에서 환경 변수를 활용하여 값을 설정할 수 있다.
```
spring:
  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
```
이 방식을 활용하면 설정 값을 코드에서 분리하여 보안성을 높일 수 있다.

------------------
### 설정 값 유효성 검증 및 기본 값 설정
Spring Boot에서는 환경 변수나 설정 값을 읽어올 때 기본 값을 설정할 수도 있다.

**기본값을 설정하는 방법**
```
spring:
  datasource:
    url: ${DB_URL:jdbc:mysql://localhost:3306/default_db} # 기본값 지정
    username: ${DB_USERNAME:default_user}
    password: ${DB_PASSWORD:default_pass}
```
위와 같이 설정하면 DB_URL 환경 변수가 설정되지 않았을 경우 ```jdbc:mysql://localhost:3306/default_db```를 사용하게 된다.

---------------------
### 로깅(Level) 설정 및 활용
Spring Boot에서 로깅 레벨을 설정하면 애플리케이션의 실행 로그를 조절할 수 있다.<br>
로깅 레벨은 TRACE → DEBUG → INFO → WARN → ERROR 순으로 상세한 로그를 출력한다.

**application.yml에서 로깅 레벨 설정**
```
logging:
  level:
    root: INFO
    org.springframework: DEBUG
    com.example.myproject: TRACE
```

**로그 출력 예제**
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class LoggingExampleService {
    private static final Logger logger = LoggerFactory.getLogger(LoggingExampleService.class);

    public void logMessage() {
        logger.trace("TRACE: 상세한 디버깅 로그");
        logger.debug("DEBUG: 개발 중 필요한 디버깅 로그");
        logger.info("INFO: 일반적인 실행 정보 로그");
        logger.warn("WARN: 주의해야 할 사항");
        logger.error("ERROR: 치명적인 오류 발생");
    }
}
```

------------------
### Spring Boot의 설정 파일 우선순위
Spring Boot는 여러 개의 환경 설정 파일을 적용할 경우 특정 우선순위에 따라 설정 값을 로드한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;커맨드라인 인자 (```--spring.profiles.active=prod```)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;환경 변수 (```SPRING_PROFILES_ACTIVE=prod```)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;application.yml (또는 application.properties)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot의 기본 설정 값

즉, 실행 시 JVM 옵션이나 환경 변수를 활용하면 기존 설정 파일보다 우선적으로 적용할 수 있다.

-------------------.
# 2. 데이터베이스 설계 및 연동
## 2.1. 데이터 모델링 및 엔티티 설계
데이터베이스를 설계하는 과정은 애플리케이션의 구조와 기능을 결정짓는 중요한 요소 중 하나이다.<br>
Spring Boot에서는 **JPA(Java Persistence API)** 를 활용하여 객체와 관계형 데이터베이스 간의 매핑을 수행할 수 있다.<br>
이를 통해 데이터베이스의 복잡한 SQL 쿼리 없이도 객체 지향적으로 데이터를 조작할 수 있다.

-------------
### 엔티티(Entity)란?
JPA에서 엔티티(Entity) 란 데이터베이스의 테이블(Table) 과 1:1로 매핑되는 클래스이다.<br>
즉, 애플리케이션에서 데이터를 객체로 관리할 수 있도록 지원하는 역할을 한다.

엔티티는 ```@Entity``` 어노테이션을 통해 선언되며, 일반적으로 데이터베이스의 테이블과 필드를 매핑하여 관리한다.

------------------
### 기본 엔티티 설계
아래는 User 엔티티를 정의하는 예제이다.
```java
import jakarta.persistence.*;

@Entity  // 해당 클래스가 데이터베이스의 테이블과 매핑됨을 의미
@Table(name = "users") // 매핑할 테이블명을 지정
public class User {

    @Id // 기본 키(Primary Key) 설정
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 자동 증가 (AUTO_INCREMENT)
    private Long id;

    @Column(nullable = false, length = 50) // null 허용 X, 최대 길이 50자
    private String name;

    @Column(unique = true, nullable = false, length = 100) // 중복 불가(unique), null 허용 X
    private String email;

    @Column(nullable = false)
    private String password;

    public User() { }

    public User(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }

    // Getter & Setter
    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```
위의 User 엔티티는 users 테이블과 매핑되며, 주요 컬럼들을 정의하였다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@Id```: 기본 키(Primary Key)로 사용될 필드를 명시한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@GeneratedValue(strategy = GenerationType.IDENTITY)```: MySQL의 AUTO_INCREMENT를 활용하여 자동 증가하는 기본 키를 설정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```@Column```: 필드의 제약 조건을 설정한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```nullable = false```: 필수 입력 필드로 지정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```length = n```: 최대 문자 길이 지정.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```unique = true```: 중복을 허용하지 않음.

-----------------
### 기본 키(Primary Key) 전략
JPA에서는 기본 키를 자동으로 생성하는 여러 가지 전략을 제공한다.
이 전략을 @GeneratedValue(strategy = GenerationType.XXX)를 통해 지정할 수 있다.

전략	설명
AUTO	데이터베이스에 맞춰 자동 선택 (기본값)
IDENTITY	AUTO_INCREMENT를 활용하여 자동 증가
SEQUENCE	데이터베이스의 시퀀스(Sequence) 를 활용
TABLE	키 값을 별도 테이블에서 관리
MySQL에서는 IDENTITY 전략을 주로 사용하며, PostgreSQL 등에서는 SEQUENCE 전략이 자주 사용된다.

다양한 필드 타입 매핑
JPA는 데이터베이스의 다양한 타입을 객체 필드로 매핑할 수 있도록 지원한다.
다음은 주요 데이터 타입과 그에 대응하는 JPA 매핑 방법이다.

자바 데이터 타입	JPA 필드 타입 예제	데이터베이스 타입 예제
String	@Column(length = 255)	VARCHAR(255)
int / Integer	@Column(nullable = false)	INTEGER
long / Long	@Column(nullable = false)	BIGINT
double / Double	@Column(nullable = false)	DOUBLE
boolean / Boolean	@Column(nullable = false)	BOOLEAN
LocalDate	@Column(nullable = false)	DATE
LocalDateTime	@Column(nullable = false)	DATETIME
기본 엔티티 설계 확장 - 생성일 및 수정일 관리
엔티티가 데이터베이스에 저장될 때, 생성일(created_at)과 수정일(updated_at)을 자동으로 관리해야 하는 경우가 많다.
Spring Boot에서는 @CreatedDate와 @LastModifiedDate 어노테이션을 활용하여 이를 자동화할 수 있다.

아래는 BaseEntity라는 공통 엔티티를 생성하여 User 엔티티에 적용하는 방법이다.

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@MappedSuperclass // 공통 필드를 정의한 상위 클래스
@EntityListeners(AuditingEntityListener.class) // 엔티티 변경 감지
public abstract class BaseEntity {

    @CreatedDate // 생성된 시간 자동 저장
    @Column(updatable = false) // 수정 불가
    private LocalDateTime createdAt;

    @LastModifiedDate // 수정될 때 자동 갱신
    private LocalDateTime updatedAt;

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
}
이제 User 엔티티에 BaseEntity를 상속하여 생성일과 수정일을 자동으로 관리할 수 있다.

@Entity
@Table(name = "users")
public class User extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String name;

    @Column(unique = true, nullable = false, length = 100)
    private String email;

    @Column(nullable = false)
    private String password;

    public User() { }

    public User(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }
}
이제 User 엔티티는 데이터가 생성될 때 createdAt, 수정될 때 updatedAt이 자동으로 반영된다.

엔티티 설정 반영을 위한 Spring Boot 설정
위의 @CreatedDate, @LastModifiedDate 등의 기능을 활성화하려면
Spring Boot의 JpaConfig에서 Auditing 기능을 활성화해야 한다.

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing // JPA Auditing 활성화
public class JpaConfig {
}
이 설정을 추가하면 BaseEntity에서 정의한 @CreatedDate, @LastModifiedDate가 정상적으로 동작하게 된다.

학습자의 사고를 돕기 위한 질문
@Entity 어노테이션을 사용하여 클래스를 엔티티로 만드는 이유는 무엇인가?

JPA와 엔티티 객체 간의 관계를 떠올려보라.
엔티티 클래스에서 @Id 어노테이션을 사용한 필드가 중요한 이유는 무엇인가?

기본 키 역할을 하며, 데이터베이스에서 레코드를 식별하는 방법에 대해 생각해보라.
@GeneratedValue를 사용하여 자동으로 키 값을 생성하는 이유는 무엇인가?

데이터베이스에서 기본 키를 자동으로 관리하는 방식에 대해 생각해보라.
실습 문제
문제 1: 엔티티 클래스 작성하기
다음 요구사항을 만족하는 User 엔티티 클래스를 작성하시오.

User 클래스는 id, name, email 필드를 갖는다.
id는 자동으로 생성되는 값이다.
name과 email은 각각 String 타입이다.
User 클래스에 대해 @Entity, @Id, @GeneratedValue 어노테이션을 사용한다.
문제 2: User 엔티티 클래스에 데이터 추가하기
다음 요구사항을 만족하는 User 엔티티 클래스를 작성하시오.

User 클래스는 id, username, password, email 필드를 갖는다.
password는 String 타입이고, 나머지 필드는 String 타입이다.
id는 자동으로 생성된다.
@Entity, @Id, @GeneratedValue 어노테이션을 사용한다.
2.2. JPA 및 Repository 설정
JPA(Java Persistence API)는 객체와 관계형 데이터베이스 간의 매핑을 가능하게 하는 ORM(Object Relational Mapping) 기술이다.
Spring Boot에서는 JPA를 사용하여 데이터베이스의 데이터를 쉽게 저장, 조회, 수정, 삭제할 수 있다.
이 과정에서 Repository 패턴을 사용하면 비즈니스 로직과 데이터 접근 계층을 분리할 수 있어 유지보수가 용이하다.

Spring Data JPA란?
Spring Data JPA는 Spring이 제공하는 JPA 기반의 데이터 접근 계층 구현을 단순화하는 라이브러리이다.
Spring Data JPA를 사용하면 기본적인 CRUD(Create, Read, Update, Delete) 기능을 별도의 구현 없이 사용할 수 있다.

Spring Data JPA의 주요 기능

기본적인 CRUD 메서드 제공 (findById, save, deleteById 등)
쿼리 메서드(Query Method) 지원 (findByEmail, findByNameLike 등)
JPQL 및 Native Query 지원
페이징 및 정렬(Paging & Sorting) 기능 제공
JpaRepository 인터페이스 활용
Spring Data JPA는 기본적으로 JpaRepository 인터페이스를 제공하며, 이를 사용하면 직접 SQL 쿼리를 작성하지 않고도 데이터베이스에 접근할 수 있다.

기본적인 Repository 인터페이스의 형태는 다음과 같다.

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email); // 이메일을 기준으로 사용자 조회
}
JpaRepository<User, Long>

첫 번째 제네릭(User)은 관리할 엔티티 타입을 의미한다.
두 번째 제네릭(Long)은 엔티티의 기본 키(PK) 타입을 의미한다.
기본적인 CRUD 메서드
Spring Data JPA가 제공하는 기본적인 CRUD 메서드는 다음과 같다.

메서드	설명
save(entity)	엔티티 저장 및 업데이트
findById(id)	특정 ID 값을 가진 엔티티 조회 (Optional)
findAll()	모든 엔티티 조회
deleteById(id)	특정 ID 값을 가진 엔티티 삭제
existsById(id)	특정 ID의 엔티티 존재 여부 확인
count()	저장된 엔티티 개수 반환
아래는 UserRepository를 활용하여 기본적인 CRUD 기능을 수행하는 예제이다.

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Optional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // 사용자 등록
    @Transactional
    public User saveUser(User user) {
        return userRepository.save(user);
    }

    // 특정 사용자 조회
    public User getUserById(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("해당 사용자가 존재하지 않습니다."));
    }

    // 모든 사용자 조회
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    // 사용자 삭제
    @Transactional
    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new IllegalArgumentException("해당 사용자가 존재하지 않습니다.");
        }
        userRepository.deleteById(id);
    }
}
설명

saveUser(User user): 사용자를 데이터베이스에 저장하는 메서드.
getUserById(Long id): ID로 사용자를 조회하며, 존재하지 않으면 예외 발생.
getAllUsers(): 모든 사용자를 조회하는 메서드.
deleteUser(Long id): 특정 사용자를 삭제하는 메서드.
쿼리 메서드(Query Method) 사용하기
Spring Data JPA는 메서드 이름만으로 자동으로 SQL을 생성하는 기능을 제공한다.
이를 쿼리 메서드(Query Method) 라고 하며, 별도의 JPQL을 작성하지 않아도 된다.

다음은 UserRepository에서 쿼리 메서드를 정의하는 예제이다.

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email); // 이메일을 기준으로 조회
    List<User> findByNameContaining(String name); // 이름이 포함된 사용자 조회
    boolean existsByEmail(String email); // 이메일이 존재하는지 확인
}
위의 메서드는 다음과 같은 SQL 쿼리를 자동으로 생성한다.

메서드명	생성되는 SQL
findByEmail(String email)	SELECT * FROM users WHERE email = ?
findByNameContaining(String name)	SELECT * FROM users WHERE name LIKE %?%
existsByEmail(String email)	SELECT CASE WHEN COUNT(*) > 0 THEN TRUE ELSE FALSE END FROM users WHERE email = ?
JPQL(JPA Query Language) 사용하기
쿼리 메서드만으로 해결되지 않는 복잡한 쿼리는 JPQL을 사용할 수 있다.
JPQL은 SQL과 유사하지만, 테이블이 아닌 엔티티 객체를 대상으로 하는 쿼리이다.

아래는 JPQL을 활용하여 특정 이름을 포함하는 사용자를 조회하는 예제이다.

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
    List<User> searchByName(@Param("name") String name);
}
위 코드의 JPQL은 "User" 엔티티를 대상으로 name이 특정 값을 포함하는 사용자 리스트를 조회하는 기능을 수행한다.

SQL과 비교하면 다음과 같다.

SQL	JPQL
SELECT * FROM users WHERE name LIKE '%홍길동%'	SELECT u FROM User u WHERE u.name LIKE '%:name%'
페이징과 정렬 (Paging & Sorting)
Spring Data JPA는 대량의 데이터를 효율적으로 처리할 수 있도록 페이징 및 정렬 기능을 지원한다.

페이징과 정렬을 적용하려면 PagingAndSortingRepository 또는 Pageable을 활용할 수 있다.

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
    Page<User> findAll(Pageable pageable); // 페이징 처리된 사용자 목록 조회
}
그리고 서비스 계층에서 PageRequest를 사용하여 페이징 기능을 적용할 수 있다.

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public Page<User> getUsersWithPagination(int page, int size) {
        PageRequest pageRequest = PageRequest.of(page, size, Sort.by("name").ascending());
        return userRepository.findAll(pageRequest);
    }
}
위 코드에서 PageRequest.of(page, size, Sort.by("name").ascending())을 통해 이름(name) 기준으로 오름차순 정렬된 데이터를 페이징 처리하여 가져온다.

학습자의 사고를 돕기 위한 질문
JpaRepository 인터페이스가 제공하는 기본 CRUD 메서드들은 무엇이 있는가?

findAll(), findById(), save(), delete() 메서드에 대해 생각해보라.
JpaRepository를 상속받는 이유는 무엇인가?

기본적인 데이터베이스 작업을 더 쉽게 처리할 수 있는 방법에 대해 생각해보라.
JPA의 @Query를 사용하여 커스텀 쿼리를 작성하는 이유는 무엇인가?

복잡한 쿼리나 조건을 처리하기 위해 필요한 경우를 떠올려보라.
실습 문제
문제 1: JpaRepository를 사용하여 기본 CRUD 구현하기
다음 요구사항을 만족하는 코드를 작성하시오.

User 엔티티 클래스를 기반으로 UserRepository를 작성한다.
findById() 메서드를 사용하여 특정 id를 가진 사용자를 조회한다.
save() 메서드를 사용하여 새로운 사용자 데이터를 추가한다.
문제 2: @Query를 사용하여 조건에 맞는 사용자 조회하기
다음 요구사항을 만족하는 코드를 작성하시오.

UserRepository에 @Query를 사용하여 name이 주어진 값과 일치하는 사용자를 조회하는 쿼리를 작성한다.
name에 해당하는 사용자를 찾는 메서드를 작성한다.
2.3. 데이터베이스 마이그레이션
데이터베이스 마이그레이션은 데이터베이스 스키마의 변경을 관리하는 과정이다.
어플리케이션이 지속적으로 발전함에 따라 새로운 테이블을 추가하거나, 기존 테이블의 컬럼을 변경해야 하는 경우가 발생한다.
이러한 스키마 변경을 코드 기반으로 관리하는 것이 바로 마이그레이션(Migration) 이다.

Spring Boot에서는 대표적으로 Flyway와 Liquibase 두 가지 마이그레이션 도구를 사용할 수 있다.
각각의 도구는 장단점이 있지만, 프로젝트의 요구사항에 맞게 선택하여 사용할 수 있다.

Flyway란?
Flyway는 SQL 기반의 마이그레이션 도구로,
버전 관리된 SQL 파일을 이용하여 데이터베이스 스키마를 자동으로 변경할 수 있도록 돕는다.
Flyway를 활용하면 버전별로 관리되는 SQL 스크립트를 실행하여 데이터베이스를 지속적으로 업데이트할 수 있다.

Flyway의 주요 특징:

SQL 파일 기반으로 스키마 변경을 적용
스키마 변경 내역을 버전 번호(V1, V2, V3) 로 관리
자동 롤백 기능이 없음 (변경된 내용을 되돌리려면 수동으로 조치 필요)
Flyway 설정 및 사용 방법
Spring Boot에서 Flyway를 사용하려면 Flyway 의존성을 추가해야 한다.

1. Flyway 의존성 추가 Maven 프로젝트의 경우 pom.xml에 다음을 추가한다.

<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
Gradle 프로젝트의 경우 build.gradle에 다음을 추가한다.

dependencies {
    implementation 'org.flywaydb:flyway-core'
}
2. Flyway 기본 설정
Flyway는 Spring Boot의 application.yml 또는 application.properties 파일을 통해 설정할 수 있다.

spring:
  flyway:
    enabled: true # Flyway 사용 활성화
    baseline-on-migrate: true # 기존 데이터베이스를 기준 버전으로 설정
    locations: classpath:db/migration # 마이그레이션 SQL 파일 경로
위 설정을 추가하면 Flyway가 db/migration 경로에 있는 SQL 파일을 찾아 실행하게 된다.

3. 마이그레이션 SQL 파일 작성
Flyway의 핵심 개념은 버전 관리된 SQL 파일을 작성하는 것이다.
파일명은 V{버전번호}__{설명}.sql 형식을 따라야 한다.

예를 들어, 사용자 테이블(users)을 생성하는 SQL 스크립트를 작성한다고 가정하자.
src/main/resources/db/migration/V1__Create_users_table.sql 파일을 생성하고 아래 내용을 작성한다.

CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
Flyway는 애플리케이션이 실행될 때 db/migration 경로에 있는 SQL 파일을 읽고,
현재 데이터베이스에 적용되지 않은 스크립트를 자동으로 실행한다.

4. 마이그레이션 실행 결과 확인
Flyway는 마이그레이션 내역을 데이터베이스의 flyway_schema_history 테이블에 기록한다.
예를 들어, MySQL에서 다음과 같이 실행하면 마이그레이션 기록을 확인할 수 있다.

SELECT * FROM flyway_schema_history;
이 테이블에는 다음과 같은 정보가 저장된다.

ID	버전	설명	실행 시간
1	1	Create_users_table	5s
이렇게 하면 데이터베이스 스키마 변경 내역을 추적할 수 있으며,
나중에 새로운 변경 사항이 필요하면 새로운 버전의 SQL 파일을 작성하여 적용하면 된다.

Liquibase란?
Liquibase는 Flyway와 유사한 데이터베이스 마이그레이션 도구이지만,
SQL 파일 대신 XML, YAML, JSON 등의 설정 파일을 사용하여 변경 사항을 관리할 수 있다.

Liquibase의 주요 특징:

SQL뿐만 아니라 XML, YAML, JSON 기반의 설정 파일을 사용하여 관리 가능
자동 롤백 지원 (변경 사항을 되돌릴 수 있음)
데이터베이스의 변경 이력을 추적하고, 변경된 내용만 적용
대규모 프로젝트에서 데이터베이스 변경을 체계적으로 관리하는 데 적합
Liquibase 설정 및 사용 방법
Spring Boot에서 Liquibase를 사용하려면 Liquibase 의존성을 추가해야 한다.

1. Liquibase 의존성 추가 Maven 프로젝트의 경우 pom.xml에 다음을 추가한다.

<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>
Gradle 프로젝트의 경우 build.gradle에 다음을 추가한다.

dependencies {
    implementation 'org.liquibase:liquibase-core'
}
2. Liquibase 기본 설정
Liquibase는 application.yml 또는 application.properties에서 설정할 수 있다.

spring:
  liquibase:
    change-log: classpath:db/changelog/db.changelog-master.xml # 변경 사항을 기록하는 XML 파일
    enabled: true # Liquibase 사용 활성화
3. 마이그레이션 XML 파일 작성
Liquibase의 마이그레이션 파일은 ChangeLog라고 불리며,
여러 개의 데이터베이스 변경 사항을 기록하는 역할을 한다.

예를 들어, 사용자 테이블을 생성하는 XML 기반의 마이그레이션을 작성할 수 있다.

src/main/resources/db/changelog/db.changelog-master.xml 파일을 생성하고 아래 내용을 추가한다.

<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">

    <changeSet id="1" author="admin">
        <createTable tableName="users">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true"/>
            </column>
            <column name="name" type="VARCHAR(50)">
                <constraints nullable="false"/>
            </column>
            <column name="email" type="VARCHAR(100)">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="password" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP" defaultValueComputed="CURRENT_TIMESTAMP"/>
            <column name="updated_at" type="TIMESTAMP" defaultValueComputed="CURRENT_TIMESTAMP"/>
        </createTable>
    </changeSet>

</databaseChangeLog>
Flyway vs Liquibase 비교
항목	Flyway	Liquibase
사용 방식	SQL 스크립트 기반	XML, YAML, JSON, SQL 지원
롤백 지원	지원하지 않음 (수동 롤백 필요)	자동 롤백 가능
변경 이력 저장 방식	flyway_schema_history 테이블	databasechangelog 테이블
실행 속도	비교적 빠름	조금 느림
대규모 프로젝트 적합성	중소형 프로젝트에 적합	대규모 프로젝트에 적합
실습 문제
문제 1: 데이터베이스 초기화 전략 설정하기
다음 요구사항을 만족하는 코드 작성하시오.

application.properties 파일에서 데이터베이스 초기화 전략을 설정한다.
spring.jpa.hibernate.ddl-auto=create로 설정하여 애플리케이션 실행 시 데이터베이스를 생성한다.
문제 2: Flyway를 사용하여 마이그레이션 적용하기
다음 요구사항을 만족하는 코드를 작성하시오.

Flyway를 사용하여 데이터베이스 마이그레이션을 적용한다.
V1__create_user_table.sql 파일을 작성하여 User 테이블을 생성한다.
application.properties에서 Flyway 설정을 추가한다.
3. 비즈니스 로직 구현
3.1. 서비스 계층 설계
Spring Boot에서 서비스(Service) 계층은 비즈니스 로직을 처리하는 핵심 부분이다.
웹 애플리케이션에서 컨트롤러는 요청을 처리하고 응답을 반환하는 역할을 담당하지만,
실제 데이터 처리, 검증, 트랜잭션 등의 로직은 서비스 계층에서 수행된다.

서비스 계층을 적절하게 분리하면 코드의 재사용성, 유지보수성, 테스트 용이성이 향상된다.

서비스 계층의 역할
비즈니스 로직 처리
단순한 CRUD 작업을 넘어서 도메인 비즈니스 규칙을 적용하는 역할을 한다.
데이터베이스 액세스 분리
서비스 계층에서 데이터를 처리하고, 레포지토리 계층에서 실제 데이터베이스와의 연결을 수행한다.
트랜잭션 관리
데이터의 일관성을 유지하기 위해 트랜잭션을 관리하는 역할을 한다.
코드 재사용성 및 모듈화
컨트롤러와 레포지토리 사이의 중간 계층을 구성하여 코드의 모듈화를 높인다.
Spring Boot에서 서비스 계층을 구현하는 방법
Spring Boot에서는 @Service 어노테이션을 사용하여 서비스 클래스를 정의한다.
이 어노테이션을 붙이면 Spring이 해당 클래스를 빈(Bean)으로 등록하여 관리하게 된다.

예제: 사용자(User) 정보를 관리하는 서비스

package com.example.service;

import com.example.model.User;
import com.example.repository.UserRepository;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;

@Service  // 서비스 계층임을 나타내는 어노테이션
public class UserService {

    private final UserRepository userRepository;

    // 생성자를 통한 의존성 주입 (권장 방식)
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // 사용자 목록 조회
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    // 사용자 조회 (ID 기준)
    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }

    // 사용자 등록
    public User createUser(User user) {
        return userRepository.save(user);
    }

    // 사용자 삭제
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
1. @Service 어노테이션의 역할
Spring에서 @Service 어노테이션은 서비스 계층임을 명시적으로 나타내는 역할을 한다.
이 어노테이션이 적용된 클래스는 Spring 컨테이너에 의해 관리되는 Bean으로 등록된다.

@Service는 내부적으로 @Component를 포함하고 있어 자동으로 빈(Bean)으로 등록된다.
서비스 계층을 의미하는 명확한 역할을 가지므로 코드의 가독성과 유지보수성을 향상시킨다.
2. 생성자를 통한 의존성 주입
UserService 클래스는 UserRepository를 주입받아 사용한다.
의존성 주입(Dependency Injection, DI)에는 여러 방식이 있지만,
생성자 주입 방식이 가장 권장되는 방식이다.

public UserService(UserRepository userRepository) {
    this.userRepository = userRepository;
}
장점:
final 키워드를 사용할 수 있어 불변성을 유지할 수 있다.
의존성이 명확하게 드러나 테스트하기 쉽다.
순환 참조(Circular Dependency) 문제를 방지할 수 있다.
3. CRUD 메서드 구현
서비스 계층에서는 비즈니스 로직을 수행하면서 레포지토리를 호출하여 데이터 처리를 한다.

getAllUsers() : 모든 사용자 목록을 조회한다.
getUserById(Long id) : 특정 ID의 사용자를 조회한다.
createUser(User user) : 새로운 사용자를 생성한다.
deleteUser(Long id) : 특정 사용자를 삭제한다.
이러한 CRUD 메서드들은 컨트롤러에서 호출되며,
비즈니스 규칙을 추가하는 경우 서비스 계층에서 처리하도록 설계된다.

4. 예제: 컨트롤러에서 서비스 계층 호출
컨트롤러에서 UserService를 호출하여 API 요청을 처리하는 예제이다.

package com.example.controller;

import com.example.model.User;
import com.example.service.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    // 모든 사용자 조회
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        return ResponseEntity.ok(userService.getAllUsers());
    }

    // 특정 사용자 조회
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        return userService.getUserById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // 사용자 생성
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        return ResponseEntity.ok(userService.createUser(user));
    }

    // 사용자 삭제
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
위의 컨트롤러 코드에서 UserService를 사용하여 비즈니스 로직을 호출하고 있다.
이렇게 하면 컨트롤러는 요청을 받아들이고, 서비스는 비즈니스 로직을 수행하며, 레포지토리는 데이터베이스와의 직접적인 상호작용을 담당하는 계층 구조가 형성된다.

5. 서비스 계층을 인터페이스 기반으로 설계하기
더 나은 확장성과 유지보수성을 고려하면 인터페이스 기반 설계를 적용할 수 있다.

인터페이스 정의:

package com.example.service;

import com.example.model.User;
import java.util.List;
import java.util.Optional;

public interface UserService {
    List<User> getAllUsers();
    Optional<User> getUserById(Long id);
    User createUser(User user);
    void deleteUser(Long id);
}
구현 클래스:

package com.example.service;

import com.example.model.User;
import com.example.repository.UserRepository;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;

@Service
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    public UserServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    @Override
    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }

    @Override
    public User createUser(User user) {
        return userRepository.save(user);
    }

    @Override
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
이렇게 인터페이스를 정의하면, 나중에 구현 클래스를 교체하거나 확장하기 쉬워진다.
예를 들어, UserServiceImpl을 교체하고 새로운 UserService 구현체를 추가하는 것이 가능하다.

학습자의 사고를 돕기 위한 질문
서비스 계층을 도입하는 이유는 무엇인가?

비즈니스 로직을 컨트롤러와 분리함으로써 얻을 수 있는 장점은 무엇인지 생각해보라.
@Service 어노테이션을 사용하여 서비스를 정의하는 이유는 무엇인가?

서비스 계층을 정의할 때 @Service가 가지는 의미와 활용 방법에 대해 생각해보라.
서비스 계층에서 특정 비즈니스 로직을 처리할 때 인터페이스를 사용하는 이유는 무엇인가?

인터페이스를 사용함으로써 얻는 유연성이나 테스트 용이성 등을 고려해보라.
3.2. 트랜잭션 관리
트랜잭션(Transaction)이란 데이터베이스의 상태를 변화시키는 하나의 작업 단위를 의미한다.
Spring Boot에서는 @Transactional 어노테이션을 이용해 트랜잭션을 관리하며,
트랜잭션은 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)이라는 ACID 특성을 보장해야 한다.

Spring의 트랜잭션 관리는 애플리케이션에서 데이터 정합성을 유지하고, 예외 발생 시 안전한 롤백을 가능하게 하는 중요한 요소다.

트랜잭션이 필요한 이유
데이터 정합성 유지
여러 개의 데이터 변경 작업이 하나의 단위로 실행되어야 한다.
일부 작업이 실패해도 전체가 롤백되도록 관리할 필요가 있다.
데이터 일관성 보장
동일한 데이터를 동시에 여러 요청이 처리할 경우,
일관성을 유지하기 위해 트랜잭션 격리 수준(Isolation Level) 이 필요하다.
롤백(rollback) 기능 지원
예외가 발생했을 때 이전 상태로 되돌릴 수 있어야 한다.
동시성 제어
다중 사용자 환경에서 데이터 무결성을 보호하기 위해 트랜잭션이 필요하다.
Spring Boot에서 @Transactional 적용 방법
Spring Boot에서는 @Transactional을 사용하여 간단하게 트랜잭션을 적용할 수 있다.
이 어노테이션은 서비스 계층에서 메서드 단위로 적용하는 것이 일반적이다.

사용자(User) 정보를 저장하는 서비스 예제

package com.example.service;

import com.example.model.User;
import com.example.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional  // 트랜잭션 적용
    public User createUser(User user) {
        return userRepository.save(user);
    }
}
@Transactional을 메서드에 적용하면, 해당 메서드가 실행되는 동안 트랜잭션이 유지된다.
메서드가 정상적으로 종료되면 트랜잭션이 commit되고, 예외가 발생하면 자동으로 rollback된다.
트랜잭션 롤백 처리
Spring Boot의 @Transactional은 기본적으로 RuntimeException이 발생하면 롤백을 수행한다.
하지만, Checked Exception은 기본적으로 롤백되지 않는다.

예제: 특정 예외 발생 시 롤백 적용

import org.springframework.transaction.annotation.Transactional;
import java.sql.SQLException;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional(rollbackFor = SQLException.class) // SQLException 발생 시 롤백
    public void updateUser(Long userId, String newName) throws SQLException {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        user.setName(newName);
        userRepository.save(user);

        // 특정 조건에서 예외 발생
        if (newName.equals("error")) {
            throw new SQLException("SQL Exception 발생");
        }
    }
}
@Transactional(rollbackFor = SQLException.class)을 지정하면 SQLException 발생 시에도 롤백된다.
기본적으로 RuntimeException만 롤백되지만, rollbackFor을 사용하면 Checked Exception도 롤백 가능하다.
트랜잭션의 격리 수준(Isolation Level)
트랜잭션의 격리 수준(Isolation Level)은 여러 개의 트랜잭션이 동시에 실행될 때,
각 트랜잭션 간의 데이터 접근 범위를 제어하는 방식이다.

격리 수준은 다음과 같이 4단계로 구분된다.

격리 수준	설명	발생 가능 문제
READ_UNCOMMITTED	다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있음.	Dirty Read, Non-repeatable Read, Phantom Read
READ_COMMITTED	다른 트랜잭션이 커밋한 데이터만 읽을 수 있음.	Non-repeatable Read, Phantom Read
REPEATABLE_READ	같은 트랜잭션 내에서는 항상 같은 데이터를 읽음.	Phantom Read
SERIALIZABLE	가장 높은 격리 수준, 트랜잭션을 직렬화하여 실행	성능 저하 발생 가능
예제: 트랜잭션 격리 수준 설정

import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AccountService {

    private final AccountRepository accountRepository;

    public AccountService(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }

    @Transactional(isolation = Isolation.REPEATABLE_READ) // 격리 수준 설정
    public void updateBalance(Long accountId, int amount) {
        Account account = accountRepository.findById(accountId)
                .orElseThrow(() -> new RuntimeException("Account not found"));

        account.setBalance(account.getBalance() + amount);
        accountRepository.save(account);
    }
}
Isolation.REPEATABLE_READ를 적용하면,
같은 트랜잭션 내에서는 다른 트랜잭션의 변경사항을 읽지 않도록 설정된다.
트랜잭션 전파(Propagation)
트랜잭션 전파(Propagation)는 하나의 트랜잭션이 다른 트랜잭션을 호출할 때 어떻게 동작할지 결정하는 방식이다.
Spring Boot에서는 Propagation 설정을 통해 트랜잭션을 분리할지, 기존 트랜잭션을 유지할지 선택할 수 있다.

전파 방식	설명
REQUIRED	기본값, 기존 트랜잭션이 있으면 합쳐서 실행
REQUIRES_NEW	기존 트랜잭션을 중단하고, 새로운 트랜잭션을 생성
NESTED	기존 트랜잭션 내부에서 새로운 트랜잭션을 실행
SUPPORTS	트랜잭션이 있으면 참여하고, 없으면 트랜잭션 없이 실행
NOT_SUPPORTED	트랜잭션 없이 실행
MANDATORY	반드시 기존 트랜잭션이 있어야 실행 가능
NEVER	트랜잭션이 있으면 예외 발생
예제: REQUIRES_NEW 적용

import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Service
public class OrderService {

    private final OrderRepository orderRepository;
    private final PaymentService paymentService;

    public OrderService(OrderRepository orderRepository, PaymentService paymentService) {
        this.orderRepository = orderRepository;
        this.paymentService = paymentService;
    }

    @Transactional
    public void placeOrder(Order order) {
        orderRepository.save(order);

        // 새로운 트랜잭션 시작 (기존 트랜잭션과 분리)
        paymentService.processPayment(order.getPayment());
    }
}

@Service
public class PaymentService {

    private final PaymentRepository paymentRepository;

    public PaymentService(PaymentRepository paymentRepository) {
        this.paymentRepository = paymentRepository;
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW) // 별도 트랜잭션 실행
    public void processPayment(Payment payment) {
        paymentRepository.save(payment);
    }
}
OrderService.placeOrder()가 실행될 때,
paymentService.processPayment()는 새로운 트랜잭션에서 실행된다.
만약 placeOrder()에서 예외가 발생해도 결제 정보는 유지된다.
학습자의 사고를 돕기 위한 질문
@Transactional 어노테이션을 사용하는 이유는 무엇인가?

트랜잭션을 적용해야 하는 이유와 그 효과를 생각해보라.
트랜잭션이 적용되었을 때 롤백(rollback) 기능이 중요한 이유는 무엇인가?

트랜잭션 처리 중 문제가 발생했을 때 데이터를 어떻게 안정적으로 유지할 수 있는지 생각해보라.
트랜잭션을 적용할 때 required, mandatory, never와 같은 전파 속성(Propagation)의 차이는 무엇인가?

트랜잭션의 전파 속성이 무엇을 의미하는지, 각각의 속성이 어떤 상황에서 사용되는지 고려해보라.
3.3. DTO 및 변환 로직
DTO(Data Transfer Object)란 데이터 전송을 위해 사용되는 객체로,
애플리케이션의 여러 계층 간 데이터를 전달할 때 사용된다.

Spring Boot에서는 Entity와 DTO를 분리하여 관리하는 것이 일반적이다.
Entity는 데이터베이스 테이블을 나타내는 객체이고, DTO는 API 요청과 응답을 위한 데이터 구조이다.

DTO를 활용하면 다음과 같은 장점이 있다:

Entity를 보호하여 직접적인 외부 접근을 방지할 수 있다.
불필요한 필드를 제외하고 필요한 데이터만 전송할 수 있다.
데이터 변환을 쉽게 관리할 수 있다.
DTO와 Entity의 차이
구분	Entity	DTO
목적	데이터베이스와 직접 매핑	API 요청/응답 데이터 변환
역할	테이블과 직접 매핑되어 JPA에서 사용	비즈니스 로직 또는 클라이언트와의 데이터 교환
구조	관계형 데이터 모델을 반영	필요한 데이터만 포함
변경 가능성	데이터베이스 변경에 영향 받음	클라이언트 요구에 따라 유연하게 변경 가능
DTO 클래스 작성
DTO 클래스는 일반적으로 request와 response DTO로 분리하여 사용한다.

예제: 사용자 정보를 다루는 DTO

package com.example.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class UserRequestDTO {
    private String name;
    private String email;
}

@Getter
@Setter
public class UserResponseDTO {
    private Long id;
    private String name;
    private String email;
}
UserRequestDTO: 클라이언트에서 요청(Request)할 때 사용하는 DTO
UserResponseDTO: 클라이언트에게 응답(Response)할 때 사용하는 DTO
DTO와 Entity 간 변환 방법
DTO와 Entity 간 변환은 여러 방법으로 수행할 수 있다.

1. 직접 변환 (수동 매핑)

package com.example.model;

import com.example.dto.UserRequestDTO;
import com.example.dto.UserResponseDTO;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.persistence.*;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // DTO -> Entity 변환
    public static User fromDTO(UserRequestDTO dto) {
        User user = new User();
        user.setName(dto.getName());
        user.setEmail(dto.getEmail());
        return user;
    }

    // Entity -> DTO 변환
    public UserResponseDTO toDTO() {
        UserResponseDTO dto = new UserResponseDTO();
        dto.setId(this.id);
        dto.setName(this.name);
        dto.setEmail(this.email);
        return dto;
    }
}
fromDTO(UserRequestDTO dto): DTO를 Entity로 변환
toDTO(): Entity를 DTO로 변환
이 방법은 직접 변환 로직을 작성해야 하지만, 코드가 명확하고 불필요한 라이브러리 의존성을 줄일 수 있다.
다만, DTO 필드가 많아지면 매핑 코드가 길어지고 유지보수가 어려워질 수 있다.

2. ModelMapper를 이용한 변환
ModelMapper는 객체 간 변환을 자동으로 수행하는 라이브러리이다.

의존성 추가 (Maven)

<dependency>
    <groupId>org.modelmapper</groupId>
    <artifactId>modelmapper</artifactId>
    <version>2.4.4</version>
</dependency>
DTO 변환 예제

import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Component;

@Component
public class UserMapper {

    private final ModelMapper modelMapper = new ModelMapper();

    public User toEntity(UserRequestDTO dto) {
        return modelMapper.map(dto, User.class);
    }

    public UserResponseDTO toDTO(User user) {
        return modelMapper.map(user, UserResponseDTO.class);
    }
}
ModelMapper를 사용하면 객체 간 변환을 자동화할 수 있다.
다만, 변환 과정에서 예외가 발생할 가능성이 있으므로 테스트가 필요하다.
3. MapStruct를 활용한 변환
MapStruct는 컴파일 시점에 변환 코드를 자동 생성하는 라이브러리이다.
코드를 직접 작성하지 않아도 성능이 빠르고 유지보수가 용이하다.

의존성 추가 (Maven)

<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct</artifactId>
    <version>1.5.3.Final</version>
</dependency>

<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-processor</artifactId>
    <version>1.5.3.Final</version>
    <scope>provided</scope>
</dependency>
DTO 변환 예제

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

@Mapper
public interface UserMapper {

    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    @Mapping(source = "name", target = "name")
    @Mapping(source = "email", target = "email")
    User toEntity(UserRequestDTO dto);

    @Mapping(source = "id", target = "id")
    @Mapping(source = "name", target = "name")
    @Mapping(source = "email", target = "email")
    UserResponseDTO toDTO(User user);
}
MapStruct는 애노테이션 기반으로 변환 로직을 자동 생성한다.
Mappers.getMapper(UserMapper.class)를 통해 싱글턴 인스턴스를 가져올 수 있다.
@Mapping 애노테이션을 활용하면 필드명을 매핑할 수 있다.
DTO 변환을 서비스 계층에서 적용하기
DTO 변환 로직을 서비스 계층에서 적용하는 방식이 일반적이다.

package com.example.service;

import com.example.dto.UserRequestDTO;
import com.example.dto.UserResponseDTO;
import com.example.model.User;
import com.example.repository.UserRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserService {

    private final UserRepository userRepository;
    private final UserMapper userMapper;

    public UserService(UserRepository userRepository, UserMapper userMapper) {
        this.userRepository = userRepository;
        this.userMapper = userMapper;
    }

    public UserResponseDTO createUser(UserRequestDTO dto) {
        User user = userMapper.toEntity(dto);
        user = userRepository.save(user);
        return userMapper.toDTO(user);
    }

    public List<UserResponseDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(userMapper::toDTO)
                .collect(Collectors.toList());
    }
}
DTO를 서비스 계층에서 변환하면, 컨트롤러와의 데이터 교환이 명확해진다.
UserRequestDTO는 요청 데이터로 변환되고, UserResponseDTO는 응답 데이터로 변환된다.
DTO 변환 시 고려해야 할 사항
Entity를 직접 노출하지 않기
Entity는 내부 데이터베이스 모델이므로, API 응답에 직접 노출되면 변경 시 위험할 수 있다.
DTO 변환 성능 고려
변환이 빈번하게 발생하는 경우, MapStruct를 사용하면 성능이 향상될 수 있다.
DTO와 Entity 간 필드 차이 확인
DTO에는 불필요한 필드를 제거하고, 필요한 데이터만 포함해야 한다.
객체 변환 시 예외 처리
ModelMapper는 변환 오류가 발생할 수 있으므로, 필요한 경우 수동 매핑을 고려해야 한다.
학습자의 사고를 돕기 위한 질문
DTO(Data Transfer Object)의 역할은 무엇인가?

엔티티와 DTO를 구분할 때의 장점과 용도를 생각해보라.
DTO와 엔티티 객체 간의 변환은 어떻게 이루어지는가?

DTO를 사용하는 이유와 변환 로직을 어떻게 구현할 수 있을지 고민해보라.
ModelMapper와 MapStruct는 어떤 점에서 유용한 도구인가?

두 라이브러리의 차이점과 각각의 사용 시점을 생각해보라.
실습 문제
문제 1: DTO 변환하기
다음 요구사항을 만족하는 DTO 클래스와 변환 로직을 작성하시오.

User 엔티티 클래스와 이를 위한 UserDTO 클래스가 존재한다.
UserDTO는 id, name, email 필드를 포함하며, 엔티티 클래스에서 해당 정보를 DTO로 변환하는 로직을 작성한다.
ModelMapper나 MapStruct를 사용하여 변환 로직을 작성할 수 있다.
문제 2: 여러 엔티티 클래스에 대한 DTO 변환 적용하기
다음 요구사항을 만족하는 DTO 변환 로직을 작성하시오.

Product 엔티티 클래스와 Order 엔티티 클래스가 각각 존재한다.
ProductDTO와 OrderDTO 클래스는 각각 id, name, price, orderDate 등의 필드를 포함한다.
Product 엔티티와 Order 엔티티를 각각 ProductDTO와 OrderDTO로 변환하는 로직을 작성한다.
4. RESTful API 개발
4.1. 컨트롤러 설계 및 구현
Spring Boot에서 RESTful API의 컨트롤러는 클라이언트 요청을 처리하고 데이터를 반환하는 역할을 한다.
컨트롤러는 비즈니스 로직을 처리하는 서비스 계층과 분리하여 관리되며,
일반적으로 @RestController와 @RequestMapping을 활용하여 API를 설계한다.

1. 컨트롤러의 역할
컨트롤러는 다음과 같은 주요 역할을 수행한다.

클라이언트 요청 처리: @GetMapping, @PostMapping 등의 애노테이션을 사용하여 API 엔드포인트를 정의한다.
서비스 계층과의 연동: 요청을 서비스 계층으로 위임하여 데이터를 조회하거나 변경하는 역할을 한다.
DTO 변환: 엔티티를 직접 반환하지 않고 DTO를 활용하여 데이터를 전송한다.
예외 처리: @ExceptionHandler를 통해 예외 상황을 처리할 수 있다.
2. @RestController와 @RequestMapping
Spring Boot에서 RESTful API를 구현할 때 @RestController를 사용한다.
이 애노테이션은 @Controller와 @ResponseBody를 결합한 것으로, 모든 메서드에서 JSON 데이터를 반환하도록 한다.

예제: 기본 컨트롤러 설정

package com.example.controller;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users")
public class UserController {

    @GetMapping
    public String getAllUsers() {
        return "모든 사용자 목록을 조회합니다.";
    }

    @PostMapping
    public String createUser() {
        return "새로운 사용자를 생성합니다.";
    }
}
@RestController: RESTful API를 처리하는 컨트롤러임을 나타낸다.
@RequestMapping("/api/users"): 해당 컨트롤러의 기본 URL을 /api/users로 설정한다.
@GetMapping: GET 요청을 처리하는 메서드이다.
@PostMapping: POST 요청을 처리하는 메서드이다.
3. CRUD API 구현
실제 데이터 처리를 위해 서비스 계층과 연동하는 컨트롤러를 구현한다.
여기서는 사용자(User) 엔티티에 대한 CRUD (Create, Read, Update, Delete) API를 작성한다.

package com.example.controller;

import com.example.dto.UserRequestDTO;
import com.example.dto.UserResponseDTO;
import com.example.service.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    // 모든 사용자 조회
    @GetMapping
    public ResponseEntity<List<UserResponseDTO>> getAllUsers() {
        List<UserResponseDTO> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }

    // 특정 사용자 조회
    @GetMapping("/{id}")
    public ResponseEntity<UserResponseDTO> getUserById(@PathVariable Long id) {
        UserResponseDTO user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }

    // 사용자 생성
    @PostMapping
    public ResponseEntity<UserResponseDTO> createUser(@RequestBody UserRequestDTO userRequestDTO) {
        UserResponseDTO newUser = userService.createUser(userRequestDTO);
        return ResponseEntity.ok(newUser);
    }

    // 사용자 정보 수정
    @PutMapping("/{id}")
    public ResponseEntity<UserResponseDTO> updateUser(@PathVariable Long id, @RequestBody UserRequestDTO userRequestDTO) {
        UserResponseDTO updatedUser = userService.updateUser(id, userRequestDTO);
        return ResponseEntity.ok(updatedUser);
    }

    // 사용자 삭제
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
설명
@GetMapping
전체 사용자 조회 (/api/users)
특정 사용자 조회 (/api/users/{id})
@PostMapping
새로운 사용자 생성 (/api/users)
@PutMapping
사용자 정보 업데이트 (/api/users/{id})
@DeleteMapping
사용자 삭제 (/api/users/{id})
4. ResponseEntity를 활용한 응답 처리
컨트롤러에서 데이터를 반환할 때,
응답 상태 코드와 함께 데이터를 반환하는 것이 중요하다.
이를 위해 ResponseEntity<T>를 활용한다.

HTTP 메서드	응답 코드	설명
GET	200 OK	조회 성공
POST	201 Created	생성 성공
PUT	200 OK	업데이트 성공
DELETE	204 No Content	삭제 성공 (데이터 없음)
예제: 응답 코드 적용

@PostMapping
public ResponseEntity<UserResponseDTO> createUser(@RequestBody UserRequestDTO userRequestDTO) {
    UserResponseDTO newUser = userService.createUser(userRequestDTO);
    return ResponseEntity.status(201).body(newUser); // 201 Created 반환
}
ResponseEntity.status(201).body(newUser): HTTP 201 상태 코드와 함께 데이터를 반환한다.
5. @PathVariable과 @RequestParam의 차이
RESTful API에서는 경로 변수 (@PathVariable) 와 쿼리 매개변수 (@RequestParam) 를 사용할 수 있다.

애노테이션	설명	예제
@PathVariable	URL 경로에서 값을 추출	/api/users/{id}
@RequestParam	URL의 쿼리 파라미터에서 값을 추출	/api/users?name=홍길동
예제: @PathVariable과 @RequestParam 비교

// @PathVariable 사용
@GetMapping("/{id}")
public ResponseEntity<UserResponseDTO> getUserById(@PathVariable Long id) {
    UserResponseDTO user = userService.getUserById(id);
    return ResponseEntity.ok(user);
}

// @RequestParam 사용
@GetMapping("/search")
public ResponseEntity<UserResponseDTO> getUserByName(@RequestParam String name) {
    UserResponseDTO user = userService.getUserByName(name);
    return ResponseEntity.ok(user);
}
/api/users/1 → @PathVariable을 사용하여 id 값을 추출한다.
/api/users/search?name=홍길동 → @RequestParam을 사용하여 name 값을 추출한다.
6. 컨트롤러에서 예외 처리
컨트롤러에서 발생하는 예외를 처리하기 위해 @ExceptionHandler를 활용할 수 있다.

예제: 컨트롤러에서 예외 처리

package com.example.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }
}
@RestControllerAdvice를 사용하여 전역 예외 처리를 한다.
특정 예외(IllegalArgumentException)가 발생하면 HTTP 400 상태 코드와 함께 오류 메시지를 반환한다.
7. 컨트롤러 계층 설계 시 고려할 점
컨트롤러는 서비스 계층과 명확하게 분리해야 한다.
비즈니스 로직은 서비스 계층에서 처리하고, 컨트롤러는 요청과 응답을 담당해야 한다.
ResponseEntity를 활용하여 명확한 응답을 반환한다.
HTTP 상태 코드와 데이터를 함께 반환하면, API 사용자가 응답을 더 쉽게 이해할 수 있다.
DTO를 사용하여 Entity를 직접 반환하지 않는다.
Entity를 직접 반환하면, 데이터베이스 모델이 외부에 노출될 위험이 있다.
전역 예외 처리를 통해 일관된 오류 응답을 제공한다.
@RestControllerAdvice를 활용하여 예외 발생 시 일관된 응답을 반환해야 한다.
학습자의 사고를 돕기 위한 질문
@RestController와 @Controller의 차이점은 무엇인가?

각각의 어노테이션이 처리하는 HTTP 응답 방식의 차이를 생각해보라.
@GetMapping과 @PostMapping의 차이점은 무엇인가?

HTTP 메서드(GET, POST)의 용도와 각각의 어노테이션이 처리하는 요청 방식을 떠올려보라.
RESTful API에서 URL 설계 시 고려해야 할 사항은 무엇인가?

URI 설계의 일관성, 직관성, 의미 부여 등에 대해 생각해보라.
4.2. API 요청 및 응답 처리
RESTful API는 클라이언트와 서버 간의 데이터 교환을 기반으로 동작하며, 요청(Request)과 응답(Response)의 구조를 명확하게 정의하는 것이 중요하다.
Spring Boot에서는 @RequestBody, @ResponseBody, ResponseEntity, DTO(Data Transfer Object) 등을 활용하여 요청 및 응답을 효율적으로 관리할 수 있다.

1. API 요청(Request)과 응답(Response)의 개념
요청(Request): 클라이언트가 서버에 특정 작업을 수행하도록 요청하는 데이터 패킷.
HTTP Method(GET, POST, PUT, DELETE)를 포함.
요청 본문(Body)이 있을 수도 있고 없을 수도 있음.
헤더(Header)에 Content-Type, Authorization 등의 정보 포함 가능.
응답(Response): 서버가 요청을 처리한 후 클라이언트에게 보내는 결과 데이터.
HTTP Status Code를 포함하여 성공/실패 여부 표시.
응답 본문(Body)에 JSON, XML 등의 데이터 형식 포함.
헤더(Header)에 Content-Type, Cache-Control 등의 정보 포함 가능.
2. @RequestBody를 활용한 요청 데이터 처리
클라이언트가 서버에 데이터를 전송할 때, JSON 형식으로 본문(Body)을 포함하는 경우가 많다.
이때 @RequestBody 애노테이션을 사용하여 JSON 데이터를 Java 객체로 변환할 수 있다.

예제: 사용자 생성 요청 처리

package com.example.controller;

import com.example.dto.UserRequestDTO;
import com.example.dto.UserResponseDTO;
import com.example.service.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public ResponseEntity<UserResponseDTO> createUser(@RequestBody UserRequestDTO userRequestDTO) {
        UserResponseDTO newUser = userService.createUser(userRequestDTO);
        return ResponseEntity.ok(newUser);
    }
}
설명
@PostMapping: HTTP POST 요청을 처리.
@RequestBody UserRequestDTO userRequestDTO
클라이언트에서 전송한 JSON 데이터를 UserRequestDTO 객체로 변환.
ResponseEntity.ok(newUser): 생성된 사용자 데이터를 응답으로 반환.
클라이언트에서 보낼 JSON 예시

{
  "name": "홍길동",
  "email": "hong@example.com"
}
3. ResponseEntity를 활용한 응답 데이터 처리
ResponseEntity는 응답 상태 코드, 헤더, 본문을 포함하는 객체로, 보다 세밀한 응답 처리가 가능하다.

예제: 응답 상태 코드와 함께 데이터 반환

@PostMapping
public ResponseEntity<UserResponseDTO> createUser(@RequestBody UserRequestDTO userRequestDTO) {
    UserResponseDTO newUser = userService.createUser(userRequestDTO);
    return ResponseEntity.status(201).body(newUser); // 201 Created 반환
}
ResponseEntity.status(201).body(newUser): HTTP 201 상태 코드와 함께 JSON 데이터를 반환.
ResponseEntity.ok(newUser): 기본적으로 HTTP 200 상태 코드 반환.
응답 예시 (201 Created)

{
  "id": 1,
  "name": "홍길동",
  "email": "hong@example.com"
}
HTTP 상태 코드	설명
200 OK	요청이 정상적으로 처리됨
201 Created	새 리소스가 성공적으로 생성됨
400 Bad Request	잘못된 요청 데이터
401 Unauthorized	인증 실패
404 Not Found	요청한 리소스가 없음
500 Internal Server Error	서버 내부 오류
4. DTO(Data Transfer Object)를 이용한 요청 및 응답 처리
엔티티(Entity) 객체를 직접 요청 또는 응답으로 사용하면 보안 및 유지보수 측면에서 문제 발생 가능성이 있다.
DTO를 사용하여 데이터를 변환하고 필요한 필드만 클라이언트와 주고받는 것이 권장된다.

예제: DTO 클래스 정의

package com.example.dto;

public class UserRequestDTO {
    private String name;
    private String email;

    // 기본 생성자
    public UserRequestDTO() {}

    public UserRequestDTO(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // Getter 및 Setter
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
package com.example.dto;

public class UserResponseDTO {
    private Long id;
    private String name;
    private String email;

    // 기본 생성자
    public UserResponseDTO() {}

    public UserResponseDTO(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    // Getter 및 Setter
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
UserRequestDTO: 사용자 생성 시 클라이언트가 전송하는 데이터.
UserResponseDTO: 사용자 정보를 응답할 때 서버가 반환하는 데이터.
5. @RequestParam과 @PathVariable을 활용한 요청 처리
@RequestParam과 @PathVariable은 클라이언트 요청에서 값을 추출하는 방식이 다르다.

애노테이션	설명	예제
@PathVariable	URL 경로에서 값을 추출	/api/users/{id}
@RequestParam	URL의 쿼리 파라미터에서 값을 추출	/api/users?name=홍길동
예제: @PathVariable 사용

@GetMapping("/{id}")
public ResponseEntity<UserResponseDTO> getUserById(@PathVariable Long id) {
    UserResponseDTO user = userService.getUserById(id);
    return ResponseEntity.ok(user);
}
/api/users/1 → id = 1 값을 추출.
예제: @RequestParam 사용

@GetMapping("/search")
public ResponseEntity<UserResponseDTO> getUserByName(@RequestParam String name) {
    UserResponseDTO user = userService.getUserByName(name);
    return ResponseEntity.ok(user);
}
/api/users/search?name=홍길동 → name = 홍길동 값을 추출.
6. API 요청 및 응답 처리 시 고려할 점
DTO를 사용하여 Entity를 직접 노출하지 않는다.
유지보수성과 보안성을 고려하여 Entity 대신 DTO를 사용해야 한다.
ResponseEntity를 활용하여 응답 코드와 데이터를 명확히 전달한다.
ResponseEntity.status(201).body(data) 형식으로 응답을 명확히 전달해야 한다.
@RequestBody를 사용할 때는 JSON 형식이 올바른지 검증한다.
데이터 검증을 위해 @Valid, @NotNull, @Size 등의 애노테이션을 활용한다.
전역 예외 처리를 적용하여 API의 일관성을 유지한다.
@RestControllerAdvice를 활용하여 공통 예외 처리를 적용해야 한다.
실습 문제
문제 1: 단순 GET API 만들기
다음 요구사항을 만족하는 GET API를 작성하시오.

/api/products라는 엔드포인트를 만든다.
해당 엔드포인트는 Product 객체를 반환하며, Product 클래스는 id, name, price 필드를 포함한다.
요청 시, Product 객체를 JSON 형태로 반환한다.
문제 2: POST 요청으로 데이터 받기
다음 요구사항을 만족하는 POST API를 작성하시오.

/api/products라는 엔드포인트를 만든다.
클라이언트에서 보내는 Product 객체를 POST 방식으로 받는다.
받은 데이터는 ProductDTO로 변환한 후 처리한다. ProductDTO는 name, price만 포함된다.
요청 받은 데이터의 응답으로 JSON 형태의 ProductDTO를 반환한다.
4.3. API 데이터 검증 및 예외 처리
API를 개발할 때 클라이언트가 보낸 데이터가 올바른지 검증하는 것은 매우 중요하다.
잘못된 데이터를 허용하면 보안 및 안정성 문제가 발생할 수 있으며, 클라이언트가 의도치 않은 응답을 받게 된다.
Spring Boot에서는 @Valid, @NotNull, @Size, @Pattern 등의 검증(Validation) 애노테이션을 활용하여 데이터를 검증하고,
@ExceptionHandler와 @ControllerAdvice를 이용해 예외를 처리할 수 있다.

1. 데이터 검증(Validation) 개요
Spring Boot에서는 Bean Validation API(JSR-303, JSR-380 표준) 를 지원하며,
javax.validation.constraints 패키지의 애노테이션을 활용하면 DTO 객체에서 데이터를 검증할 수 있다.

애노테이션	설명
@NotNull	값이 null이 아니어야 함
@NotEmpty	문자열이 비어 있지 않아야 함 (공백 포함)
@NotBlank	문자열이 공백이 아니어야 함 (공백만 입력 불가)
@Size(min, max)	문자열 또는 컬렉션의 크기 제한
@Min(value)	숫자가 특정 값 이상이어야 함
@Max(value)	숫자가 특정 값 이하이어야 함
@Pattern(regexp)	정규식을 만족해야 함 (이메일, 전화번호 등)
이 애노테이션들을 DTO 클래스에 적용하면 컨트롤러에서 데이터를 받을 때 자동으로 검증이 이루어진다.

2. DTO에서 데이터 검증 적용
API 요청 시 클라이언트가 전송한 데이터를 검증하려면 DTO 클래스에 적절한 검증 애노테이션을 추가해야 한다.

예제: 사용자 생성 요청 데이터 검증

package com.example.dto;

import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class UserRequestDTO {

    @NotBlank(message = "이름은 필수 입력 값입니다.")
    @Size(min = 2, max = 20, message = "이름은 2자 이상 20자 이하로 입력해야 합니다.")
    private String name;

    @NotBlank(message = "이메일은 필수 입력 값입니다.")
    @Email(message = "유효한 이메일 주소를 입력하세요.")
    private String email;

    @NotNull(message = "나이는 필수 입력 값입니다.")
    @Min(value = 18, message = "나이는 18세 이상이어야 합니다.")
    @Max(value = 100, message = "나이는 100세 이하여야 합니다.")
    private Integer age;

    public UserRequestDTO() {}

    public UserRequestDTO(String name, String email, Integer age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
설명
@NotBlank: 빈 문자열 입력 방지 (null과 빈 문자열 "" 모두 허용하지 않음).
@Size(min = 2, max = 20): 문자열의 길이 제한.
@Email: 이메일 형식 검증.
@Min(18), @Max(100): 나이 범위 제한.
이제 컨트롤러에서 이 DTO를 @Valid와 함께 사용하면 요청 데이터의 유효성을 자동으로 검증할 수 있다.

3. 컨트롤러에서 @Valid를 활용한 데이터 검증
검증 애노테이션을 적용한 DTO를 컨트롤러의 요청 본문에 받을 때, @Valid를 사용하여 자동으로 검증을 수행할 수 있다.
만약 유효하지 않은 데이터가 들어오면 예외(Exception)가 발생하며, 이를 적절히 처리해야 한다.

package com.example.controller;

import com.example.dto.UserRequestDTO;
import com.example.dto.UserResponseDTO;
import com.example.service.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@RestController
@RequestMapping("/api/users")
@Validated
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public ResponseEntity<UserResponseDTO> createUser(@Valid @RequestBody UserRequestDTO userRequestDTO) {
        UserResponseDTO newUser = userService.createUser(userRequestDTO);
        return ResponseEntity.status(201).body(newUser);
    }
}
설명
@Valid @RequestBody UserRequestDTO userRequestDTO:
@Valid를 사용하면 DTO의 검증 애노테이션이 자동으로 적용됨.
유효성 검사를 통과하지 못하면 MethodArgumentNotValidException 예외 발생.
ResponseEntity.status(201).body(newUser): 성공적으로 생성된 데이터를 반환.
클라이언트에서 잘못된 요청을 보냈을 때 (예시)

{
  "name": "",
  "email": "invalid-email",
  "age": 15
}
이 경우, 400 Bad Request 응답과 함께 예외 메시지를 반환해야 한다.

4. @ExceptionHandler를 이용한 예외 처리
Spring Boot에서는 @ExceptionHandler를 활용하여 특정 예외를 잡아 사용자 친화적인 응답을 제공할 수 있다.

예제: @ExceptionHandler로 검증 예외 처리

package com.example.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();

        ex.getBindingResult().getFieldErrors().forEach(error ->
                errors.put(error.getField(), error.getDefaultMessage()));

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }
}
설명
@RestControllerAdvice: 모든 컨트롤러에서 발생하는 예외를 전역적으로 처리하는 역할.
@ExceptionHandler(MethodArgumentNotValidException.class):
@Valid 검증 실패 시 발생하는 MethodArgumentNotValidException을 처리.
getBindingResult().getFieldErrors()를 사용하여 필드별 오류 메시지를 추출하여 JSON 형식으로 응답.
잘못된 요청을 보냈을 때의 응답 예시

{
  "name": "이름은 필수 입력 값입니다.",
  "email": "유효한 이메일 주소를 입력하세요.",
  "age": "나이는 18세 이상이어야 합니다."
}
name, email, age 필드에 대한 구체적인 오류 메시지를 반환.
5. @ControllerAdvice를 이용한 전역 예외 처리
@RestControllerAdvice와 유사하지만, @ControllerAdvice는 일반 @Controller에도 적용 가능하다.

package com.example.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionAdvice {

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<String> handleRuntimeException(RuntimeException ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("서버 내부 오류: " + ex.getMessage());
    }
}
모든 RuntimeException을 처리하고 500 Internal Server Error로 응답.
학습자의 사고를 돕기 위한 질문
API에서 데이터 검증을 해야 하는 이유는 무엇인가?

데이터 무결성을 보장하고, 잘못된 입력이 시스템에 영향을 미치지 않도록 하기 위한 이유를 고려해보라.
@Valid 어노테이션을 사용하는 이유는 무엇인가?

@Valid 어노테이션이 데이터 검증에 어떻게 사용되는지와 그 필요성에 대해 생각해보라.
예외가 발생했을 때, 전역적으로 예외를 처리하는 방법은 무엇인가?

@ExceptionHandler와 @ControllerAdvice를 사용하여 발생한 예외를 어떻게 처리하는지 생각해보라.
실습 문제
문제 1: 데이터 검증하기
다음 요구사항을 만족하는 데이터를 검증하는 로직을 작성하시오.

ProductDTO 클래스에는 name과 price 필드가 있다.
name은 null이 아니고, price는 0보다 커야 한다.
클라이언트에서 보내는 데이터를 검증하여 유효한 데이터만 받아들이도록 한다.
유효하지 않은 데이터가 들어왔을 경우, 적절한 예외를 반환한다.
문제 2: 예외 처리하기
다음 요구사항을 만족하는 예외 처리 로직을 작성하시오.

클라이언트에서 잘못된 데이터를 보내면 ProductNotFoundException 예외가 발생한다.
이 예외가 발생했을 때, @ExceptionHandler로 예외를 처리하고, 클라이언트에게 적절한 오류 메시지를 반환한다.
5. 인증 및 보안 적용
5.1. Spring Security 기반 인증 및 인가
Spring Boot 애플리케이션에서 보안(Security) 은 필수적으로 고려해야 할 요소이다.
특히, RESTful API를 제공하는 서비스에서는 인가(Authorization) 및 인증(Authentication) 을 효과적으로 설정해야 한다.
이를 위해 Spring Boot에서 제공하는 Spring Security 프레임워크를 활용할 수 있다.

이 파트에서는 Spring Security를 적용하여 사용자 인증과 역할(Role) 기반 인가를 설정하는 방법을 설명한다.

1. Spring Security 개요
Spring Security는 Spring 기반 애플리케이션의 보안 설정을 담당하는 강력한 프레임워크로,
기본적으로 로그인, 권한 관리, 요청 필터링 등의 기능을 제공한다.

Spring Security의 주요 기능은 다음과 같다.

인증(Authentication): 사용자가 본인이 맞는지를 확인하는 과정.
인가(Authorization): 특정 기능에 대한 접근 권한을 검사하는 과정.
보안 필터(Security Filter Chain): 요청이 들어왔을 때, 특정 경로에 대한 접근을 제어.
CSRF 보호: 크로스 사이트 요청 위조 공격 방지.
비밀번호 암호화: 비밀번호 저장 시 해싱 처리 (BCrypt 등 사용).
Spring Boot에서는 기본적으로 spring-boot-starter-security 의존성을 추가하는 것만으로도 보안 기능이 활성화된다.

2. Spring Security 의존성 추가
Spring Boot 프로젝트에서 Spring Security를 사용하려면 spring-boot-starter-security 의존성을 추가해야 한다.

Maven 기준:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
Gradle 기준:

implementation 'org.springframework.boot:spring-boot-starter-security'
위 의존성을 추가하고 프로젝트를 실행하면, 기본적으로 모든 API 요청이 인증을 요구하는 상태가 된다.

3. Spring Security 기본 동작
Spring Security를 추가하면 기본적으로 모든 API 요청이 인증을 필요로 하는 상태가 된다.
즉, 사용자 로그인을 하지 않으면 어떠한 요청도 허용되지 않는다.

Spring Boot는 기본적으로 기본 사용자 계정(username, password)를 자동 생성하며,
로그인 시 username은 user, 비밀번호는 애플리케이션 실행 시 로그에 출력된다.

Using generated security password: 4a5c1b2d-xxxx-xxxx-xxxx-xxxxxxxxxxxx
이제, http://localhost:8080 에 접근하면 브라우저에서 로그인 창이 나타나며,
로그에 출력된 비밀번호를 입력해야 접근이 가능하다.

4. Spring Security 설정을 커스텀하기
Spring Security의 기본 설정을 유지하면 개발 중에 불편하기 때문에,
보안 설정을 커스텀하여 특정 경로를 비인증 상태에서도 접근 가능하도록 설정할 수 있다.

예제: SecurityConfig 설정

package com.example.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable() // CSRF 보호 비활성화 (API 서버에서는 일반적으로 비활성화)
            .authorizeHttpRequests(auth -> auth
                .antMatchers("/api/public/**").permitAll()  // 인증 없이 접근 가능
                .antMatchers("/api/admin/**").hasRole("ADMIN") // ADMIN 역할 필요
                .anyRequest().authenticated() // 나머지 요청은 인증 필요
            )
            .formLogin() // 기본 로그인 폼 사용
            .and()
            .httpBasic(); // HTTP Basic 인증 활성화

        return http.build();
    }
}
5. 설정 설명
위 코드에서 설정한 SecurityConfig 클래스는 애플리케이션의 보안 설정을 담당하며,
다음과 같은 주요 보안 정책을 정의하고 있다.

CSRF 보호 비활성화

http.csrf().disable() 설정을 통해 API 서버에서는 CSRF 보호를 해제한다.
REST API 서버에서는 일반적으로 csrf 를 비활성화한다.
인증 및 권한 설정

antMatchers("/api/public/**").permitAll() → /api/public/ 이하의 모든 경로는 인증 없이 접근 가능.
antMatchers("/api/admin/**").hasRole("ADMIN") → /api/admin/ 경로는 ADMIN 역할을 가진 사용자만 접근 가능.
anyRequest().authenticated() → 그 외의 모든 요청은 로그인 필요.
로그인 및 인증 방식

formLogin() → 기본 제공 로그인 폼 사용.
httpBasic() → HTTP Basic 인증 방식 사용.
6. 사용자 인증 및 역할(Role) 설정
Spring Security를 활용하려면 사용자 계정 정보 및 역할(ROLE) 기반 접근 제어가 필요하다.
이를 위해 UserDetailsService 인터페이스를 구현하여 커스텀 사용자 인증을 설정할 수 있다.

예제: 사용자 정보 관리 서비스

package com.example.security;

import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        if ("admin".equals(username)) {
            return User.withUsername("admin")
                    .password("{noop}password") // {noop}은 비밀번호 암호화 없이 사용함
                    .roles("ADMIN")
                    .build();
        } else if ("user".equals(username)) {
            return User.withUsername("user")
                    .password("{noop}password")
                    .roles("USER")
                    .build();
        } else {
            throw new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username);
        }
    }
}
7. 설정 설명
위 CustomUserDetailsService 클래스는 Spring Security의 UserDetailsService 인터페이스를 구현한 것이다.

loadUserByUsername(String username) 메서드를 통해 사용자 정보를 조회한다.
User.withUsername("admin").password("{noop}password").roles("ADMIN"):
admin 사용자는 ADMIN 역할을 가지며, 비밀번호는 "password"이다.
User.withUsername("user").password("{noop}password").roles("USER"):
user 사용자는 USER 역할을 가지며, 비밀번호는 "password"이다.
이제, 애플리케이션을 실행한 후 다음과 같은 요청을 테스트할 수 있다.

로그인 테스트

admin 계정: username: admin, password: password
user 계정: username: user, password: password
권한 테스트

/api/public/**: 인증 없이 접근 가능.
/api/admin/**: ADMIN 역할이 있어야 접근 가능.
/api/**: 기본적으로 로그인 필요.
5. 인증 및 보안 적용
5.1. Spring Security 기반 인증 및 인가
Spring Boot 애플리케이션에서 보안(Security) 은 필수적으로 고려해야 할 요소이다.
특히, RESTful API를 제공하는 서비스에서는 인가(Authorization) 및 인증(Authentication) 을 효과적으로 설정해야 한다.
이를 위해 Spring Boot에서 제공하는 Spring Security 프레임워크를 활용할 수 있다.

이 파트에서는 Spring Security를 적용하여 사용자 인증과 역할(Role) 기반 인가를 설정하는 방법을 설명한다.

1. Spring Security 개요
Spring Security는 Spring 기반 애플리케이션의 보안 설정을 담당하는 강력한 프레임워크로,
기본적으로 로그인, 권한 관리, 요청 필터링 등의 기능을 제공한다.

Spring Security의 주요 기능은 다음과 같다.

인증(Authentication): 사용자가 본인이 맞는지를 확인하는 과정.
인가(Authorization): 특정 기능에 대한 접근 권한을 검사하는 과정.
보안 필터(Security Filter Chain): 요청이 들어왔을 때, 특정 경로에 대한 접근을 제어.
CSRF 보호: 크로스 사이트 요청 위조 공격 방지.
비밀번호 암호화: 비밀번호 저장 시 해싱 처리 (BCrypt 등 사용).
Spring Boot에서는 기본적으로 spring-boot-starter-security 의존성을 추가하는 것만으로도 보안 기능이 활성화된다.

2. Spring Security 의존성 추가
Spring Boot 프로젝트에서 Spring Security를 사용하려면 spring-boot-starter-security 의존성을 추가해야 한다.

Maven 기준:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
Gradle 기준:

implementation 'org.springframework.boot:spring-boot-starter-security'
위 의존성을 추가하고 프로젝트를 실행하면, 기본적으로 모든 API 요청이 인증을 요구하는 상태가 된다.

3. Spring Security 기본 동작
Spring Security를 추가하면 기본적으로 모든 API 요청이 인증을 필요로 하는 상태가 된다.
즉, 사용자 로그인을 하지 않으면 어떠한 요청도 허용되지 않는다.

Spring Boot는 기본적으로 기본 사용자 계정(username, password)를 자동 생성하며,
로그인 시 username은 user, 비밀번호는 애플리케이션 실행 시 로그에 출력된다.

Using generated security password: 4a5c1b2d-xxxx-xxxx-xxxx-xxxxxxxxxxxx
이제, http://localhost:8080 에 접근하면 브라우저에서 로그인 창이 나타나며,
로그에 출력된 비밀번호를 입력해야 접근이 가능하다.

4. Spring Security 설정을 커스텀하기
Spring Security의 기본 설정을 유지하면 개발 중에 불편하기 때문에,
보안 설정을 커스텀하여 특정 경로를 비인증 상태에서도 접근 가능하도록 설정할 수 있다.

예제: SecurityConfig 설정

package com.example.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable() // CSRF 보호 비활성화 (API 서버에서는 일반적으로 비활성화)
            .authorizeHttpRequests(auth -> auth
                .antMatchers("/api/public/**").permitAll()  // 인증 없이 접근 가능
                .antMatchers("/api/admin/**").hasRole("ADMIN") // ADMIN 역할 필요
                .anyRequest().authenticated() // 나머지 요청은 인증 필요
            )
            .formLogin() // 기본 로그인 폼 사용
            .and()
            .httpBasic(); // HTTP Basic 인증 활성화

        return http.build();
    }
}
5. 설정 설명
위 코드에서 설정한 SecurityConfig 클래스는 애플리케이션의 보안 설정을 담당하며,
다음과 같은 주요 보안 정책을 정의하고 있다.

CSRF 보호 비활성화

http.csrf().disable() 설정을 통해 API 서버에서는 CSRF 보호를 해제한다.
REST API 서버에서는 일반적으로 csrf 를 비활성화한다.
인증 및 권한 설정

antMatchers("/api/public/**").permitAll() → /api/public/ 이하의 모든 경로는 인증 없이 접근 가능.
antMatchers("/api/admin/**").hasRole("ADMIN") → /api/admin/ 경로는 ADMIN 역할을 가진 사용자만 접근 가능.
anyRequest().authenticated() → 그 외의 모든 요청은 로그인 필요.
로그인 및 인증 방식

formLogin() → 기본 제공 로그인 폼 사용.
httpBasic() → HTTP Basic 인증 방식 사용.
6. 사용자 인증 및 역할(Role) 설정
Spring Security를 활용하려면 사용자 계정 정보 및 역할(ROLE) 기반 접근 제어가 필요하다.
이를 위해 UserDetailsService 인터페이스를 구현하여 커스텀 사용자 인증을 설정할 수 있다.

예제: 사용자 정보 관리 서비스

package com.example.security;

import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        if ("admin".equals(username)) {
            return User.withUsername("admin")
                    .password("{noop}password") // {noop}은 비밀번호 암호화 없이 사용함
                    .roles("ADMIN")
                    .build();
        } else if ("user".equals(username)) {
            return User.withUsername("user")
                    .password("{noop}password")
                    .roles("USER")
                    .build();
        } else {
            throw new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username);
        }
    }
}
7. 설정 설명
위 CustomUserDetailsService 클래스는 Spring Security의 UserDetailsService 인터페이스를 구현한 것이다.

loadUserByUsername(String username) 메서드를 통해 사용자 정보를 조회한다.
User.withUsername("admin").password("{noop}password").roles("ADMIN"):
admin 사용자는 ADMIN 역할을 가지며, 비밀번호는 "password"이다.
User.withUsername("user").password("{noop}password").roles("USER"):
user 사용자는 USER 역할을 가지며, 비밀번호는 "password"이다.
이제, 애플리케이션을 실행한 후 다음과 같은 요청을 테스트할 수 있다.

로그인 테스트

admin 계정: username: admin, password: password
user 계정: username: user, password: password
권한 테스트

/api/public/**: 인증 없이 접근 가능.
/api/admin/**: ADMIN 역할이 있어야 접근 가능.
/api/**: 기본적으로 로그인 필요.
학습자의 사고를 돕기 위한 질문
Spring Security에서 인증(Authentication)과 인가(Authorization)의 차이점은 무엇인가?

인증은 사용자 본인 확인을 의미하며, 인가는 사용자가 리소스에 접근할 수 있는지의 권한을 의미한다.
Spring Security에서 기본적인 인증을 구현하려면 어떤 설정이 필요한가?

인증을 위한 SecurityConfig 클래스 설정과 인증에 필요한 서비스의 구성을 떠올려보라.
Spring Security에서 @PreAuthorize 어노테이션을 사용하여 권한 기반 접근 제어를 설정하는 방법은 무엇인가?

메소드 실행 전에 권한을 체크하는 방법에 대해 생각해보라.
5.2. JWT 인증 시스템 구축
JWT (JSON Web Token)는 토큰 기반 인증 방식 중 하나로, RESTful API에서 널리 사용된다.
Spring Security와 JWT를 결합하면 세션 기반 인증 없이 사용자의 로그인 상태를 유지할 수 있으며,
각 요청마다 토큰을 포함하여 인증을 수행할 수 있다.

이 파트에서는 JWT를 활용한 인증 시스템 구축을 설명한다.

1. JWT 개요
JWT는 Header, Payload, Signature 세 부분으로 구성된다.

Header: 토큰의 타입(JWT)과 서명 알고리즘(HS256 등)을 포함.
Payload: 사용자의 정보(이름, 이메일, 권한 등) 및 토큰의 유효 기간이 포함됨.
Signature: Header와 Payload를 암호화하여 변조 여부를 확인.
예제 JWT 토큰 구조

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  // Header (Base64 인코딩)
.
eyJzdWIiOiJ1c2VyMSIsImlhdCI6MTY0NTgxMTI3NSwiZXhwIjoxNjQ1ODE0ODc1fQ  // Payload (Base64 인코딩)
.
g3StZoQ2yMhxLXNc8jGHfKpl08-JXtb_XNUE9kMEnoM  // Signature (서명)
각 요청에 이 토큰을 포함하여 서버에서 검증한 후 접근을 허용한다.

2. JWT 관련 의존성 추가
JWT를 다루기 위해서는 jjwt (io.jsonwebtoken 라이브러리) 를 사용한다.

Maven 기준

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.11.5</version>
</dependency>
Gradle 기준

implementation 'io.jsonwebtoken:jjwt:0.11.5'
3. JWT 토큰 생성 및 검증 로직
JWT를 생성하고 검증하기 위한 JwtTokenProvider 클래스를 만든다.

예제: JwtTokenProvider

package com.example.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String secretKey;

    private final long validityInMilliseconds = 3600000; // 1시간 (1시간 = 3600000ms)

    // JWT 토큰 생성
    public String createToken(String username, String role) {
        Claims claims = Jwts.claims().setSubject(username);
        claims.put("role", role);

        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInMilliseconds);

        return Jwts.builder()
                .setClaims(claims)
                .setIssuedAt(now)
                .setExpiration(validity)
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();
    }

    // JWT 토큰에서 사용자 이름 추출
    public String getUsername(String token) {
        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getSubject();
    }

    // JWT 토큰 유효성 검사
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
4. JWT 필터 설정 (OncePerRequestFilter)
JWT는 요청마다 포함되어야 하므로,
JWT 필터(OncePerRequestFilter)를 생성하여 모든 요청에 대해 JWT를 검사하도록 한다.

예제: JwtTokenFilter

package com.example.security.jwt;

import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

@Component
public class JwtTokenFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final UserDetailsService userDetailsService;

    public JwtTokenFilter(JwtTokenProvider jwtTokenProvider, UserDetailsService userDetailsService) {
        this.jwtTokenProvider = jwtTokenProvider;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, javax.servlet.http.HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String token = resolveToken(request);

        if (token != null && jwtTokenProvider.validateToken(token)) {
            String username = jwtTokenProvider.getUsername(token);
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    // 요청 헤더에서 JWT 토큰을 가져오는 메서드
    private String resolveToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
5. Spring Security와 JWT 연동
Spring Security의 설정 파일을 수정하여 JWT 필터를 적용한다.

예제: SecurityConfig

package com.example.security.config;

import com.example.security.jwt.JwtTokenFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    private final JwtTokenFilter jwtTokenFilter;

    public SecurityConfig(JwtTokenFilter jwtTokenFilter) {
        this.jwtTokenFilter = jwtTokenFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // JWT를 사용하므로 세션 사용 안 함
            .and()
            .authorizeHttpRequests(auth -> auth
                .antMatchers("/api/auth/**").permitAll() // 로그인, 회원가입은 인증 없이 허용
                .antMatchers("/api/user/**").hasRole("USER")
                .antMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtTokenFilter, UsernamePasswordAuthenticationFilter.class); // JWT 필터 추가

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}
6. 로그인 및 JWT 발급 API 구현
사용자가 로그인을 요청하면, JWT 토큰을 생성하여 응답하도록 API를 구현한다.

예제: AuthController

package com.example.security.controller;

import com.example.security.jwt.JwtTokenProvider;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;

    public AuthController(AuthenticationManager authenticationManager, JwtTokenProvider jwtTokenProvider) {
        this.authenticationManager = authenticationManager;
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @PostMapping("/login")
    public ResponseEntity<Map<String, String>> login(@RequestBody Map<String, String> request) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.get("username"), request.get("password"))
        );

        String token = jwtTokenProvider.createToken(request.get("username"), "USER");
        return ResponseEntity.ok(Map.of("token", token));
    }
}
5.2. JWT 인증 시스템 구축
JWT (JSON Web Token)는 토큰 기반 인증 방식 중 하나로, RESTful API에서 널리 사용된다.
Spring Security와 JWT를 결합하면 세션 기반 인증 없이 사용자의 로그인 상태를 유지할 수 있으며,
각 요청마다 토큰을 포함하여 인증을 수행할 수 있다.

이 파트에서는 JWT를 활용한 인증 시스템 구축을 설명한다.

1. JWT 개요
JWT는 Header, Payload, Signature 세 부분으로 구성된다.

Header: 토큰의 타입(JWT)과 서명 알고리즘(HS256 등)을 포함.
Payload: 사용자의 정보(이름, 이메일, 권한 등) 및 토큰의 유효 기간이 포함됨.
Signature: Header와 Payload를 암호화하여 변조 여부를 확인.
예제 JWT 토큰 구조

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  // Header (Base64 인코딩)
.
eyJzdWIiOiJ1c2VyMSIsImlhdCI6MTY0NTgxMTI3NSwiZXhwIjoxNjQ1ODE0ODc1fQ  // Payload (Base64 인코딩)
.
g3StZoQ2yMhxLXNc8jGHfKpl08-JXtb_XNUE9kMEnoM  // Signature (서명)
각 요청에 이 토큰을 포함하여 서버에서 검증한 후 접근을 허용한다.

2. JWT 관련 의존성 추가
JWT를 다루기 위해서는 jjwt (io.jsonwebtoken 라이브러리) 를 사용한다.

Maven 기준

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.11.5</version>
</dependency>
Gradle 기준

implementation 'io.jsonwebtoken:jjwt:0.11.5'
3. JWT 토큰 생성 및 검증 로직
JWT를 생성하고 검증하기 위한 JwtTokenProvider 클래스를 만든다.

예제: JwtTokenProvider

package com.example.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String secretKey;

    private final long validityInMilliseconds = 3600000; // 1시간 (1시간 = 3600000ms)

    // JWT 토큰 생성
    public String createToken(String username, String role) {
        Claims claims = Jwts.claims().setSubject(username);
        claims.put("role", role);

        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInMilliseconds);

        return Jwts.builder()
                .setClaims(claims)
                .setIssuedAt(now)
                .setExpiration(validity)
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();
    }

    // JWT 토큰에서 사용자 이름 추출
    public String getUsername(String token) {
        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getSubject();
    }

    // JWT 토큰 유효성 검사
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
4. JWT 필터 설정 (OncePerRequestFilter)
JWT는 요청마다 포함되어야 하므로,
JWT 필터(OncePerRequestFilter)를 생성하여 모든 요청에 대해 JWT를 검사하도록 한다.

예제: JwtTokenFilter

package com.example.security.jwt;

import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

@Component
public class JwtTokenFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final UserDetailsService userDetailsService;

    public JwtTokenFilter(JwtTokenProvider jwtTokenProvider, UserDetailsService userDetailsService) {
        this.jwtTokenProvider = jwtTokenProvider;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, javax.servlet.http.HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String token = resolveToken(request);

        if (token != null && jwtTokenProvider.validateToken(token)) {
            String username = jwtTokenProvider.getUsername(token);
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    // 요청 헤더에서 JWT 토큰을 가져오는 메서드
    private String resolveToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
5. Spring Security와 JWT 연동
Spring Security의 설정 파일을 수정하여 JWT 필터를 적용한다.

예제: SecurityConfig

package com.example.security.config;

import com.example.security.jwt.JwtTokenFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    private final JwtTokenFilter jwtTokenFilter;

    public SecurityConfig(JwtTokenFilter jwtTokenFilter) {
        this.jwtTokenFilter = jwtTokenFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // JWT를 사용하므로 세션 사용 안 함
            .and()
            .authorizeHttpRequests(auth -> auth
                .antMatchers("/api/auth/**").permitAll() // 로그인, 회원가입은 인증 없이 허용
                .antMatchers("/api/user/**").hasRole("USER")
                .antMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtTokenFilter, UsernamePasswordAuthenticationFilter.class); // JWT 필터 추가

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}
6. 로그인 및 JWT 발급 API 구현
사용자가 로그인을 요청하면, JWT 토큰을 생성하여 응답하도록 API를 구현한다.

예제: AuthController

package com.example.security.controller;

import com.example.security.jwt.JwtTokenProvider;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;

    public AuthController(AuthenticationManager authenticationManager, JwtTokenProvider jwtTokenProvider) {
        this.authenticationManager = authenticationManager;
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @PostMapping("/login")
    public ResponseEntity<Map<String, String>> login(@RequestBody Map<String, String> request) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.get("username"), request.get("password"))
        );

        String token = jwtTokenProvider.createToken(request.get("username"), "USER");
        return ResponseEntity.ok(Map.of("token", token));
    }
}
실습 문제
문제 1: JWT 생성 및 검증 구현하기
다음 요구사항을 만족하는 JWT 인증 시스템을 구현하시오.

사용자가 로그인 시 username과 password를 입력한다.
로그인 시, 서버에서 JWT 토큰을 생성하고 반환한다.
클라이언트는 이 토큰을 저장하고 이후 요청 시 HTTP 헤더에 Authorization 필드로 토큰을 포함하여 요청한다.
서버는 Authorization 헤더를 통해 토큰을 검증하고, 토큰이 유효하면 요청을 처리한다.
문제 2: JWT 인증 필터 구현하기
다음 요구사항을 만족하는 JWT 인증 필터를 구현하시오.

OncePerRequestFilter를 상속받아 커스텀 필터를 작성한다.
클라이언트의 요청에서 JWT 토큰을 가져오고, 이를 검증하여 인증된 사용자인지 확인한다.
유효하지 않은 토큰일 경우 예외를 발생시킨다.
5.3. 인증 및 보안 예외 처리
Spring Security와 JWT 기반 인증 시스템을 적용한 후, 다양한 인증 및 인가 관련 예외 처리를 추가해야 한다.
사용자가 올바르지 않은 자격 증명을 입력하거나, 권한이 없는 리소스에 접근하려고 할 때
적절한 응답을 반환하여 클라이언트에서 적절한 조치를 할 수 있도록 해야 한다.

이 파트에서는 로그인 실패, 인증 실패, 접근 권한 부족 등의 예외 처리 방법을 설명한다.

1. 인증 및 보안 예외 처리 개요
Spring Security에서는 인증과 권한 검사를 수행하는 과정에서 다양한 예외가 발생할 수 있다.

인증 실패 (AuthenticationException)

잘못된 사용자명 또는 비밀번호 입력 시 발생
처리 클래스: AuthenticationEntryPoint
인가(권한) 실패 (AccessDeniedException)

특정 역할(Role)이 필요한 엔드포인트에 접근하려 할 때 권한이 없으면 발생
처리 클래스: AccessDeniedHandler
이 두 가지 예외를 적절하게 처리하여 사용자 경험을 개선하고,
보안적으로도 민감한 정보를 노출하지 않도록 구성해야 한다.

2. 인증 실패 처리 (AuthenticationEntryPoint)
잘못된 사용자 인증 정보로 요청이 들어왔을 때 401 Unauthorized 응답을 반환하도록 설정한다.

예제: CustomAuthenticationEntryPoint

package com.example.security.exception;

import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "인증 실패: 잘못된 로그인 정보입니다.");
    }
}
이제 인증되지 않은 사용자가 보호된 리소스에 접근하면, 401 응답과 함께 "인증 실패" 메시지가 반환된다.

3. 접근 권한 부족 처리 (AccessDeniedHandler)
로그인된 사용자가 특정 엔드포인트에 접근할 권한이 없을 경우,
403 Forbidden 응답을 반환하도록 처리한다.

예제: CustomAccessDeniedHandler

package com.example.security.exception;

import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException {
        response.sendError(HttpServletResponse.SC_FORBIDDEN, "권한 부족: 해당 리소스에 접근할 수 없습니다.");
    }
}
이제 로그인된 사용자가 접근 권한이 없는 엔드포인트에 접근하면,
403 응답과 함께 "권한 부족" 메시지가 반환된다.

4. 예외 처리 설정을 Spring Security에 적용
위에서 만든 AuthenticationEntryPoint와 AccessDeniedHandler를 Spring Security 설정 파일에 적용한다.

예제: SecurityConfig

package com.example.security.config;

import com.example.security.exception.CustomAccessDeniedHandler;
import com.example.security.exception.CustomAuthenticationEntryPoint;
import com.example.security.jwt.JwtTokenFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    private final JwtTokenFilter jwtTokenFilter;
    private final CustomAuthenticationEntryPoint authenticationEntryPoint;
    private final CustomAccessDeniedHandler accessDeniedHandler;

    public SecurityConfig(JwtTokenFilter jwtTokenFilter, CustomAuthenticationEntryPoint authenticationEntryPoint,
                          CustomAccessDeniedHandler accessDeniedHandler) {
        this.jwtTokenFilter = jwtTokenFilter;
        this.authenticationEntryPoint = authenticationEntryPoint;
        this.accessDeniedHandler = accessDeniedHandler;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(auth -> auth
                .antMatchers("/api/auth/**").permitAll()
                .antMatchers("/api/user/**").hasRole("USER")
                .antMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint) // 인증 실패 처리 적용
                .accessDeniedHandler(accessDeniedHandler) // 권한 부족 처리 적용
            .and()
            .addFilterBefore(jwtTokenFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}
위 설정의 주요 기능

authenticationEntryPoint(authenticationEntryPoint)
인증되지 않은 사용자가 접근하면 401 Unauthorized 응답을 반환.
accessDeniedHandler(accessDeniedHandler)
인증된 사용자라도 권한이 없으면 403 Forbidden 응답을 반환.
5. 인증 및 보안 예외 처리 테스트
이제 JWT를 적용한 인증 시스템에서,
잘못된 로그인 시도와 접근 권한 부족 상황에서 예외 처리가 정상적으로 동작하는지 확인해야 한다.

테스트 1: 인증되지 않은 사용자가 보호된 리소스 접근

GET /api/user/profile HTTP/1.1
Host: example.com
응답 (401 Unauthorized)

{
  "error": "인증 실패: 잘못된 로그인 정보입니다."
}
테스트 2: 로그인은 했지만 권한이 부족한 사용자가 관리자 리소스 접근

GET /api/admin/dashboard HTTP/1.1
Host: example.com
Authorization: Bearer {USER_ROLE_JWT_TOKEN}
응답 (403 Forbidden)

{
  "error": "권한 부족: 해당 리소스에 접근할 수 없습니다."
}
이제 인증되지 않았거나 권한이 부족한 경우에 적절한 오류 응답이 반환되는지 확인할 수 있다.

학습자의 사고를 돕기 위한 질문
Spring Security에서 AccessDeniedHandler와 AuthenticationEntryPoint의 역할은 무엇인가?

AccessDeniedHandler는 권한 부족에 대한 처리를 담당하고, AuthenticationEntryPoint는 인증이 필요할 때의 처리를 담당한다.
JWT 토큰이 만료되었을 때 발생할 수 있는 예외를 처리하는 방법은 무엇인가?

토큰 만료 예외를 처리하고, 만료된 토큰에 대해 적절한 응답을 반환하는 방법을 생각해보라.
Spring Security에서 커스텀 예외 처리 방법은 무엇인가?

예외 발생 시 전역적으로 처리할 수 있도록 @ControllerAdvice를 활용하는 방법을 떠올려보라.
실습 문제
문제 1: 권한 부족 예외 처리하기
다음 요구사항을 만족하는 권한 부족 예외 처리 로직을 작성하시오.

사용자가 ADMIN 권한을 요구하는 리소스에 접근하려고 시도했을 때, AccessDeniedException 예외를 발생시킨다.
예외가 발생하면 AccessDeniedHandler에서 이를 처리하고, 사용자에게 적절한 메시지를 반환한다.
문제 2: 인증 실패 예외 처리하기
다음 요구사항을 만족하는 인증 실패 예외 처리 로직을 작성하시오.

JWT 토큰이 없거나, 만료되었을 경우 AuthenticationEntryPoint에서 예외를 발생시킨다.
이 예외를 처리하여 사용자에게 인증이 필요한 리소스에 대한 접근을 차단하는 응답을 반환한다.
6. 예외 처리 및 로깅
6.1. 글로벌 예외 처리
Spring Boot 애플리케이션에서는 예외 처리를 어떻게 구성하는지가 매우 중요하다.
특히 RESTful API를 개발할 때는 예외가 발생했을 때 클라이언트에게 일관된 형식의 응답을 반환하는 것이 필수적이다.
이를 위해 전역 예외 처리(Global Exception Handling) 를 구현할 수 있다.

Spring은 예외 처리를 위한 몇 가지 강력한 메커니즘을 제공하는데,
그중에서 대표적인 것이 @ExceptionHandler 와 @ControllerAdvice 이다.

1. 예외 처리의 필요성
일반적으로 애플리케이션에서는 다양한 유형의 예외가 발생할 수 있다.

사용자의 입력 오류: 필수 필드 누락, 유효하지 않은 값 입력 등.
리소스 조회 실패: 데이터베이스에서 특정 데이터를 찾을 수 없는 경우.
비즈니스 로직 예외: 특정 조건을 만족하지 못할 경우 발생하는 예외.
서버 내부 오류: 예상치 못한 에러, NullPointerException 등.
이러한 예외가 발생하면 적절한 HTTP 응답 코드와 메시지를 제공하여
클라이언트가 올바르게 대응할 수 있도록 해야 한다.

2. @ExceptionHandler를 활용한 예외 처리
Spring에서 특정 컨트롤러 내에서만 예외를 처리하려면 @ExceptionHandler를 활용할 수 있다.

예제: 컨트롤러 내에서 특정 예외 처리

@RestController
@RequestMapping("/api/user")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUserById(@PathVariable Long id) {
        UserDto user = userService.findUserById(id);
        return ResponseEntity.ok(user);
    }

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<String> handleUserNotFoundException(UserNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
    }
}
위 코드를 보면 @ExceptionHandler(UserNotFoundException.class)를 이용해
특정 컨트롤러에서 UserNotFoundException이 발생했을 때 404 Not Found 응답을 반환하도록 했다.

하지만 이 방법은 컨트롤러별로 개별적으로 적용해야 하는 단점이 있다.
애플리케이션 전반에서 예외를 일관되게 처리하려면 전역 예외 처리 방식을 사용하는 것이 좋다.

3. @ControllerAdvice를 활용한 전역 예외 처리
전역 예외 처리는 @ControllerAdvice를 활용하여 애플리케이션 전체에서 발생하는 예외를 한 곳에서 처리할 수 있도록 한다.

예제: 전역 예외 처리 클래스

package com.example.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<String> handleUserNotFoundException(UserNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("사용자를 찾을 수 없습니다: " + e.getMessage());
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException e) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("잘못된 요청: " + e.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGeneralException(Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("서버 내부 오류 발생: " + e.getMessage());
    }
}
이제 UserNotFoundException이 발생하면
모든 컨트롤러에서 GlobalExceptionHandler가 자동으로 처리하여 404 응답을 반환하게 된다.

또한,

IllegalArgumentException이 발생하면 400 Bad Request를 반환.
Exception 클래스는 예상치 못한 서버 내부 오류 발생 시 500 Internal Server Error를 반환.
이렇게 하면 모든 컨트롤러에서 예외를 일관되게 처리할 수 있다.

4. 커스텀 예외 정의하기
애플리케이션의 가독성을 높이고 유지보수를 쉽게 하기 위해 커스텀 예외 클래스를 정의할 수도 있다.

예제: 사용자 정의 예외 클래스

package com.example.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
이제 UserNotFoundException을 비즈니스 로직에서 예외 상황이 발생할 때 사용할 수 있다.

5. 예외 처리 테스트
이제 예외 처리 기능이 제대로 동작하는지 확인해보자.

테스트 1: 존재하지 않는 사용자 조회

GET /api/user/999 HTTP/1.1
Host: example.com
응답 (404 Not Found)

{
  "error": "사용자를 찾을 수 없습니다: 사용자 ID 999"
}
테스트 2: 잘못된 요청 값 전달

GET /api/user/abc HTTP/1.1
Host: example.com
응답 (400 Bad Request)

{
  "error": "잘못된 요청: ID는 숫자여야 합니다."
}
6. @ResponseStatus를 활용한 예외 처리
예외 클래스에서 직접 HTTP 상태 코드를 설정할 수도 있다.
이 방법을 사용하면 예외가 발생했을 때 자동으로 해당 HTTP 응답 코드가 설정된다.

예제: @ResponseStatus를 이용한 커스텀 예외

package com.example.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
이제 UserNotFoundException이 발생하면 자동으로 404 상태 코드가 적용된다.

7. 예외 응답을 JSON 형식으로 반환하기
일반적인 API에서는 일관된 JSON 형식으로 예외 응답을 반환하는 것이 좋다.
이를 위해 별도의 에러 응답 객체를 생성하여 반환하는 방식을 사용할 수 있다.

예제: ErrorResponse DTO 생성

package com.example.dto;

import java.time.LocalDateTime;

public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;

    public ErrorResponse(int status, String error, String message) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
    }

    // Getter 생략
}
예제: JSON 응답을 반환하는 글로벌 예외 처리

package com.example.exception;

import com.example.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFoundException(UserNotFoundException e) {
        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            "User Not Found",
            e.getMessage()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }
}
학습자의 사고를 돕기 위한 질문
@ControllerAdvice를 사용하면 어떤 이점이 있는가?

전역 예외 처리를 관리하고 코드 중복을 줄이는 방법에 대해 생각해보라.
특정 예외를 처리하는 데 @ExceptionHandler를 사용할 때, 어떻게 특정 예외에만 반응하도록 설정할 수 있는가?

예외를 특정 클래스나 메시지에 기반하여 처리하는 방법을 떠올려보라.
6.2. 로깅 프레임워크 설정
애플리케이션에서 발생하는 요청 및 응답, 예외, 성능 데이터를 기록하는 것은 중요한 작업이다.
로깅은 시스템이 정상적으로 작동하는지 확인하고, 장애가 발생했을 때 문제를 신속하게 해결하는 데 도움을 준다.
Spring Boot에서는 Slf4j와 Logback을 활용한 강력한 로깅 기능을 제공한다.

1. 로깅(Log)란?
로깅(Log)은 애플리케이션 실행 중 발생하는 다양한 정보를 기록하는 작업을 의미한다.
로깅을 효과적으로 활용하면 다음과 같은 이점을 얻을 수 있다.

디버깅 및 문제 해결: 오류 발생 시 원인을 쉽게 분석 가능.
성능 모니터링: 응답 속도 및 시스템 부하 분석 가능.
보안 감사: 보안 위협 탐지 및 악의적 접근 기록 가능.
2. Spring Boot에서 로깅 설정
Spring Boot에서는 기본적으로 Slf4j(Simple Logging Facade for Java) 와 Logback을 사용한다.
Slf4j는 로깅 인터페이스 역할을 하며, Logback은 Slf4j의 구현체로 Spring Boot에서 기본적으로 설정되어 있다.

Slf4j + Logback을 활용하면 다음과 같은 기능을 제공한다.

다양한 로그 레벨 (DEBUG, INFO, WARN, ERROR)
콘솔 및 파일에 로그 출력
로그 패턴 커스터마이징
특정 패키지 또는 클래스별로 로깅 레벨 지정 가능
3. Slf4j 의존성 추가 (Maven & Gradle)
Spring Boot 프로젝트에는 기본적으로 Logback이 포함되어 있으므로 별도 설정이 필요 없지만,
Slf4j를 사용하기 위해 다음과 같은 의존성을 추가할 수 있다.

Maven 프로젝트의 경우

<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.36</version>
</dependency>
Gradle 프로젝트의 경우

dependencies {
    implementation 'org.slf4j:slf4j-api:1.7.36'
}
이제 Slf4j를 사용하여 로깅할 수 있다.

4. Slf4j를 활용한 기본 로깅 예제
Slf4j를 사용하면 간단하게 로깅을 적용할 수 있다.
다음은 컨트롤러에서 Slf4j를 사용하여 요청을 로깅하는 예제이다.

package com.example.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/log")
public class LogController {

    private static final Logger logger = LoggerFactory.getLogger(LogController.class);

    @GetMapping("/test")
    public String logTest() {
        logger.info("INFO 레벨 로그 - /api/log/test 요청 발생");
        logger.debug("DEBUG 레벨 로그 - 추가적인 디버깅 정보");
        logger.warn("WARN 레벨 로그 - 경고 메시지");
        logger.error("ERROR 레벨 로그 - 심각한 오류 발생");

        return "로그 확인";
    }
}
위 코드를 실행하면 /api/log/test 엔드포인트를 호출할 때 로그가 기록된다.

5. 로그 레벨(Level)
Slf4j에서 제공하는 주요 로그 레벨은 다음과 같다.

로그 레벨	설명
TRACE	가장 상세한 로깅, 디버깅 목적
DEBUG	개발자가 디버깅할 때 사용
INFO	일반적인 정보 기록, 운영 환경에서 주로 사용
WARN	경고 메시지, 비정상적인 동작 감지
ERROR	치명적인 오류 발생 시 사용
개발 환경에서는 DEBUG 또는 TRACE 레벨을 사용하지만,
운영 환경에서는 INFO 이상만 기록하도록 설정하는 것이 일반적이다.

6. Logback 설정 (logback-spring.xml)
Slf4j의 기본 구현체인 Logback은 logback-spring.xml 파일을 통해 설정할 수 있다.
Spring Boot에서는 이 설정 파일을 resources 디렉토리에 위치시키면 된다.

기본적인 Logback 설정 파일 (logback-spring.xml)

<configuration>
    <!-- 콘솔에 로그 출력 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>[%d{yyyy-MM-dd HH:mm:ss}] [%level] [%thread] %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 로그 파일에 기록 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <encoder>
            <pattern>[%d{yyyy-MM-dd HH:mm:ss}] [%level] [%thread] %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>

    <!-- 로그 레벨 설정 -->
    <logger name="com.example" level="DEBUG"/>
    <root level="INFO">
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
위 설정을 적용하면:

콘솔 및 파일에 로그를 기록한다.
로그 패턴을 지정할 수 있다.
하루마다 로그 파일을 생성하고 30일간 유지한다.
7. 특정 패키지 또는 클래스별 로깅 레벨 조절
Spring Boot에서는 특정 패키지나 클래스에 대한 로깅 레벨을 조절할 수 있다.
이는 application.yml 또는 logback-spring.xml을 통해 설정 가능하다.

application.yml을 이용한 설정 예제

logging:
  level:
    root: INFO
    com.example: DEBUG
    org.springframework.web: WARN
위 설정은:

기본 로그 레벨(root)을 INFO로 설정.
com.example 패키지는 DEBUG 레벨로 설정.
Spring 내부 로그는 WARN 이상만 기록하도록 한다.
8. 예외 발생 시 로그 출력하기
로깅을 활용하면 예외 발생 시 보다 상세한 정보를 기록할 수 있다.

예제: 예외 발생 시 로그 남기기

package com.example.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    public String getUserById(Long id) {
        try {
            if (id <= 0) {
                throw new IllegalArgumentException("ID는 1 이상이어야 합니다.");
            }
            return "사용자 정보: " + id;
        } catch (IllegalArgumentException e) {
            logger.error("예외 발생 - 잘못된 ID 입력: {}", id, e);
            throw e;
        }
    }
}
위 코드에서 logger.error("예외 발생 - 잘못된 ID 입력: {}", id, e);는
예외 메시지와 함께 예외의 스택 트레이스(stack trace)까지 기록하도록 한다.

실습 문제
문제 1: Slf4j 및 Logback을 활용한 로깅 설정
다음 요구사항을 만족하는 코드를 작성하시오.

Slf4j와 Logback을 활용하여 애플리케이션에 로깅을 설정한다.
로그 레벨을 INFO, DEBUG, ERROR로 설정하여 각 상황에 맞는 로그를 출력한다.
예시: 로그인 시도 로그, 데이터베이스 쿼리 로그, 예외 발생 로그 등을 적절하게 출력한다.
문제 2: 요청 및 응답 로깅
다음 요구사항을 만족하는 코드를 작성하시오.

Spring Boot 애플리케이션에서 HTTP 요청과 응답을 로깅한다.
요청 URL, 요청 파라미터, 응답 상태 코드 등을 로깅한다.
이를 위해 필터를 구현하여 요청과 응답을 캡처하고 로그로 출력한다.
6.3. 성능 모니터링 및 디버깅
애플리케이션을 개발할 때 성능 모니터링과 디버깅은 필수적인 과정이다.
Spring Boot에서는 Spring Actuator를 활용하여 성능을 모니터링할 수 있으며,
디버깅을 위해 debug 로그와 trace 로그를 활용하는 것이 일반적이다.

1. Spring Boot Actuator란?
Spring Boot Actuator는 애플리케이션의 상태 및 성능을 모니터링할 수 있는 기능을 제공하는 라이브러리이다.
이를 활용하면 애플리케이션이 정상적으로 동작하는지 확인하고, 필요할 경우 성능 튜닝을 수행할 수 있다.

Actuator의 주요 기능

애플리케이션 상태 확인 (/actuator/health)
CPU, 메모리 사용량 모니터링 (/actuator/metrics)
실행 중인 빈(Bean) 목록 조회 (/actuator/beans)
HTTP 요청 추적 (/actuator/httptrace)
애플리케이션 정보 확인 (/actuator/info)
Spring Boot에서 Actuator를 활성화하면 기본적으로 위와 같은 기능을 제공하며, 필요에 따라 추가 설정도 가능하다.

2. Actuator 의존성 추가
Spring Boot Actuator를 사용하려면 Maven 또는 Gradle에서 의존성을 추가해야 한다.

Maven 프로젝트의 경우

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
Gradle 프로젝트의 경우

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
}
위 의존성을 추가한 후 애플리케이션을 다시 실행하면 Actuator 기능을 사용할 수 있다.

3. Actuator 설정 (application.yml)
Actuator의 기본 설정은 제한적이므로, 원하는 기능을 활성화하려면 application.yml에서 설정을 추가해야 한다.

기본 설정 예제

management:
  endpoints:
    web:
      exposure:
        include: "health,info,metrics,beans,env,httptrace"
  endpoint:
    health:
      show-details: always
위 설정을 적용하면 /actuator 엔드포인트에서 여러 가지 정보를 확인할 수 있다.

4. Actuator 주요 엔드포인트
Spring Boot Actuator에서 사용할 수 있는 대표적인 엔드포인트는 다음과 같다.

엔드포인트	설명
/actuator/health	애플리케이션의 상태 확인
/actuator/info	애플리케이션의 정보 출력
/actuator/metrics	CPU, 메모리 사용량, GC 상태 확인
/actuator/beans	애플리케이션의 빈(Bean) 목록 확인
/actuator/env	환경 변수 및 프로퍼티 확인
/actuator/httptrace	최근 HTTP 요청 기록 확인
예제: /actuator/health 호출 결과

{
  "status": "UP"
}
애플리케이션이 정상적으로 동작하고 있다면 "status": "UP"이 반환된다.

5. 성능 모니터링 예제
Spring Boot의 Actuator를 활용하여 메모리 사용량, CPU 부하, GC 상태 등을 확인할 수 있다.

예제: /actuator/metrics 호출

curl -X GET http://localhost:8080/actuator/metrics
위 명령을 실행하면 사용 가능한 메트릭 목록이 출력된다.

특정 메트릭을 조회하려면 아래와 같이 요청한다.

curl -X GET http://localhost:8080/actuator/metrics/jvm.memory.used
위 요청을 실행하면 JVM에서 사용 중인 메모리 정보를 반환한다.

응답 예제

{
  "name": "jvm.memory.used",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 528483328
    }
  ],
  "availableTags": [
    {
      "tag": "area",
      "values": ["heap", "nonheap"]
    }
  ]
}
여기서 "value": 528483328은 현재 JVM이 사용 중인 메모리 크기를 의미한다.

6. 디버깅을 위한 debug 및 trace 로그 설정
Spring Boot에서는 debug 로그와 trace 로그를 활용하여 애플리케이션의 실행 상태를 더욱 자세히 분석할 수 있다.

application.yml에서 로그 레벨 설정

logging:
  level:
    root: INFO
    org.springframework: DEBUG
    com.example: TRACE
위 설정을 적용하면:

Spring 내부 로그는 DEBUG로 출력됨
com.example 패키지는 TRACE 레벨로 설정됨 (가장 상세한 로그)
7. 특정 메서드의 실행 시간 측정
성능 분석을 위해 특정 메서드의 실행 시간을 측정하려면 System.nanoTime() 또는 StopWatch를 사용할 수 있다.

예제: StopWatch를 활용한 성능 측정

package com.example.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.util.StopWatch;

@Service
public class PerformanceService {

    private static final Logger logger = LoggerFactory.getLogger(PerformanceService.class);

    public void executeTask() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        try {
            // 실행할 로직 (예: DB 쿼리, 외부 API 호출 등)
            Thread.sleep(500);
        } catch (InterruptedException e) {
            logger.error("작업 중 예외 발생", e);
        }

        stopWatch.stop();
        logger.info("작업 실행 시간: {} ms", stopWatch.getTotalTimeMillis());
    }
}
위 코드를 실행하면 executeTask() 메서드가 실행되는 데 걸린 시간이 로그에 기록된다.

8. 예외 발생 시 스택 트레이스 출력
디버깅을 위해 예외 발생 시 스택 트레이스(stack trace)를 로그에 기록하는 것이 중요하다.

예제: 예외 로그 출력

package com.example.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class DebugService {

    private static final Logger logger = LoggerFactory.getLogger(DebugService.class);

    public void processRequest(String input) {
        try {
            int value = Integer.parseInt(input);
            logger.info("변환된 값: {}", value);
        } catch (NumberFormatException e) {
            logger.error("입력 변환 중 오류 발생: {}", input, e);
        }
    }
}
실행 결과 (예외 발생 시)

ERROR com.example.service.DebugService - 입력 변환 중 오류 발생: abc
java.lang.NumberFormatException: For input string: "abc"
    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)
    at java.base/java.lang.Integer.parseInt(Integer.java:668)
위처럼 예외 발생 시 에러 메시지와 함께 스택 트레이스가 출력되므로, 디버깅이 용이해진다.

학습자의 사고를 돕기 위한 질문
Spring Boot Actuator를 사용하면 어떤 성능 지표를 모니터링할 수 있는가?

애플리케이션의 상태와 성능을 모니터링하는 다양한 방법에 대해 생각해보라.
debug와 trace 레벨 로그를 어떻게 활용하여 디버깅을 효율적으로 할 수 있는가?

로그 레벨을 조정하여 문제 해결을 어떻게 돕는지에 대해 고민해보라.
실습 문제
문제 1: Spring Boot Actuator를 활용한 애플리케이션 모니터링
다음 요구사항을 만족하는 코드를 작성하시오.

Spring Boot Actuator를 프로젝트에 추가하고, metrics와 health 엔드포인트를 활성화한다.
애플리케이션이 실행되면 /actuator/metrics와 /actuator/health URL에서 애플리케이션의 상태와 성능 지표를 확인할 수 있도록 설정한다.
문제 2: 디버깅을 위한 debug 로그 활용
다음 요구사항을 만족하는 코드를 작성하시오.

애플리케이션에서 발생하는 주요 오류와 예외에 대해 debug 로그를 출력하도록 설정한다.
디버깅 로그를 활용하여 문제를 추적할 수 있도록 @Slf4j를 사용하여 로그 메시지를 작성한다.
7. 테스트 및 디버깅
7.1. 단위 테스트 작성
애플리케이션 개발에서 단위 테스트(Unit Test) 는 필수적인 과정이다.
단위 테스트를 통해 개별 모듈이 기대한 대로 동작하는지 확인하고,
이후 통합 테스트나 시스템 테스트에서 발생할 수 있는 문제를 사전에 방지할 수 있다.

Spring Boot에서 단위 테스트를 작성할 때는 JUnit 5와 Mockito를 활용한다.
이 두 가지 도구를 이용하면 비즈니스 로직과 데이터 액세스 계층을 효과적으로 검증할 수 있다.

1. 단위 테스트란?
단위 테스트(Unit Test)는 애플리케이션의 특정 모듈(클래스, 메서드)이 올바르게 동작하는지 확인하는 테스트이다.
Spring Boot에서는 주로 JUnit 5와 Mockito를 활용하여 단위 테스트를 진행한다.

단위 테스트의 목적

코드 변경 시 기존 기능이 정상적으로 유지되는지 확인
버그를 조기에 발견하여 유지보수 비용 절감
개발 속도 향상 및 신뢰성 확보
단위 테스트와 통합 테스트의 차이

구분	단위 테스트(Unit Test)	통합 테스트(Integration Test)
테스트 대상	개별 메서드, 클래스	여러 모듈이 상호작용
의존성	독립적 실행 (Mock 사용)	실제 DB, API와 연동
속도	빠름	상대적으로 느림
주요 도구	JUnit 5, Mockito	Spring Boot Test
2. JUnit 5 설정
Spring Boot에서 JUnit 5를 사용하려면 spring-boot-starter-test 의존성을 추가해야 한다.
Spring Boot 프로젝트를 생성하면 기본적으로 포함되어 있다.

Maven 프로젝트의 경우

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
Gradle 프로젝트의 경우

dependencies {
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
위의 의존성을 추가하면 JUnit 5와 Mockito를 활용한 단위 테스트를 작성할 수 있다.

3. 기본적인 JUnit 5 테스트 작성
JUnit 5의 @Test 어노테이션을 사용하여 단위 테스트를 작성할 수 있다.

예제: 단순한 서비스 클래스 테스트

package com.example.service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class MathServiceTest {

    @Test
    void testAddition() {
        int result = 3 + 5;
        assertEquals(8, result, "3 + 5는 8이어야 한다.");
    }
}
위 테스트는 assertEquals(기대값, 실제값, 메시지)를 이용해 검증한다.

4. Spring Boot 환경에서 서비스 계층 테스트
Spring Boot에서 서비스 계층을 테스트하려면 @SpringBootTest를 사용할 수 있지만,
단위 테스트에서는 불필요한 의존성을 줄이기 위해 @ExtendWith(MockitoExtension.class)와 @MockBean을 활용하는 것이 좋다.

예제: @MockBean을 활용한 서비스 테스트

package com.example.service;

import com.example.repository.UserRepository;
import com.example.entity.User;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void testFindUserById() {
        User mockUser = new User(1L, "John Doe", "john@example.com");
        when(userRepository.findById(1L)).thenReturn(java.util.Optional.of(mockUser));

        User result = userService.findUserById(1L);

        assertNotNull(result);
        assertEquals("John Doe", result.getName());
    }
}
설명

@Mock : 실제 UserRepository를 생성하는 대신 가짜(Mock) 객체를 만든다.
@InjectMocks : UserService의 의존성(UserRepository)을 자동으로 주입한다.
when(...).thenReturn(...) : 특정 메서드가 호출되었을 때 반환값을 지정한다.
assertNotNull(result) : 결과가 null이 아닌지 확인한다.
assertEquals("John Doe", result.getName()) : 기대값과 실제값이 일치하는지 확인한다.
5. 예외 발생 테스트 (assertThrows)
서비스 로직에서 예외가 정상적으로 발생하는지도 테스트해야 한다.

예제: 존재하지 않는 사용자를 조회할 때 예외가 발생하는지 검증

package com.example.service;

import com.example.repository.UserRepository;
import com.example.exception.UserNotFoundException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void testFindUserByIdNotFound() {
        when(userRepository.findById(99L)).thenReturn(java.util.Optional.empty());

        Exception exception = assertThrows(UserNotFoundException.class, () -> {
            userService.findUserById(99L);
        });

        assertEquals("사용자를 찾을 수 없습니다: 99", exception.getMessage());
    }
}
설명

assertThrows(예외 클래스, 실행 코드)를 사용하여 예외 발생 여부를 검증한다.
when(userRepository.findById(99L)).thenReturn(java.util.Optional.empty()) : 사용자가 존재하지 않는 경우를 가정한다.
exception.getMessage()를 통해 예외 메시지가 올바르게 반환되는지도 확인할 수 있다.
6. @MockBean을 활용한 Spring 환경 테스트
Spring Boot에서 @MockBean 을 활용하면 서비스 계층의 빈(Bean)을 테스트할 수 있다.

예제: @MockBean을 사용하여 컨트롤러 단위 테스트

package com.example.controller;

import com.example.service.UserService;
import com.example.entity.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(UserController.class)
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void testGetUserById() throws Exception {
        User mockUser = new User(1L, "John Doe", "john@example.com");
        when(userService.findUserById(1L)).thenReturn(mockUser);

        mockMvc.perform(get("/users/1"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("John Doe"));
    }
}
설명

@WebMvcTest(UserController.class) : 컨트롤러 단위 테스트를 수행할 때 사용.
MockMvc : HTTP 요청을 시뮬레이션하여 컨트롤러 테스트를 수행할 수 있도록 지원.
@MockBean : 실제 UserService 빈 대신 Mock 객체를 주입.
mockMvc.perform(get("/users/1")) : GET 요청을 보내고, 응답을 검증.
실습 문제
문제 1: 서비스 계층 단위 테스트 작성
다음 요구사항을 만족하는 단위 테스트를 작성하시오.

UserService라는 서비스 클래스가 있다. 이 클래스는 사용자 정보를 등록하는 registerUser() 메서드를 가지고 있다.
해당 메서드는 UserRepository를 사용하여 사용자 정보를 저장한다.
@MockBean을 사용하여 UserRepository를 모킹(mocking)하고, registerUser() 메서드가 제대로 동작하는지 테스트한다.
@InjectMocks를 사용하여 UserService를 주입하고, registerUser() 메서드를 호출한 후 저장된 사용자 정보를 검증한다.
7.2. API 통합 테스트
API 통합 테스트(Integration Test)는 서비스 계층과 데이터 계층을 포함하여 전체 애플리케이션의 동작을 검증하는 테스트이다.
단위 테스트가 개별 컴포넌트의 동작을 확인하는 데 초점을 맞춘다면, 통합 테스트는 애플리케이션의 여러 계층이
서로 올바르게 상호작용하는지 확인하는 것을 목표로 한다.

Spring Boot에서는 @SpringBootTest 와 TestRestTemplate, MockMvc 를 활용하여 API 통합 테스트를 수행할 수 있다.

1. API 통합 테스트란?
통합 테스트는 실제 애플리케이션 환경과 최대한 유사한 환경에서 API의 동작을 검증하는 테스트이다.

통합 테스트의 주요 특징

Spring 컨텍스트를 로드하여 실행 (단위 테스트와 달리 모든 빈(Bean)이 초기화됨)
실제 데이터베이스와 연동할 수 있음 (H2 또는 Testcontainers 활용 가능)
API 호출을 통한 응답 데이터 검증 (JSON 형식 검증 포함)
API 테스트의 종류

테스트 종류	목적	사용 도구
단위 테스트	개별 메서드가 정상적으로 동작하는지 검증	JUnit 5, Mockito
통합 테스트	서비스 및 데이터 계층을 포함한 API 테스트	@SpringBootTest, TestRestTemplate
컨트롤러 테스트	웹 계층의 API 테스트 (데이터 없이)	@WebMvcTest, MockMvc
2. API 통합 테스트 환경 설정
API 통합 테스트를 실행하려면 Spring Boot 환경을 전체적으로 로드할 필요가 있다.
이를 위해 @SpringBootTest 를 사용한다.

테스트 실행 시 필요한 주요 설정

@SpringBootTest: 전체 Spring 컨텍스트를 로드하여 테스트 환경 구성
TestRestTemplate: 실제 HTTP 요청을 수행하여 API 응답을 검증
@Transactional: 테스트 실행 후 데이터베이스 롤백 처리
H2 Database: 가벼운 인메모리 데이터베이스 활용 (옵션)
3. @SpringBootTest와 TestRestTemplate 활용
API 통합 테스트에서는 TestRestTemplate을 사용하여 실제 서버처럼 동작하는 API를 호출할 수 있다.

예제: 사용자 등록 API 테스트

package com.example.controller;

import com.example.dto.UserRequestDto;
import com.example.entity.User;
import com.example.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.http.*;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class UserControllerTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private UserRepository userRepository;

    @BeforeEach
    void setUp() {
        userRepository.deleteAll();
    }

    @Test
    void testCreateUser() {
        String url = "http://localhost:" + port + "/users";

        UserRequestDto requestDto = new UserRequestDto("John Doe", "john@example.com");
        HttpEntity<UserRequestDto> request = new HttpEntity<>(requestDto);

        ResponseEntity<User> response = restTemplate.postForEntity(url, request, User.class);

        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("John Doe", response.getBody().getName());
    }
}
설명

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT):
실제 서버를 실행하여 테스트 환경을 구성 (실제 API 호출 가능)
TestRestTemplate:
HTTP 요청을 보내 API의 응답을 검증
@BeforeEach:
테스트 실행 전 데이터베이스를 초기화하여 깨끗한 환경에서 테스트 실행
4. @WebMvcTest와 MockMvc 활용 (컨트롤러 테스트)
API 테스트에서 데이터베이스가 필요하지 않고 웹 계층만 검증하고자 할 때는 @WebMvcTest를 활용한다.

예제: @WebMvcTest를 활용한 컨트롤러 단위 테스트

package com.example.controller;

import com.example.service.UserService;
import com.example.entity.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(UserController.class)
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void testGetUserById() throws Exception {
        User mockUser = new User(1L, "John Doe", "john@example.com");
        when(userService.findUserById(1L)).thenReturn(mockUser);

        mockMvc.perform(get("/users/1"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("John Doe"));
    }
}
설명

@WebMvcTest(UserController.class):
컨트롤러 계층만 로드하여 테스트 (DB 연동 X)
MockMvc:
HTTP 요청을 가짜로 만들어 컨트롤러 테스트 수행
@MockBean:
UserService의 Mock 객체 생성 (실제 서비스 계층은 테스트 대상이 아님)
5. H2 데이터베이스를 활용한 통합 테스트
실제 데이터베이스(MySQL, PostgreSQL 등)와 연결하지 않고도 테스트를 수행할 수 있도록
H2 Database(인메모리 DB) 를 활용할 수 있다.

application-test.yml 설정 (테스트용 데이터베이스)

spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
위와 같이 설정하면 H2 데이터베이스가 메모리에서 동작하며,
테스트가 끝난 후 자동으로 초기화된다.

6. API 테스트 시 고려해야 할 사항
테스트 환경 분리

개발 환경과 테스트 환경을 분리하여,
테스트가 실제 데이터베이스나 외부 API에 영향을 주지 않도록 해야 한다.
application-test.yml을 활용하여 테스트 전용 환경을 구성한다.
테스트 데이터 관리

각 테스트 실행 전에 데이터베이스를 초기화하여
테스트 결과가 이전 데이터의 영향을 받지 않도록 한다.
@BeforeEach에서 repository.deleteAll()을 호출하여 초기화 가능.
API 응답 데이터 검증

응답이 JSON 형태로 올 경우, jsonPath("$.name").value("John Doe")
와 같이 응답 데이터의 특정 필드를 검증할 수 있다.
실습 문제
문제 1: REST API 통합 테스트
다음 요구사항을 만족하는 API 통합 테스트를 작성하시오.

@SpringBootTest를 사용하여 Spring Boot 애플리케이션을 통합 테스트한다.
UserController가 있으며, 이 컨트롤러는 사용자 정보를 POST /users 엔드포인트로 받는다.
TestRestTemplate을 사용하여 POST /users 엔드포인트에 사용자 정보를 보내고, 응답 상태 코드가 201 Created임을 확인한다.
또한, 응답 본문에 반환된 사용자 정보가 요청한 정보와 일치하는지 검증한다.
7.3. 디버깅 및 오류 분석
디버깅과 오류 분석은 애플리케이션을 유지보수하고 안정성을 확보하는 데 필수적인 과정이다.
Spring Boot 애플리케이션에서는 여러 가지 방법을 활용하여 효과적으로 디버깅할 수 있다.

디버깅 과정에서 주로 활용되는 기술과 도구는 다음과 같다.

Spring Boot DevTools: 개발 편의성을 높이기 위한 자동 재시작 및 라이브 리로드 기능 제공
로그(Log) 활용: @Slf4j를 사용한 로그 출력 및 분석
스택 트레이스(Stack Trace) 분석: 예외 발생 시 원인을 추적하는 방법
Spring Boot Actuator: 애플리케이션 상태 및 성능 모니터링
1. Spring Boot DevTools 활용
Spring Boot는 개발 편의성을 위해 DevTools(Development Tools) 를 제공한다.
이를 활용하면 애플리케이션을 실행한 상태에서 코드 변경 시 자동으로 반영할 수 있다.

Spring Boot DevTools 주요 기능

기능	설명
자동 재시작	코드 수정 후 변경 사항을 감지하여 애플리케이션 자동 재시작
라이브 리로드	HTML, CSS, JS 변경 사항을 브라우저에서 자동 반영
캐시 비활성화	개발 환경에서 정적 리소스 및 템플릿 캐싱 비활성화
의존성 추가 (Maven 기준)

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
⚠️ 주의: DevTools는 운영 환경에서는 비활성화된다.
Spring Boot는 spring-boot-devtools 의존성이 포함될 경우, prod 환경에서 자동으로 로드하지 않는다.

사용 예시

애플리케이션을 실행한 상태에서 Controller의 내용을 변경하면 변경 사항이 즉시 반영됨
HTML, CSS 수정 후 브라우저 새로고침 없이 실시간 반영됨
2. @Slf4j를 활용한 로그 디버깅
디버깅 과정에서 System.out.println() 을 사용하기보다는
Slf4j (Simple Logging Facade for Java) 를 활용하는 것이 바람직하다.

Slf4j 로그 레벨

레벨	설명
TRACE	가장 상세한 디버깅 로그
DEBUG	개발 중 디버깅 목적의 로그
INFO	주요 이벤트 및 정상적인 흐름
WARN	비정상적인 동작이나 위험 경고
ERROR	애플리케이션 오류 발생 시 사용
Slf4j 설정 및 사용 예제

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Slf4j
@Service
public class UserService {

    public void processUser(String username) {
        log.info("사용자 처리 시작: {}", username);

        try {
            if (username == null) {
                throw new IllegalArgumentException("사용자 이름이 없습니다.");
            }
            log.debug("정상적으로 사용자 처리 완료: {}", username);
        } catch (Exception e) {
            log.error("사용자 처리 중 오류 발생: {}", e.getMessage(), e);
        }
    }
}
로그 출력 예시

2025-02-20 10:00:00.123  INFO 12345 --- [  main] com.example.service.UserService : 사용자 처리 시작: JohnDoe
2025-02-20 10:00:00.124 DEBUG 12345 --- [  main] com.example.service.UserService : 정상적으로 사용자 처리 완료: JohnDoe
⚠️ 주의: DEBUG 및 TRACE 레벨은 운영 환경에서는 출력되지 않도록 application.yml에서 설정해야 한다.

로그 레벨 설정 (application.yml)

logging:
  level:
    root: INFO
    com.example: DEBUG
root: INFO → 전체 애플리케이션 기본 로그 레벨을 INFO로 설정
com.example: DEBUG → 특정 패키지에서 DEBUG 레벨 로그 출력
3. 스택 트레이스(Stack Trace) 분석
예외 발생 시 Spring Boot는 스택 트레이스(Stack Trace) 를 출력하여 오류의 원인을 분석할 수 있도록 한다.

예제 코드 (예외 발생)

public void divideByZero() {
    int result = 10 / 0;
}
스택 트레이스 예시

java.lang.ArithmeticException: / by zero
    at com.example.service.CalculatorService.divideByZero(CalculatorService.java:10)
    at com.example.MainApplication.main(MainApplication.java:15)
스택 트레이스 분석 방법

예외 메시지 확인
java.lang.ArithmeticException: / by zero → 0으로 나누는 연산에서 발생한 오류
문제 발생 위치 추적
CalculatorService.java:10 → 10번째 줄에서 오류 발생
콜 스택(Call Stack) 확인
MainApplication.main(MainApplication.java:15) → 메인 메서드에서 호출됨
⚠️ 주의: 예외 발생 시 전체 로그를 확인하고 근본 원인을 분석해야 한다.

4. Spring Boot Actuator를 활용한 애플리케이션 모니터링
Spring Boot Actuator는 애플리케이션의 상태 및 성능을 실시간으로 모니터링할 수 있는 기능을 제공한다.

Actuator 주요 기능

기능	설명
/actuator/health	애플리케이션 상태 확인 (UP/DOWN)
/actuator/loggers	실시간 로깅 레벨 변경
/actuator/metrics	애플리케이션 성능 지표 제공
/actuator/env	현재 환경 변수 확인
의존성 추가

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
설정 파일에서 Actuator 활성화 (application.yml)

management:
  endpoints:
    web:
      exposure:
        include: "health,info,metrics,loggers"
  endpoint:
    health:
      show-details: always
exposure.include: "health,info,metrics,loggers" → 주요 엔드포인트 활성화
health.show-details: always → 상태 정보를 상세히 표시
Actuator 엔드포인트 확인

http://localhost:8080/actuator/health
{
  "status": "UP"
}
http://localhost:8080/actuator/metrics/jvm.memory.used
{
  "name": "jvm.memory.used",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 123456789
    }
  ]
}
학습자의 사고를 돕기 위한 질문
Spring Boot에서 @Slf4j를 활용한 로그 출력 방법은 어떻게 되는가?

로그 메시지를 어떻게 출력하는지, 로그 레벨별로 어떻게 구분하는지 생각해보라.
debug와 trace 레벨 로그를 어떤 상황에서 사용하는 것이 유리한가?

로그 레벨의 차이를 이해하고, 각각을 활용하는 상황을 떠올려보라.
실습 문제
문제 1: @Slf4j를 활용한 로그 출력 설정
다음 요구사항을 만족하는 코드를 작성하시오.

Spring Boot 애플리케이션에서 @Slf4j를 사용하여 로그를 설정한다.
INFO, DEBUG, ERROR 레벨의 로그를 출력하는 코드 블록을 작성하시오.
각 레벨에 맞는 로그 메시지를 출력하고, 로그 레벨에 맞는 출력이 되는지 확인한다.
문제 2: debug와 trace 레벨 로그 활용
다음 요구사항을 만족하는 코드를 작성하시오.

애플리케이션에서 특정 서비스 메서드가 호출될 때마다 debug 레벨 로그를 출력하도록 설정한다.
trace 레벨 로그를 사용하여 세부적인 메서드 호출 흐름을 추적하도록 설정한다.
메서드 호출 시 로그를 확인하고, debug와 trace 레벨 로그가 출력되는지 확인한다.
8. 프로젝트 빌드 및 배포
8.1. 빌드 및 실행
Spring Boot 애플리케이션을 실행 가능한 상태로 만들기 위해서는 빌드 과정이 필요하다.
빌드는 프로젝트의 소스 코드와 종속성을 패키징하여 실행 가능한 JAR(WAR) 파일을 생성하는 과정이다.
Spring Boot는 Maven과 Gradle 두 가지 빌드 도구를 지원하며, 이를 활용하여 애플리케이션을 빌드하고 실행할 수 있다.

1. Maven을 이용한 빌드
Maven은 Java 프로젝트의 빌드를 자동화하는 도구로, XML 기반의 pom.xml 파일을 사용하여 의존성 및 빌드 설정을 관리한다.

Maven을 이용한 빌드 절차

Maven 빌드 실행

mvn clean package
clean : 이전 빌드 결과물을 삭제
package : JAR 또는 WAR 파일 생성
생성된 JAR 파일 확인

target/ 디렉토리 내에 .jar 파일이 생성됨
예시: target/myapp-0.0.1-SNAPSHOT.jar
애플리케이션 실행

java -jar target/myapp-0.0.1-SNAPSHOT.jar
java -jar 명령어를 이용하여 Spring Boot 애플리케이션 실행
Maven 빌드 설정 예시 (pom.xml)

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
spring-boot-maven-plugin을 사용하면 mvn package 실행 시 실행 가능한 JAR 파일이 생성된다.

2. Gradle을 이용한 빌드
Gradle은 XML 대신 Groovy 또는 Kotlin DSL을 사용하여 프로젝트를 구성하는 빌드 도구다.
Spring Boot 프로젝트는 Gradle을 이용하여 더 간결하고 빠른 빌드가 가능하다.

Gradle을 이용한 빌드 절차

Gradle 빌드 실행

./gradlew clean build
clean : 이전 빌드 결과물을 삭제
build : 실행 가능한 JAR 파일을 생성
생성된 JAR 파일 확인

build/libs/ 디렉토리 내에 .jar 파일이 생성됨
예시: build/libs/myapp-0.0.1-SNAPSHOT.jar
애플리케이션 실행

java -jar build/libs/myapp-0.0.1-SNAPSHOT.jar
Gradle 빌드 설정 예시 (build.gradle)

plugins {
    id 'org.springframework.boot' version '3.1.0'
    id 'io.spring.dependency-management' version '1.1.3'
    id 'java'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
}

tasks.named('test') {
    useJUnitPlatform()
}
org.springframework.boot 플러그인을 사용하면 ./gradlew build 실행 시 JAR 파일이 생성된다.

3. 실행 가능한 JAR(WAR) 생성
Spring Boot 애플리케이션은 기본적으로 JAR 파일로 패키징되지만, 필요에 따라 WAR 파일로도 생성할 수 있다.

JAR 파일로 패키징 (기본)

pom.xml에서 spring-boot-maven-plugin을 사용하면 JAR 파일이 생성된다.
실행 명령: java -jar target/myapp-0.0.1-SNAPSHOT.jar
WAR 파일로 패키징

pom.xml에 다음과 같이 설정 변경
<packaging>war</packaging>
Maven을 이용한 WAR 생성:
mvn clean package
생성된 WAR 파일: target/myapp-0.0.1-SNAPSHOT.war
Tomcat 등의 웹 컨테이너에서 실행 가능
4. 애플리케이션 실행 옵션
빌드 후 java -jar 명령어로 실행할 때 다양한 옵션을 설정할 수 있다.

옵션	설명
--server.port=8081	포트 변경 (기본값: 8080)
--spring.profiles.active=prod	특정 프로파일 활성화
--debug	디버깅 모드 활성화
--Dspring.output.ansi.enabled=always	컬러 로그 활성화
예제: 포트 변경 및 프로파일 지정

java -jar target/myapp-0.0.1-SNAPSHOT.jar --server.port=8081 --spring.profiles.active=prod
8.2. CI/CD 적용
CI/CD(Continuous Integration / Continuous Deployment)는 소프트웨어 개발 프로세스를 자동화하여 지속적인 통합과 배포를 가능하게 하는 기법이다. 이를 활용하면 개발자가 변경한 코드가 자동으로 빌드, 테스트, 배포되며, 오류가 발생하면 즉시 감지할 수 있다.

Spring Boot 애플리케이션의 CI/CD 환경을 구축하기 위해 가장 많이 사용되는 도구는 GitHub Actions와 Jenkins이다.
이번 섹션에서는 GitHub Actions와 Jenkins를 활용하여 CI/CD를 구축하는 방법을 다룬다.

1. GitHub Actions을 활용한 CI/CD
GitHub Actions는 GitHub에서 제공하는 CI/CD 서비스로, GitHub 저장소에서 발생하는 이벤트(예: 코드 푸시, PR 생성)를 감지하여 자동으로 빌드 및 테스트를 실행할 수 있다.

GitHub Actions의 주요 개념

워크플로우(Workflow): CI/CD 작업을 자동화하는 YAML 파일
이벤트(Event): 워크플로우 실행을 트리거하는 GitHub 이벤트(예: push, pull request)
잡(Job): 특정 환경에서 실행되는 일련의 작업(예: 빌드, 테스트, 배포)
스텝(Step): 개별적인 명령어 실행 단계
2. GitHub Actions 설정
GitHub Actions를 사용하려면 .github/workflows/ 디렉토리에 YAML 파일을 생성해야 한다.

1) GitHub Actions CI/CD 파이프라인 설정 아래의 ci-cd.yml 파일을 생성하여 GitHub Actions에서 Spring Boot 애플리케이션을 빌드하고, 테스트를 실행하도록 한다.

name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4

      - name: Java 17 설정
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Maven 빌드 및 테스트 실행
        run: mvn clean package

      - name: 빌드된 JAR 파일 업로드
        uses: actions/upload-artifact@v3
        with:
          name: application
          path: target/*.jar
설명

on: push : main 또는 develop 브랜치에 코드가 푸시될 때 실행된다.
on: pull_request : main 브랜치로 PR이 생성될 때 실행된다.
runs-on: ubuntu-latest : GitHub에서 제공하는 최신 Ubuntu 환경에서 실행된다.
actions/checkout@v4 : GitHub 저장소의 코드를 가져온다.
actions/setup-java@v3 : Java 17을 설치한다.
mvn clean package : Maven을 이용하여 빌드하고 테스트를 실행한다.
actions/upload-artifact@v3 : 빌드된 JAR 파일을 업로드하여 배포 단계에서 사용할 수 있도록 한다.
3. Jenkins를 활용한 CI/CD
Jenkins는 CI/CD를 위한 오픈소스 도구로, 다양한 플러그인을 활용하여 빌드, 테스트, 배포 과정을 자동화할 수 있다.

1) Jenkins 설치 및 기본 설정 Jenkins를 설치하려면 다음 명령어를 실행한다.

# Jenkins 설치 (Ubuntu 기준)
wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -
sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list'
sudo apt update
sudo apt install -y jenkins
설치 후 Jenkins를 실행하고 웹 브라우저에서 http://localhost:8080으로 접속하여 초기 설정을 진행한다.

4. Jenkins를 활용한 Spring Boot 빌드 및 배포
Jenkins에서 Spring Boot 애플리케이션을 빌드하고 배포하는 파이프라인을 설정하기 위해 Jenkinsfile을 작성한다.

1) Jenkinsfile 작성 Jenkinsfile은 Jenkins에서 실행할 CI/CD 프로세스를 정의하는 스크립트 파일이다.

pipeline {
    agent any

    environment {
        JAVA_HOME = "/usr/lib/jvm/java-17-openjdk-amd64"
    }

    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/사용자명/저장소명.git'
            }
        }

        stage('Build & Test') {
            steps {
                sh 'mvn clean package'
            }
        }

        stage('Deploy') {
            steps {
                sh 'scp target/*.jar ubuntu@서버_IP:/home/ubuntu/app.jar'
                sh 'ssh ubuntu@서버_IP "nohup java -jar /home/ubuntu/app.jar &"'
            }
        }
    }
}
설명

stage('Checkout') : GitHub에서 최신 코드를 가져온다.
stage('Build & Test') : Maven을 이용하여 빌드 및 테스트를 실행한다.
stage('Deploy') : 빌드된 JAR 파일을 원격 서버로 전송하고 실행한다.
5. Jenkins와 GitHub 연동
GitHub에서 코드 변경이 발생하면 자동으로 Jenkins가 CI/CD를 실행하도록 설정할 수 있다.

GitHub Webhook 설정 방법

GitHub 저장소에서 Settings → Webhooks로 이동
Add Webhook 클릭
Payload URL에 Jenkins의 GitHub Webhook URL 입력 (예: http://JENKINS_IP:8080/github-webhook/)
Content type을 application/json으로 설정
Just the push event 선택 후 Add webhook 클릭
이제 GitHub에 코드가 푸시될 때마다 Jenkins가 자동으로 CI/CD를 실행한다.

6. 배포 자동화를 위한 추가 설정
CI/CD 파이프라인에서 배포를 더욱 자동화하기 위해 Docker와 Kubernetes를 활용할 수도 있다.

Docker를 이용한 배포 자동화

docker build -t myapp .
docker run -d -p 8080:8080 myapp
Kubernetes를 이용한 배포 자동화

apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: myapp
          image: myapp:latest
          ports:
            - containerPort: 8080
Kubernetes를 사용하면 여러 개의 인스턴스를 실행하고 부하를 분산할 수 있다.

8.3. Docker 및 Kubernetes 배포
애플리케이션의 배포를 자동화하고 확장성을 높이기 위해 Docker와 Kubernetes를 활용한다.
Spring Boot 애플리케이션을 컨테이너화하고 이를 Kubernetes 환경에서 배포 및 관리하는 방법을 설명한다.

1. Docker를 활용한 애플리케이션 컨테이너화
Docker는 애플리케이션을 컨테이너로 패키징하여 실행하는 플랫폼이다. 컨테이너는 운영 체제와 독립적으로 실행되며, 동일한 환경을 유지하면서 어디서든 배포할 수 있는 장점이 있다.

2. Docker 설치 및 환경 설정
먼저 Docker를 설치하고 환경을 구성해야 한다. Ubuntu 기준으로 Docker를 설치하는 방법은 다음과 같다.

# 기존의 오래된 버전 제거
sudo apt-get remove docker docker-engine docker.io containerd runc

# 패키지 업데이트 및 의존성 설치
sudo apt-get update
sudo apt-get install -y \
    ca-certificates \
    curl \
    gnupg \
    lsb-release

# Docker 공식 GPG 키 추가
sudo mkdir -m 0755 -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo tee /etc/apt/keyrings/docker.asc > /dev/null
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Docker 저장소 추가 및 설치
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

sudo apt-get update
sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# Docker 서비스 실행 및 활성화
sudo systemctl start docker
sudo systemctl enable docker
설치가 완료되면 아래 명령어를 실행하여 Docker가 정상적으로 실행되는지 확인한다.

docker --version
3. Dockerfile 작성
Docker를 사용하여 Spring Boot 애플리케이션을 컨테이너화하려면 Dockerfile을 작성해야 한다.

# 베이스 이미지 설정 (AdoptOpenJDK 사용)
FROM openjdk:17-jdk-slim

# JAR 파일을 컨테이너 내부로 복사
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar

# 컨테이너 내부에서 실행될 명령어 설정
ENTRYPOINT ["java","-jar","/app.jar"]

# 컨테이너 실행 시 사용할 포트 설정
EXPOSE 8080
이제 해당 Dockerfile을 이용해 Docker 이미지를 빌드할 수 있다.

docker build -t my-spring-app .
위 명령어가 실행되면 my-spring-app이라는 이름의 Docker 이미지가 생성된다.

4. Docker 컨테이너 실행
Docker 이미지가 생성되었으면 이를 실행할 수 있다.

docker run -d -p 8080:8080 --name my-spring-container my-spring-app
이 명령어는 다음과 같은 작업을 수행한다.

-d : 백그라운드 실행
-p 8080:8080 : 호스트의 8080 포트를 컨테이너의 8080 포트와 매핑
--name my-spring-container : 실행될 컨테이너의 이름 지정
my-spring-app : 실행할 Docker 이미지 지정
실행 중인 컨테이너를 확인하려면 아래 명령어를 실행한다.

docker ps
컨테이너를 중지하려면 다음 명령어를 사용한다.

docker stop my-spring-container
5. Kubernetes를 활용한 컨테이너 오케스트레이션
Kubernetes는 컨테이너화된 애플리케이션을 배포하고 확장할 수 있도록 지원하는 오픈소스 플랫폼이다.
Docker는 개별 컨테이너를 실행하는 도구라면, Kubernetes는 여러 개의 컨테이너를 조율하고 관리하는 역할을 한다.

6. Kubernetes 설치
Kubernetes를 로컬에서 실행하려면 Minikube 또는 K3s를 사용할 수 있다.
여기서는 Minikube를 이용해 Kubernetes 환경을 구축하는 방법을 설명한다.

# Minikube 설치
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# Minikube 시작
minikube start --driver=docker
설치가 완료되면 아래 명령어로 Kubernetes 클러스터 상태를 확인할 수 있다.

kubectl cluster-info
7. Kubernetes Deployment 구성
Kubernetes에서 Spring Boot 애플리케이션을 배포하려면 Deployment 및 Service 파일을 작성해야 한다.

1) Deployment 파일 (spring-app-deployment.yml)

apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: spring-app
  template:
    metadata:
      labels:
        app: spring-app
    spec:
      containers:
        - name: spring-app
          image: my-spring-app
          ports:
            - containerPort: 8080
2) Service 파일 (spring-app-service.yml)

apiVersion: v1
kind: Service
metadata:
  name: spring-app-service
spec:
  selector:
    app: spring-app
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
  type: NodePort
이제 위 두 개의 파일을 사용하여 Kubernetes에 배포한다.

kubectl apply -f spring-app-deployment.yml
kubectl apply -f spring-app-service.yml
실행 중인 Pod를 확인하려면 다음 명령어를 사용한다.

kubectl get pods
애플리케이션이 정상적으로 실행되었는지 확인하려면 아래 명령어를 사용하여 노드의 IP를 찾은 뒤 접속하면 된다.

minikube service spring-app-service --url
8. Docker Compose를 활용한 로컬 개발 환경 구성
Docker Compose는 여러 개의 컨테이너를 한 번에 관리할 수 있는 도구이다.
Spring Boot 애플리케이션과 데이터베이스(MySQL)를 함께 실행하는 환경을 구성하려면 docker-compose.yml 파일을 작성한다.

version: "3.8"

services:
  db:
    image: mysql:8.0
    container_name: mysql-container
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: spring_db
      MYSQL_USER: user
      MYSQL_PASSWORD: password
    ports:
      - "3306:3306"

  app:
    build: .
    container_name: spring-app-container
    ports:
      - "8080:8080"
    depends_on:
      - db
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://db:3306/spring_db
      SPRING_DATASOURCE_USERNAME: user
      SPRING_DATASOURCE_PASSWORD: password
이제 아래 명령어를 실행하여 컨테이너를 실행할 수 있다.

docker-compose up -d
실행 중인 컨테이너를 확인하려면 아래 명령어를 사용한다.

docker-compose ps
모든 컨테이너를 중지하려면 다음 명령어를 실행한다.

docker-compose down
실습 문제
문제 1: Docker를 활용한 애플리케이션 컨테이너화

다음 요구사항을 만족하는 코드를 작성하시오.

Spring Boot 애플리케이션을 Docker 이미지로 빌드한다.
Dockerfile을 작성하여, 애플리케이션을 컨테이너화한다.
애플리케이션을 Docker 컨테이너로 실행한 후, localhost:8080에서 애플리케이션이 정상적으로 작동하는지 확인한다.
문제 2: Kubernetes를 활용한 컨테이너 오케스트레이션

다음 요구사항을 만족하는 코드를 작성하시오.

Docker로 빌드한 애플리케이션을 Kubernetes 클러스터에 배포한다.
Deployment와 Service를 정의하는 YAML 파일을 작성하고, 이를 통해 애플리케이션을 배포한다.
Kubernetes 클러스터에서 배포된 애플리케이션이 정상적으로 작동하는지 확인한다.
연습 문제
문제 1: User 엔티티 클래스 작성
다음 요구사항을 만족하는 User 엔티티 클래스를 작성하시오.

User 클래스는 id, name, email 필드를 갖는다.
id는 자동으로 생성되는 값이다.
name과 email은 각각 String 타입이다.
@Entity, @Id, @GeneratedValue 어노테이션을 사용한다.
문제 2: UserRepository 클래스 작성
다음 요구사항을 만족하는 UserRepository 클래스를 작성하시오.

User 엔티티를 기반으로 JpaRepository를 상속받는다.
findById(), save(), findAll(), delete() 메서드를 사용하여 기본적인 CRUD 메서드를 구현한다.
문제 3: UserService 클래스 작성 및 트랜잭션 처리
다음 요구사항을 만족하는 UserService 클래스를 작성하시오.

@Transactional 어노테이션을 사용하여 registerUser() 메서드에서 트랜잭션을 처리한다.
registerUser() 메서드는 UserRepository를 사용하여 새로운 사용자 데이터를 저장한다.
registerUser() 메서드 실행 후, 트랜잭션이 정상적으로 커밋되거나 롤백되는지 검증할 수 있도록 처리한다.
문제 4: ProductDTO 클래스 작성 및 데이터 검증
다음 요구사항을 만족하는 ProductDTO 클래스를 작성하시오.

ProductDTO는 name, price 필드를 갖는다.
name은 @NotNull 어노테이션을 사용하여 null을 방지하고, @Size(min=2)로 최소 2글자 이상으로 설정한다.
price는 @Min(1) 어노테이션을 사용하여 최소값을 1로 설정한다.
@Valid 어노테이션을 사용하여 DTO 데이터 검증을 한다.
문제 5: ProductController 클래스 작성
다음 요구사항을 만족하는 ProductController 클래스를 작성하시오.

GET /products 요청을 처리하고, Product 객체 리스트를 반환한다.
Product 객체는 id, name, price 필드를 갖고, ResponseEntity로 반환한다.
문제 6: @PreAuthorize를 사용한 권한 기반 접근 제어
다음 요구사항을 만족하는 ProductService 클래스를 작성하시오.

@PreAuthorize("hasRole('ADMIN')") 어노테이션을 사용하여 addProduct() 메서드에 ADMIN 권한을 가진 사용자만 접근할 수 있도록 설정한다.
ProductService에서 Product 객체를 저장하는 메서드를 작성한다.
문제 7: AccessDeniedException 처리
다음 요구사항을 만족하는 AccessDeniedException 처리 로직을 작성하시오.

사용자가 ADMIN 권한을 요구하는 리소스에 접근하려고 시도했을 때, AccessDeniedException 예외가 발생한다.
예외가 발생하면 AccessDeniedHandler에서 이를 처리하고, 사용자에게 적절한 메시지를 반환한다.
문제 8: JWT 인증 토큰 생성 및 검증
다음 요구사항을 만족하는 JWT 인증 시스템을 구현하시오.

사용자가 로그인 시 username과 password를 입력하고, 서버에서 JWT 토큰을 생성하여 반환한다.
클라이언트는 JWT 토큰을 Authorization 헤더에 포함하여 요청한다.
서버는 Authorization 헤더에서 JWT 토큰을 검증하고, 유효한 토큰일 경우 요청을 처리한다.
문제 9: @ExceptionHandler를 활용한 예외 처리
다음 요구사항을 만족하는 예외 처리 로직을 작성하시오.

ProductNotFoundException 예외가 발생하면 @ExceptionHandler로 예외를 처리한다.
예외 처리 시, ProductNotFoundException 메시지를 클라이언트에게 JSON 형태로 반환한다.
문제 10: @Slf4j를 사용한 로그 출력
다음 요구사항을 만족하는 코드를 작성하시오.

@Slf4j 어노테이션을 사용하여 로그 출력을 설정한다.
INFO, DEBUG, ERROR 레벨의 로그를 출력하는 코드 블록을 작성한다.
각 로그 레벨에 맞는 로그 메시지를 출력하고, 로그 레벨에 맞게 출력되는지 확인한다.
답안
1. 프로젝트 환경 설정 및 구조 구성
1.1. 프로젝트 초기화 및 의존성 설정
학습자의 사고를 돕기 위한 질문
Spring Boot 프로젝트를 시작할 때 start.spring.io를 사용하는 이유는 무엇인가?

Spring Boot 프로젝트 생성에 있어 템플릿과 의존성 설정을 효율적으로 관리하기 위한 방식을 생각해보라.
Maven과 Gradle의 차이점은 무엇인가?

두 빌드 도구의 차이점을 기준으로 각자의 장단점을 고려해보라.
1.2. 프로젝트 디렉토리 및 패키지 구조 설계
학습자의 사고를 돕기 위한 질문
controller, service, repository 패키지로 디렉토리를 나누는 이유는 무엇인가?

각 계층의 역할과 책임을 분리하여 유지보수성을 높이는 방법을 떠올려보라.
계층형 아키텍처에서 controller와 service의 역할을 각각 어떻게 정의할 수 있는가?

컨트롤러와 서비스 계층의 구체적인 책임을 생각해보라.
실습 문제
문제 1: 기본적인 Spring Boot 프로젝트 구조 만들기

controller, service, repository 패키지를 생성하여, 기본적인 구조를 세팅한다.
UserController, UserService, UserRepository 클래스를 작성하고 각 클래스에 기본적인 메서드를 추가한다. (예: getUserList(), getUserById())
// UserController.java
package com.example.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import com.example.service.UserService;

@RestController
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/users")
    public List<User> getUserList() {
        return userService.getAllUsers();
    }
}
// UserService.java
package com.example.service;

import org.springframework.stereotype.Service;
import com.example.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
// UserRepository.java
package com.example.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.example.model.User;

public interface UserRepository extends JpaRepository<User, Long> {
}
문제 2: 서비스 계층에 의존성 주입하기

UserController에서 UserService를 주입받아 사용한다.
UserService에서 UserRepository를 주입받아 사용한다.
각 메서드가 해당하는 계층에 맞게 역할을 수행하는지 확인한다.
// UserController.java
package com.example.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import com.example.service.UserService;

@RestController
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/users")
    public List<User> getUserList() {
        return userService.getAllUsers();
    }
}
// UserService.java
package com.example.service;

import org.springframework.stereotype.Service;
import com.example.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
1.3. 환경 설정 파일 작성
학습자의 사고를 돕기 위한 질문
application.properties와 application.yml의 차이점은 무엇인가?

설정 파일의 포맷 차이점과 그에 따른 사용 용도를 생각해보라.
다중 환경(Profile)을 사용하는 이유는 무엇인가?

dev, prod 등 각 환경에 맞는 설정을 분리하여 관리하는 이유에 대해 생각해보라.
2. 데이터베이스 설계 및 연동
2.1. 데이터 모델링 및 엔티티 설계
학습자의 사고를 돕기 위한 질문
@Entity 어노테이션을 사용하여 클래스를 엔티티로 만드는 이유는 무엇인가?

JPA와 엔티티 객체 간의 관계를 떠올려보라.
엔티티 클래스에서 @Id 어노테이션을 사용한 필드가 중요한 이유는 무엇인가?

기본 키 역할을 하며, 데이터베이스에서 레코드를 식별하는 방법에 대해 생각해보라.
@GeneratedValue를 사용하여 자동으로 키 값을 생성하는 이유는 무엇인가?

데이터베이스에서 기본 키를 자동으로 관리하는 방식에 대해 생각해보라.
실습 문제
문제 1: 엔티티 클래스 작성하기

User 클래스는 id, name, email 필드를 갖는다.
id는 자동으로 생성되는 값이다.
name과 email은 각각 String 타입이다.
User 클래스에 대해 @Entity, @Id, @GeneratedValue 어노테이션을 사용한다.
// User.java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;

    // Getters and Setters
}
문제 2: User 엔티티 클래스에 데이터 추가하기

User 클래스는 id, username, password, email 필드를 갖는다.
password는 String 타입이고, 나머지 필드는 String 타입이다.
id는 자동으로 생성된다.
@Entity, @Id, @GeneratedValue 어노테이션을 사용한다.
// User.java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String password;
    private String email;

    // Getters and Setters
}
2.2. JPA 및 Repository 설정
학습자의 사고를 돕기 위한 질문
JpaRepository 인터페이스가 제공하는 기본 CRUD 메서드들은 무엇이 있는가?

findAll(), findById(), save(), delete() 메서드에 대해 생각해보라.
JpaRepository를 상속받는 이유는 무엇인가?

기본적인 데이터베이스 작업을 더 쉽게 처리할 수 있는 방법에 대해 생각해보라.
JPA의 @Query를 사용하여 커스텀 쿼리를 작성하는 이유는 무엇인가?

복잡한 쿼리나 조건을 처리하기 위해 필요한 경우를 떠올려보라.
실습 문제
문제 1: JpaRepository를 사용하여 기본 CRUD 구현하기

User 엔티티 클래스를 기반으로 UserRepository를 작성한다.
findById() 메서드를 사용하여 특정 id를 가진 사용자를 조회한다.
save() 메서드를 사용하여 새로운 사용자 데이터를 추가한다.
// UserRepository.java
package com.example.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.example.model.User;

public interface UserRepository extends JpaRepository<User, Long> {
}
// UserService.java
package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.example.repository.UserRepository;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    public void saveUser(User user) {
        userRepository.save(user);
    }
}
문제 2: @Query를 사용하여 조건에 맞는 사용자 조회하기

UserRepository에 @Query를 사용하여 name이 주어진 값과 일치하는 사용자를 조회하는 쿼리를 작성한다.
name에 해당하는 사용자를 찾는 메서드를 작성한다.
// UserRepository.java
package com.example.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import com.example.model.User;

public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u WHERE u.name = :name")
    User findByName(String name);
}
2.3. 데이터베이스 마이그레이션
실습 문제
문제 1: 데이터베이스 초기화 전략 설정하기

application.properties 파일에서 데이터베이스 초기화 전략을 설정한다.
spring.jpa.hibernate.ddl-auto=create로 설정하여 애플리케이션 실행 시 데이터베이스를 생성한다.
# application.properties
spring.jpa.hibernate.ddl-auto=create
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=root
문제 2: Flyway를 사용하여 마이그레이션 적용하기

Flyway를 사용하여 데이터베이스 마이그레이션을 적용한다.
V1__create_user_table.sql 파일을 작성하여 User 테이블을 생성한다.
application.properties에서 Flyway 설정을 추가한다.
-- V1__create_user_table.sql
CREATE TABLE user (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    password VARCHAR(50),
    email VARCHAR(50)
);
# application.properties
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
3. 비즈니스 로직 구현
3.1. 서비스 계층 설계
학습자의 사고를 돕기 위한 질문
서비스 계층을 도입하는 이유는 무엇인가?

비즈니스 로직을 컨트롤러와 분리함으로써 얻을 수 있는 장점은 무엇인지 생각해보라.
@Service 어노테이션을 사용하여 서비스를 정의하는 이유는 무엇인가?

서비스 계층을 정의할 때 @Service가 가지는 의미와 활용 방법에 대해 생각해보라.
서비스 계층에서 특정 비즈니스 로직을 처리할 때 인터페이스를 사용하는 이유는 무엇인가?

인터페이스를 사용함으로써 얻는 유연성이나 테스트 용이성 등을 고려해보라.
3.2. 트랜잭션 관리
학습자의 사고를 돕기 위한 질문
@Transactional 어노테이션을 사용하는 이유는 무엇인가?

트랜잭션을 적용해야 하는 이유와 그 효과를 생각해보라.
트랜잭션이 적용되었을 때 롤백(rollback) 기능이 중요한 이유는 무엇인가?

트랜잭션 처리 중 문제가 발생했을 때 데이터를 어떻게 안정적으로 유지할 수 있는지 생각해보라.
트랜잭션을 적용할 때 required, mandatory, never와 같은 전파 속성(Propagation)의 차이는 무엇인가?

트랜잭션의 전파 속성이 무엇을 의미하는지, 각각의 속성이 어떤 상황에서 사용되는지 고려해보라.
3.3. DTO 및 변환 로직
학습자의 사고를 돕기 위한 질문
DTO(Data Transfer Object)의 역할은 무엇인가?

엔티티와 DTO를 구분할 때의 장점과 용도를 생각해보라.
DTO와 엔티티 객체 간의 변환은 어떻게 이루어지는가?

DTO를 사용하는 이유와 변환 로직을 어떻게 구현할 수 있을지 고민해보라.
ModelMapper와 MapStruct는 어떤 점에서 유용한 도구인가?

두 라이브러리의 차이점과 각각의 사용 시점을 생각해보라.
실습 문제
문제 1: DTO 변환하기

User 엔티티 클래스와 이를 위한 UserDTO 클래스가 존재한다.
UserDTO는 id, name, email 필드를 포함하며, 엔티티 클래스에서 해당 정보를 DTO로 변환하는 로직을 작성한다.
ModelMapper나 MapStruct를 사용하여 변환 로직을 작성할 수 있다.
// UserDTO.java
package com.example.dto;

public class UserDTO {
    private Long id;
    private String name;
    private String email;

    // Getters and Setters
}
// User.java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class User {
    @Id
    private Long id;
    private String name;
    private String email;

    // Getters and Setters
}
// UserMapper.java
package com.example.mapper;

import com.example.dto.UserDTO;
import com.example.model.User;
import org.modelmapper.ModelMapper;

public class UserMapper {
    public UserDTO convertToDTO(User user) {
        ModelMapper modelMapper = new ModelMapper();
        return modelMapper.map(user, UserDTO.class);
    }
}
문제 2: 여러 엔티티 클래스에 대한 DTO 변환 적용하기

Product 엔티티 클래스와 Order 엔티티 클래스가 각각 존재한다.
ProductDTO와 OrderDTO 클래스는 각각 id, name, price, orderDate 등의 필드를 포함한다.
Product 엔티티와 Order 엔티티를 각각 ProductDTO와 OrderDTO로 변환하는 로직을 작성한다.
// ProductDTO.java
package com.example.dto;

public class ProductDTO {
    private Long id;
    private String name;
    private Double price;

    // Getters and Setters
}
// OrderDTO.java
package com.example.dto;

import java.util.Date;

public class OrderDTO {
    private Long id;
    private Date orderDate;

    // Getters and Setters
}
// Product.java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class Product {
    @Id
    private Long id;
    private String name;
    private Double price;

    // Getters and Setters
}
// Order.java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.Date;

@Entity
public class Order {
    @Id
    private Long id;
    private Date orderDate;

    // Getters and Setters
}
// ProductMapper.java
package com.example.mapper;

import com.example.dto.ProductDTO;
import com.example.model.Product;
import org.modelmapper.ModelMapper;

public class ProductMapper {
    public ProductDTO convertToDTO(Product product) {
        ModelMapper modelMapper = new ModelMapper();
        return modelMapper.map(product, ProductDTO.class);
    }
}
// OrderMapper.java
package com.example.mapper;

import com.example.dto.OrderDTO;
import com.example.model.Order;
import org.modelmapper.ModelMapper;

public class OrderMapper {
    public OrderDTO convertToDTO(Order order) {
        ModelMapper modelMapper = new ModelMapper();
        return modelMapper.map(order, OrderDTO.class);
    }
}
4. RESTful API 개발
4.1. 컨트롤러 설계 및 구현
학습자의 사고를 돕기 위한 질문
@RestController와 @Controller의 차이점은 무엇인가?

@RestController는 HTTP 응답을 JSON 또는 XML 형태로 반환하는 RESTful 웹 서비스용 어노테이션이며, @Controller는 일반적인 HTML 뷰를 반환하는 웹 페이지용 어노테이션이다.
@GetMapping과 @PostMapping의 차이점은 무엇인가?

@GetMapping은 GET 요청을 처리하는 데 사용되고, 데이터를 조회하는 데 사용된다. @PostMapping은 POST 요청을 처리하며, 데이터를 생성하거나 서버에 보내는 데 사용된다.
RESTful API에서 URL 설계 시 고려해야 할 사항은 무엇인가?

URL은 직관적이고 의미가 있어야 하며, 리소스에 대한 접근 방식을 명확히 표현해야 한다. 또한, 계층적인 구조를 통해 리소스 간 관계를 잘 나타내야 한다.
4.2. API 요청 및 응답 처리
실습 문제
문제 1: 단순 GET API 만들기

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @GetMapping
    public Product getProduct() {
        Product product = new Product(1L, "Laptop", 1500.0);
        return product;
    }
}
문제 2: POST 요청으로 데이터 받기

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @PostMapping
    public ProductDTO createProduct(@RequestBody Product product) {
        ProductDTO productDTO = new ProductDTO();
        productDTO.setName(product.getName());
        productDTO.setPrice(product.getPrice());
        return productDTO;
    }
}
4.3. API 데이터 검증 및 예외 처리
학습자의 사고를 돕기 위한 질문
API에서 데이터 검증을 해야 하는 이유는 무엇인가?

데이터 검증을 통해 잘못된 데이터가 시스템에 입력되지 않도록 하여 데이터 무결성을 유지하고, 시스템 안정성을 확보할 수 있다.
@Valid 어노테이션을 사용하는 이유는 무엇인가?

@Valid는 객체의 유효성을 검증할 때 사용되며, DTO 클래스에 적용하여 클라이언트로부터 받은 데이터의 유효성을 자동으로 검사한다.
예외가 발생했을 때, 전역적으로 예외를 처리하는 방법은 무엇인가?

@ExceptionHandler와 @ControllerAdvice를 사용하여 애플리케이션 전역에서 발생한 예외를 한 곳에서 처리하고, 적절한 오류 메시지를 반환할 수 있다.
실습 문제
문제 1: 데이터 검증하기

public class ProductDTO {

    @NotNull(message = "Name cannot be null")
    private String name;

    @Min(value = 1, message = "Price must be greater than 0")
    private Double price;

    // Getters and Setters
}
@RestController
@RequestMapping("/api/products")
public class ProductController {

    @PostMapping
    public ResponseEntity<ProductDTO> createProduct(@Valid @RequestBody ProductDTO productDTO) {
        return new ResponseEntity<>(productDTO, HttpStatus.CREATED);
    }
}
문제 2: 예외 처리하기

public class ProductNotFoundException extends RuntimeException {
    public ProductNotFoundException(String message) {
        super(message);
    }
}

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ProductNotFoundException.class)
    public ResponseEntity<String> handleProductNotFound(ProductNotFoundException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
    }
}
@RestController
@RequestMapping("/api/products")
public class ProductController {

    @GetMapping("/{id}")
    public Product getProduct(@PathVariable Long id) {
        if (id == 1) {
            return new Product(1L, "Laptop", 1500.0);
        }
        throw new ProductNotFoundException("Product not found");
    }
}
5. 인증 및 보안 적용
5.1. Spring Security 기반 인증 및 인가
학습자의 사고를 돕기 위한 질문
Spring Security에서 인증(Authentication)과 인가(Authorization)의 차이점은 무엇인가?

인증은 사용자가 누구인지 확인하는 과정이고, 인가는 사용자가 특정 리소스에 접근할 수 있는 권한을 가지고 있는지를 판단하는 과정이다.
Spring Security에서 기본적인 인증을 구현하려면 어떤 설정이 필요한가?

기본적인 인증을 위해 SecurityConfig 클래스를 설정하고, HttpSecurity 객체를 사용하여 인증 및 인가 관련 규칙을 정의한다. 또한, UserDetailsService와 PasswordEncoder를 사용하여 사용자 정보를 로드하고 비밀번호를 암호화한다.
Spring Security에서 @PreAuthorize 어노테이션을 사용하여 권한 기반 접근 제어를 설정하는 방법은 무엇인가?

@PreAuthorize는 메소드 실행 전에 권한을 검사할 수 있게 해준다. 예를 들어, @PreAuthorize("hasRole('ADMIN')")를 사용하면 ADMIN 권한을 가진 사용자만 해당 메서드를 실행할 수 있다.
5.2. JWT 인증 시스템 구축
실습 문제
문제 1: JWT 생성 및 검증 구현하기

// 로그인 후 JWT 생성
public String createToken(String username) {
    return Jwts.builder()
               .setSubject(username)
               .setExpiration(new Date(System.currentTimeMillis() + 86400000)) // 24 hours
               .signWith(SignatureAlgorithm.HS512, "secret")
               .compact();
}

// JWT 검증
public boolean validateToken(String token) {
    try {
        Jwts.parser().setSigningKey("secret").parseClaimsJws(token);
        return true;
    } catch (JwtException e) {
        return false;
    }
}
문제 2: JWT 인증 필터 구현하기

public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final String HEADER = "Authorization";
    private final String PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String token = request.getHeader(HEADER);

        if (token != null && token.startsWith(PREFIX)) {
            token = token.replace(PREFIX, "");
            if (validateToken(token)) {
                String username = extractUsername(token);
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        filterChain.doFilter(request, response);
    }
}
5.3. 인증 및 보안 예외 처리
학습자의 사고를 돕기 위한 질문
Spring Security에서 AccessDeniedHandler와 AuthenticationEntryPoint의 역할은 무엇인가?

AccessDeniedHandler는 인증은 되었으나 권한이 없는 사용자가 리소스에 접근하려 할 때 발생하는 예외를 처리한다. AuthenticationEntryPoint는 인증이 없을 경우 접근을 차단하는 역할을 한다.
JWT 토큰이 만료되었을 때 발생할 수 있는 예외를 처리하는 방법은 무엇인가?

JWT 토큰이 만료되면 ExpiredJwtException이 발생하며, 이를 @ExceptionHandler로 처리하여 만료된 토큰에 대해 적절한 오류 메시지와 상태 코드를 반환한다.
Spring Security에서 커스텀 예외 처리 방법은 무엇인가?

@ControllerAdvice를 사용하여 전역적으로 예외를 처리하고, @ExceptionHandler를 사용하여 특정 예외에 대한 맞춤형 응답을 반환할 수 있다.
실습 문제
문제 1: 권한 부족 예외 처리하기

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<String> handleAccessDenied(AccessDeniedException ex) {
        return new ResponseEntity<>("You do not have permission to access this resource", HttpStatus.FORBIDDEN);
    }
}
@PreAuthorize("hasRole('ADMIN')")
@GetMapping("/admin")
public String getAdminPage() {
    return "Admin Page";
}
문제 2: 인증 실패 예외 처리하기

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<String> handleAuthenticationException(AuthenticationException ex) {
        return new ResponseEntity<>("Authentication failed. Please provide valid credentials.", HttpStatus.UNAUTHORIZED);
    }
}
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException, ServletException {
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
    }
}
6. 예외 처리 및 로깅
6.1. 글로벌 예외 처리
학습자의 사고를 돕기 위한 질문
@ControllerAdvice를 사용하면 어떤 이점이 있는가?

@ControllerAdvice는 애플리케이션 전역에서 발생하는 예외를 처리할 수 있는 중앙 집중식 처리 방식을 제공하여 코드 중복을 줄이고 관리하기 쉽게 한다.
특정 예외를 처리하는 데 @ExceptionHandler를 사용할 때, 어떻게 특정 예외에만 반응하도록 설정할 수 있는가?

@ExceptionHandler에 특정 예외 클래스나 예외 메시지를 지정하여 해당 예외가 발생했을 때만 해당 메서드가 실행되도록 설정할 수 있다.
6.2. 로깅 프레임워크 설정
실습 문제
문제 1: Slf4j 및 Logback을 활용한 로깅 설정

@Slf4j
@RestController
public class ProductController {

    @GetMapping("/products")
    public List<Product> getProducts() {
        log.info("Fetching all products");
        return productService.getAllProducts();
    }

    @PostMapping("/products")
    public Product createProduct(@RequestBody Product product) {
        log.debug("Creating product: {}", product);
        return productService.createProduct(product);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception ex) {
        log.error("Error occurred: {}", ex.getMessage());
        return new ResponseEntity<>("Internal server error", HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
문제 2: 요청 및 응답 로깅

@Component
public class RequestResponseLoggingFilter implements Filter {

    private static final Logger logger = LoggerFactory.getLogger(RequestResponseLoggingFilter.class);

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        logger.info("Request URL: {}", httpServletRequest.getRequestURL());
        logger.info("Request Parameters: {}", httpServletRequest.getParameterMap());

        chain.doFilter(request, response);

        HttpServletResponse httpServletResponse = (HttpServletResponse) response;
        logger.info("Response Status: {}", httpServletResponse.getStatus());
    }
}
6.3. 성능 모니터링 및 디버깅
학습자의 사고를 돕기 위한 질문
Spring Boot Actuator를 사용하면 어떤 성능 지표를 모니터링할 수 있는가?

Spring Boot Actuator를 사용하면 애플리케이션의 상태, 성능, 메트릭, 로그 등을 모니터링할 수 있으며, metrics, health, env 등의 엔드포인트를 통해 다양한 성능 지표를 확인할 수 있다.
debug와 trace 레벨 로그를 어떻게 활용하여 디버깅을 효율적으로 할 수 있는가?

debug와 trace 레벨 로그는 개발 중 발생하는 문제를 추적하는 데 유용하며, 자세한 정보를 제공하여 문제의 원인을 빠르게 파악할 수 있도록 돕는다.
실습 문제
문제 1: Spring Boot Actuator를 활용한 애플리케이션 모니터링

management.endpoints.web.exposure.include=health,metrics
@RestController
public class ActuatorController {

    @GetMapping("/actuator/metrics")
    public String getMetrics() {
        return "Metrics endpoint activated";
    }

    @GetMapping("/actuator/health")
    public String getHealth() {
        return "Health endpoint activated";
    }
}
문제 2: 디버깅을 위한 debug 로그 활용

@Slf4j
@RestController
public class ProductController {

    @GetMapping("/product/{id}")
    public Product getProduct(@PathVariable Long id) {
        log.debug("Fetching product with ID: {}", id);
        return productService.getProductById(id);
    }
}
7. 테스트 및 디버깅
7.1. 단위 테스트 작성
실습 문제
문제 1: 서비스 계층 단위 테스트 작성

@RunWith(SpringRunner.class)
@SpringBootTest
public class UserServiceTest {

    @MockBean
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    public void testRegisterUser() {
        User user = new User("john", "john@example.com");
        Mockito.when(userRepository.save(Mockito.any(User.class))).thenReturn(user);

        User registeredUser = userService.registerUser(user);

        assertNotNull(registeredUser);
        assertEquals("john", registeredUser.getName());
        Mockito.verify(userRepository).save(user);
    }
}
7.2. API 통합 테스트
실습 문제
문제 1: REST API 통합 테스트

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testCreateUser() throws Exception {
        UserDTO userDTO = new UserDTO("john", "john@example.com");

        mockMvc.perform(post("/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(new ObjectMapper().writeValueAsString(userDTO)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.name").value("john"))
                .andExpect(jsonPath("$.email").value("john@example.com"));
    }
}
7.3. 디버깅 및 오류 분석
학습자의 사고를 돕기 위한 질문
Spring Boot에서 @Slf4j를 활용한 로그 출력 방법은 어떻게 되는가?

@Slf4j를 사용하면 log.info(), log.debug(), log.error() 등을 통해 로그를 출력할 수 있다. 각 로그 레벨을 상황에 맞게 사용하여 애플리케이션의 흐름을 추적할 수 있다.
debug와 trace 레벨 로그를 어떤 상황에서 사용하는 것이 유리한가?

debug 레벨 로그는 개발 중에 일반적인 흐름을 추적할 때 유용하고, trace 레벨 로그는 더 세부적인 내부 동작이나 함수 호출 과정을 추적할 때 사용한다.
실습 문제
문제 1: @Slf4j를 활용한 로그 출력 설정

@Slf4j
@RestController
public class ProductController {

    @GetMapping("/products")
    public List<Product> getProducts() {
        log.info("Fetching all products");
        return productService.getAllProducts();
    }

    @PostMapping("/products")
    public Product createProduct(@RequestBody Product product) {
        log.debug("Creating product: {}", product);
        return productService.createProduct(product);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception ex) {
        log.error("Error occurred: {}", ex.getMessage());
        return new ResponseEntity<>("Internal server error", HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
문제 2: debug와 trace 레벨 로그 활용

@Slf4j
@Service
public class ProductService {

    public Product getProductById(Long id) {
        log.debug("Entering method getProductById with ID: {}", id);
        Product product = productRepository.findById(id).orElseThrow(() -> new ProductNotFoundException("Product not found"));
        log.trace("Retrieved product: {}", product);
        return product;
    }
}
8. 프로젝트 빌드 및 배포
8.3. Docker 및 Kubernetes 배포
실습 문제
문제 1: Docker를 활용한 애플리케이션 컨테이너화

# Dockerfile
FROM openjdk:11-jre-slim
VOLUME /tmp
COPY target/myapp.jar app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]
# 빌드 및 실행 명령
docker build -t myapp .
docker run -p 8080:8080 myapp
문제 2: Kubernetes를 활용한 컨테이너 오케스트레이션

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: myapp
          image: myapp:latest
          ports:
            - containerPort: 8080

---
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: LoadBalancer
# 배포 명령
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
9. 연습 문제에 대한 답안
9.1 User 엔티티 클래스 작성

정답:
User 엔티티 클래스는 @Entity 어노테이션을 사용하고 id를 자동으로 생성하도록 설정한다. name과 email은 String 타입으로 정의된다.

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // Getters and Setters
}
9.2 UserRepository 클래스 작성

정답:
JpaRepository를 상속받아 기본적인 CRUD 메서드를 제공하는 UserRepository 클래스를 작성한다.

import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {

    // 기본적인 CRUD 메서드 제공됨
    // 예: findById(), save(), findAll(), delete()
}
9.3 UserService 클래스 작성 및 트랜잭션 처리

정답:
@Transactional을 사용하여 트랜잭션을 처리하는 registerUser() 메서드를 포함한 UserService 클래스를 작성한다.

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public User registerUser(User user) {
        // 사용자 저장 로직
        return userRepository.save(user);
    }
}
9.4 ProductDTO 클래스 작성 및 데이터 검증

정답:
ProductDTO 클래스에서 @NotNull, @Size, @Min 등의 데이터 검증 어노테이션을 사용하여 유효성 검사를 한다.

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.validation.constraints.Min;

public class ProductDTO {

    @NotNull
    @Size(min = 2)
    private String name;

    @Min(1)
    private double price;

    // Getters and Setters
}
9.5 ProductController 클래스 작성

정답:
@RestController를 사용하여 GET /products 엔드포인트에서 Product 객체 리스트를 반환하는 ProductController 클래스를 작성한다.

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.http.ResponseEntity;
import java.util.List;

@RestController
public class ProductController {

    @GetMapping("/products")
    public ResponseEntity<List<Product>> getAllProducts() {
        // Product 리스트 반환
        return ResponseEntity.ok(productRepository.findAll());
    }
}
9.6 @PreAuthorize를 사용한 권한 기반 접근 제어

정답:
@PreAuthorize 어노테이션을 사용하여 ADMIN 권한을 가진 사용자만 addProduct() 메서드에 접근할 수 있도록 한다.

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;

@Service
public class ProductService {

    @PreAuthorize("hasRole('ADMIN')")
    public Product addProduct(Product product) {
        return productRepository.save(product);
    }
}
9.7 AccessDeniedException 처리

정답:
AccessDeniedException 예외가 발생할 때 AccessDeniedHandler에서 이를 처리하고, 사용자에게 적절한 메시지를 반환한다.

import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException {
        ResponseEntity.status(HttpStatus.FORBIDDEN).body("Access Denied: You do not have permission to access this resource.");
    }
}
9.8 JWT 인증 토큰 생성 및 검증

정답:
JWT 토큰을 생성하고 검증하는 로직을 작성한다. 클라이언트는 Authorization 헤더를 통해 토큰을 전송하고, 서버는 이를 검증하여 유효한 요청만 처리한다.

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

public class JwtUtils {

    private String secretKey = "mySecretKey";

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();
    }

    public Claims extractClaims(String token) {
        return Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean validateToken(String token, String username) {
        return username.equals(extractClaims(token).getSubject()) && !isTokenExpired(token);
    }

    private boolean isTokenExpired(String token) {
        return extractClaims(token).getExpiration().before(new Date());
    }
}
9.9 @ExceptionHandler를 활용한 예외 처리

정답:
@ExceptionHandler를 사용하여 예외를 처리하고, 클라이언트에게 적절한 오류 메시지를 반환한다.

import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.http.ResponseEntity;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ProductNotFoundException.class)
    public ResponseEntity<String> handleProductNotFound(ProductNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }
}
9.10 @Slf4j를 사용한 로그 출력

정답:
@Slf4j를 사용하여 로그를 출력하는 코드 예제이다. INFO, DEBUG, ERROR 레벨의 로그를 작성한다.

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Slf4j
public class ProductService {

    public void createProduct(Product product) {
        log.info("Creating product with name: {}", product.getName());
        try {
            // 제품 생성 로직
            log.debug("Product creation debug info");
        } catch (Exception e) {
            log.error("Error occurred while creating product", e);
        }
    }
}
닫기
